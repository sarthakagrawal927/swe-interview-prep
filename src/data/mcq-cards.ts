import type { MCQCard } from '../types';

// ─── DSA MCQ Cards ──────────────────────────────────────────────────────────
export const DSA_MCQ_CARDS: MCQCard[] = [
  // ===== ARRAYS & HASHING =====
  { id: 'two-sum-mcq-1', problemId: 'two-sum', difficulty: 'medium',
    question: 'Which approach reduces Two Sum from O(n^2) to O(n)?',
    options: ['Sorting the array then binary search', 'Hash map storing value -> index', 'Two pointers from both ends', 'Prefix sum array'],
    correctIndex: 1, explanation: 'A hash map allows O(1) lookup for the complement (target - num) as you iterate, giving O(n) total time.' },
  { id: 'two-sum-mcq-2', problemId: 'two-sum', difficulty: 'hard',
    question: 'For nums = [3, 3], target = 6, what does the hash map approach return?',
    options: ['[0, 0]', '[0, 1]', 'Error: duplicate keys overwrite', 'Empty array'],
    correctIndex: 1, explanation: 'When processing index 1, we check if 6-3=3 exists in the map. It does (index 0), so we return [0, 1]. We check BEFORE inserting, so no overwrite issue.' },
  { id: 'two-sum-mcq-3', problemId: 'two-sum', difficulty: 'hard',
    question: 'Why can\'t you sort the array and use two pointers for Two Sum when you need to return original indices?',
    options: ['Sorting is O(n log n) which is too slow', 'Sorting destroys the original index mapping', 'Two pointers only works on positive numbers', 'Two pointers can\'t handle duplicates'],
    correctIndex: 1, explanation: 'Sorting rearranges elements, losing original indices. You\'d need to store original indices alongside values, adding complexity. Hash map is simpler.' },

  { id: 'group-anagrams-mcq-1', problemId: 'group-anagrams', difficulty: 'medium',
    question: 'What is the most efficient key strategy for grouping anagrams?',
    options: ['Sort each string alphabetically', 'Character frequency count as tuple/string', 'Hash of character XOR values', 'Compare all pairs of strings'],
    correctIndex: 1, explanation: 'Character frequency count gives O(k) per string vs O(k log k) for sorting. Use counts like "1#0#0#...#0" as keys.' },
  { id: 'group-anagrams-mcq-2', problemId: 'group-anagrams', difficulty: 'hard',
    question: 'For input ["eat","tea","tan","ate","nat","bat"], how many groups are formed?',
    options: ['2', '3', '4', '6'],
    correctIndex: 1, explanation: 'Three groups: ["eat","tea","ate"], ["tan","nat"], ["bat"]. Anagrams share the same sorted characters.' },
  { id: 'group-anagrams-mcq-3', problemId: 'group-anagrams', difficulty: 'hard',
    question: 'Why is using XOR of character codes a bad key for grouping anagrams?',
    options: ['XOR is too slow to compute', 'Different strings can have the same XOR value (collisions)', 'XOR doesn\'t work with Unicode', 'XOR produces negative values'],
    correctIndex: 1, explanation: '"ab" and "ba" would match (good), but "ad" and "bc" could also collide since XOR loses count information.' },

  { id: 'longest-consecutive-mcq-1', problemId: 'longest-consecutive-sequence', difficulty: 'medium',
    question: 'How do you achieve O(n) for Longest Consecutive Sequence?',
    options: ['Sort then linear scan', 'Hash set + only count from sequence starts', 'Union-Find on consecutive pairs', 'BFS from every element'],
    correctIndex: 1, explanation: 'Put all numbers in a Set. Only start counting when (num-1) is NOT in the set. Each number is visited at most twice total.' },
  { id: 'longest-consecutive-mcq-2', problemId: 'longest-consecutive-sequence', difficulty: 'hard',
    question: 'For nums = [100, 4, 200, 1, 3, 2], what is the longest consecutive sequence length?',
    options: ['3', '4', '5', '6'],
    correctIndex: 1, explanation: 'The sequence [1, 2, 3, 4] has length 4. The numbers 100 and 200 are isolated.' },
  { id: 'longest-consecutive-mcq-3', problemId: 'longest-consecutive-sequence', difficulty: 'hard',
    question: 'Why is the hash set solution O(n) despite having a while loop inside a for loop?',
    options: ['The while loop runs at most log(n) times', 'Each element is visited by the inner loop at most once across ALL iterations', 'The for loop skips most elements', 'Hash set lookups are O(1) amortized'],
    correctIndex: 1, explanation: 'Only sequence starts trigger the while loop. Each number participates in at most one sequence count. Total inner loop iterations across all outer iterations is at most n.' },

  { id: 'contains-duplicate-mcq-1', problemId: 'contains-duplicate', difficulty: 'medium',
    question: 'Which approach detects duplicates in O(n) time and O(n) space?',
    options: ['Sort then check adjacent elements', 'Hash Set - add and check each element', 'Nested loops comparing all pairs', 'Bit manipulation with XOR'],
    correctIndex: 1, explanation: 'A Set provides O(1) lookup. For each element, check if it\'s in the set; if yes, duplicate found. If no, add it.' },
  { id: 'contains-duplicate-mcq-2', problemId: 'contains-duplicate', difficulty: 'hard',
    question: 'You have nums = [1, 2, 3, 1]. At which iteration does the Set approach detect the duplicate?',
    options: ['Iteration 1 (value 1)', 'Iteration 2 (value 2)', 'Iteration 3 (value 3)', 'Iteration 4 (value 1)'],
    correctIndex: 3, explanation: 'At iteration 4, we check if 1 is in the set {1,2,3}. It is, so we return true. The first three iterations just add to the set.' },

  { id: 'product-except-self-mcq-1', problemId: 'product-of-array-except-self', difficulty: 'medium',
    question: 'How do you solve Product of Array Except Self without division?',
    options: ['Prefix product * suffix product for each index', 'Nested loop multiplying all except current', 'Sort then use cumulative products', 'Use logarithms to convert to addition'],
    correctIndex: 0, explanation: 'Build prefix products (left to right) and suffix products (right to left). result[i] = prefix[i] * suffix[i].' },
  { id: 'product-except-self-mcq-2', problemId: 'product-of-array-except-self', difficulty: 'hard',
    question: 'For nums = [1, 2, 3, 4], what is output[2] (product except self at index 2)?',
    options: ['6', '8', '12', '24'],
    correctIndex: 1, explanation: 'Product of all elements except index 2 (value 3): 1 * 2 * 4 = 8.' },
  { id: 'product-except-self-mcq-3', problemId: 'product-of-array-except-self', difficulty: 'hard',
    question: 'Why does the division approach fail for Product of Array Except Self?',
    options: ['Division is O(n^2)', 'It fails when any element is zero', 'Division causes floating point errors', 'It requires extra space'],
    correctIndex: 1, explanation: 'If any element is 0, total product is 0 and you can\'t divide by 0. You\'d need special handling for zero counts.' },

  { id: 'valid-anagram-mcq-1', problemId: 'valid-anagram', difficulty: 'medium',
    question: 'What is the optimal approach for checking if two strings are anagrams?',
    options: ['Sort both strings and compare', 'Character frequency count array', 'XOR all characters together', 'Use a stack to match characters'],
    correctIndex: 1, explanation: 'A 26-element frequency array gives O(n) time. Increment for string 1, decrement for string 2, check all zeros.' },
  { id: 'valid-anagram-mcq-2', problemId: 'valid-anagram', difficulty: 'hard',
    question: 'If s = "anagram" and t = "nagaram", what should every count in the frequency array be after processing both?',
    options: ['26', '1', '0', '-1'],
    correctIndex: 2, explanation: 'For each character, incrementing for s and decrementing for t should cancel out to 0 if they are anagrams.' },

  { id: 'top-k-frequent-mcq-1', problemId: 'top-k-frequent-elements', difficulty: 'medium',
    question: 'Which approach gives O(n) time for Top K Frequent Elements?',
    options: ['Sort by frequency', 'Min-heap of size k', 'Bucket sort where index = frequency', 'Quickselect on frequencies'],
    correctIndex: 2, explanation: 'Bucket sort: create array of size n+1 where index = frequency. Fill buckets, then collect from highest bucket. O(n) time.' },
  { id: 'top-k-frequent-mcq-2', problemId: 'top-k-frequent-elements', difficulty: 'hard',
    question: 'For nums = [1,1,1,2,2,3], k = 2, what does the bucket sort approach return?',
    options: ['[1, 2]', '[2, 3]', '[1, 3]', '[3, 2]'],
    correctIndex: 0, explanation: 'Frequencies: 1->3, 2->2, 3->1. Buckets: index 3 has [1], index 2 has [2], index 1 has [3]. Taking top 2: [1, 2].' },

  // ===== TWO POINTERS =====
  { id: 'container-water-mcq-1', problemId: 'container-with-most-water', difficulty: 'medium',
    question: 'Why does the two-pointer approach work for Container With Most Water?',
    options: ['It always picks the tallest lines', 'Moving the shorter pointer can only improve the area', 'It checks all possible pairs efficiently', 'The width always decreases so we maximize height'],
    correctIndex: 1, explanation: 'The shorter line limits the area. Moving it inward might find a taller line and increase area. Moving the taller line can only decrease or maintain area (width shrinks).' },
  { id: 'container-water-mcq-2', problemId: 'container-with-most-water', difficulty: 'hard',
    question: 'For height = [1,8,6,2,5,4,8,3,7], what is the maximum water area?',
    options: ['36', '40', '49', '56'],
    correctIndex: 2, explanation: 'Between indices 1 (h=8) and 8 (h=7): min(8,7) * (8-1) = 7 * 7 = 49.' },

  { id: '3sum-mcq-1', problemId: '3sum', difficulty: 'medium',
    question: 'What is the key step to solve 3Sum in O(n^2)?',
    options: ['Hash map for complement lookup', 'Sort array then use two pointers for each fixed element', 'Three nested loops with early termination', 'Divide and conquer on the sorted array'],
    correctIndex: 1, explanation: 'Sort the array. Fix one element, then use two pointers on the remaining subarray to find pairs that sum to its negation.' },
  { id: '3sum-mcq-2', problemId: '3sum', difficulty: 'hard',
    question: 'In 3Sum, how do you avoid duplicate triplets?',
    options: ['Use a Set to store results', 'Skip duplicate values when moving each pointer', 'Only consider unique elements', 'Sort results and remove duplicates at the end'],
    correctIndex: 1, explanation: 'After finding a valid triplet, skip duplicate values for the fixed element and both pointers (while nums[i] == nums[i-1], skip).' },
  { id: '3sum-mcq-3', problemId: '3sum', difficulty: 'hard',
    question: 'For nums = [-1, 0, 1, 2, -1, -4], how many unique triplets sum to 0?',
    options: ['1', '2', '3', '4'],
    correctIndex: 1, explanation: 'Two triplets: [-1, -1, 2] and [-1, 0, 1]. After sorting: [-4, -1, -1, 0, 1, 2].' },

  { id: 'trapping-rain-mcq-1', problemId: 'trapping-rain-water', difficulty: 'hard',
    question: 'In the two-pointer approach for Trapping Rain Water, what determines how much water a position holds?',
    options: ['min(leftMax, rightMax) - height[i]', 'max(leftMax, rightMax) - height[i]', 'leftMax + rightMax - height[i]', 'abs(leftMax - rightMax)'],
    correctIndex: 0, explanation: 'Water at position i is bounded by the shorter of the two max heights on either side, minus the ground height at i.' },
  { id: 'trapping-rain-mcq-2', problemId: 'trapping-rain-water', difficulty: 'hard',
    question: 'For height = [0,1,0,2,1,0,1,3,2,1,2,1], how much water is trapped?',
    options: ['4', '5', '6', '8'],
    correctIndex: 2, explanation: 'The trapped water is 6 units. Each position contributes: min(leftMax, rightMax) - height[i] when positive.' },

  { id: 'valid-palindrome-mcq-1', problemId: 'valid-palindrome', difficulty: 'medium',
    question: 'What is the key technique for checking palindromes with non-alphanumeric characters?',
    options: ['Remove all non-alphanumeric chars first', 'Two pointers that skip non-alphanumeric chars', 'Reverse the string and compare', 'Use regex replacement then compare'],
    correctIndex: 1, explanation: 'Two pointers from both ends, skipping non-alphanumeric characters and comparing case-insensitively. O(n) time, O(1) space.' },

  { id: 'two-sum-ii-mcq-1', problemId: 'two-sum-ii', difficulty: 'medium',
    question: 'Why do two pointers work for Two Sum II on a sorted array?',
    options: ['Pointers move toward each other, narrowing the search', 'If sum > target, right pointer decreases sum; if sum < target, left pointer increases sum', 'Sorted arrays have no duplicates', 'Binary search is embedded in the pointer movement'],
    correctIndex: 1, explanation: 'Since the array is sorted, moving left pointer right increases the sum, and moving right pointer left decreases it. This gives a systematic way to find the target.' },

  // ===== SLIDING WINDOW =====
  { id: 'longest-substring-mcq-1', problemId: 'longest-substring-without-repeating-characters', difficulty: 'medium',
    question: 'What data structure tracks characters in the current window for Longest Substring Without Repeating Characters?',
    options: ['Array of 26 booleans', 'Hash Set of characters', 'Hash Map of character -> last index', 'Queue of characters'],
    correctIndex: 2, explanation: 'A hash map storing character -> last seen index lets you jump the left pointer directly to one past the duplicate, avoiding char-by-char shrinking.' },
  { id: 'longest-substring-mcq-2', problemId: 'longest-substring-without-repeating-characters', difficulty: 'hard',
    question: 'For s = "abcabcbb", what is the length of the longest substring without repeating characters?',
    options: ['2', '3', '4', '5'],
    correctIndex: 1, explanation: 'The answer is 3 ("abc"). When we hit the second "a", the window resets.' },

  { id: 'min-window-substr-mcq-1', problemId: 'minimum-window-substring', difficulty: 'hard',
    question: 'In Minimum Window Substring, when do you shrink the window?',
    options: ['When window size exceeds t.length', 'When all characters of t are satisfied in the window', 'When a duplicate character is found', 'After every expansion step'],
    correctIndex: 1, explanation: 'Expand right until all of t\'s characters are satisfied, then shrink from left to minimize. Track satisfaction with a counter of matched characters.' },
  { id: 'min-window-substr-mcq-2', problemId: 'minimum-window-substring', difficulty: 'hard',
    question: 'For s = "ADOBECODEBANC", t = "ABC", what is the minimum window substring?',
    options: ['"ADOBEC"', '"BANC"', '"BECODEBA"', '"CODEBA"'],
    correctIndex: 1, explanation: '"BANC" (length 4) is the smallest window containing A, B, and C.' },

  { id: 'best-buy-sell-mcq-1', problemId: 'best-time-to-buy-and-sell-stock', difficulty: 'medium',
    question: 'What is the key insight for Best Time to Buy and Sell Stock in O(n)?',
    options: ['Track max price seen so far', 'Track min price seen so far, compute profit at each step', 'Use two pointers from both ends', 'Sort prices and take difference of max and min'],
    correctIndex: 1, explanation: 'Track the minimum price seen. At each price, compute profit = current - minSoFar. Track max profit across all steps.' },
  { id: 'best-buy-sell-mcq-2', problemId: 'best-time-to-buy-and-sell-stock', difficulty: 'hard',
    question: 'For prices = [7,1,5,3,6,4], what is the maximum profit?',
    options: ['4', '5', '6', '7'],
    correctIndex: 1, explanation: 'Buy at 1 (day 2), sell at 6 (day 5). Profit = 6 - 1 = 5.' },

  { id: 'longest-repeating-mcq-1', problemId: 'longest-repeating-character-replacement', difficulty: 'hard',
    question: 'In Longest Repeating Character Replacement with k replacements, what condition triggers window shrinking?',
    options: ['Window size > 26', 'Window size - count of most frequent char > k', 'Number of distinct chars > k', 'Any character count exceeds k'],
    correctIndex: 1, explanation: 'windowLength - maxFreqCount > k means we need more than k replacements. Shrink the window from the left.' },

  // ===== STACK =====
  { id: 'valid-parens-mcq-1', problemId: 'valid-parentheses', difficulty: 'medium',
    question: 'Why is a stack the ideal data structure for Valid Parentheses?',
    options: ['Stacks support O(1) search', 'LIFO order matches nested bracket closing order', 'Stacks can store pairs of brackets', 'Stacks automatically validate nesting'],
    correctIndex: 1, explanation: 'The most recently opened bracket must be closed first (LIFO). Push opening brackets, pop and match on closing brackets.' },
  { id: 'valid-parens-mcq-2', problemId: 'valid-parentheses', difficulty: 'hard',
    question: 'For s = "([)]", is it valid?',
    options: ['Yes, all brackets are matched', 'No, brackets are improperly nested', 'Yes, each type appears equal times', 'Depends on the implementation'],
    correctIndex: 1, explanation: 'Opening "[" would need to close before "(". When we see ")", the stack top is "[" which doesn\'t match.' },

  // ===== BINARY SEARCH =====
  { id: 'search-rotated-mcq-1', problemId: 'search-in-rotated-sorted-array', difficulty: 'hard',
    question: 'In Search in Rotated Sorted Array, how do you decide which half to search?',
    options: ['Always search the larger half', 'Determine which half is sorted, then check if target is in that range', 'Compare target with the pivot element', 'Use two binary searches: find pivot, then search'],
    correctIndex: 1, explanation: 'If nums[left] <= nums[mid], left half is sorted. Check if target is in [left, mid]. Otherwise, right half is sorted. This works in a single binary search.' },
  { id: 'search-rotated-mcq-2', problemId: 'search-in-rotated-sorted-array', difficulty: 'hard',
    question: 'For nums = [4,5,6,7,0,1,2], target = 0, what index is returned?',
    options: ['0', '3', '4', '6'],
    correctIndex: 2, explanation: '0 is at index 4. Binary search identifies the right half as containing the target.' },

  { id: 'find-min-rotated-mcq-1', problemId: 'find-minimum-in-rotated-sorted-array', difficulty: 'hard',
    question: 'In Find Minimum in Rotated Sorted Array, what does nums[mid] > nums[right] tell you?',
    options: ['Minimum is in the left half', 'Minimum is in the right half (mid+1 to right)', 'Mid is the minimum', 'Array is not rotated'],
    correctIndex: 1, explanation: 'If nums[mid] > nums[right], the rotation point (minimum) must be between mid+1 and right.' },

  // ===== LINKED LIST =====
  { id: 'remove-nth-mcq-1', problemId: 'remove-nth-node-from-end-of-list', difficulty: 'medium',
    question: 'How do you remove the nth node from the end in one pass?',
    options: ['Count length first, then traverse again', 'Use two pointers with n gap between them', 'Use a stack to store all nodes', 'Reverse the list first'],
    correctIndex: 1, explanation: 'Advance the fast pointer n steps ahead. Then move both pointers until fast reaches the end. Slow is now at the node before the target.' },

  { id: 'merge-sorted-mcq-1', problemId: 'merge-two-sorted-lists', difficulty: 'medium',
    question: 'What is the key to merging two sorted linked lists?',
    options: ['Convert to arrays, merge, convert back', 'Compare heads, attach smaller, advance that pointer', 'Always attach from list 1 first', 'Use a priority queue'],
    correctIndex: 1, explanation: 'Use a dummy head. Compare current nodes of both lists, attach the smaller one, advance that list\'s pointer. O(n+m) time.' },

  { id: 'merge-k-mcq-1', problemId: 'merge-k-sorted-lists', difficulty: 'hard',
    question: 'What is the optimal approach for Merge K Sorted Lists?',
    options: ['Merge all lists sequentially one by one', 'Min-heap of size k holding current heads', 'Convert all to one array and sort', 'Divide and conquer: pairwise merge'],
    correctIndex: 1, explanation: 'A min-heap of k current heads gives O(N log k) where N is total nodes. Always extract min and push next node from that list.' },
  { id: 'merge-k-mcq-2', problemId: 'merge-k-sorted-lists', difficulty: 'hard',
    question: 'Why is merging k lists one by one O(Nk) instead of O(N log k)?',
    options: ['Each merge doubles the list size, so later merges process more nodes', 'Sequential merge doesn\'t use a heap', 'The first list gets traversed k-1 times', 'One-by-one merge can\'t handle duplicates efficiently'],
    correctIndex: 0, explanation: 'Merging list 1+2 creates a list of size ~2n. Merging that with list 3 processes ~3n nodes. Total: 2n + 3n + ... + kn = O(Nk).' },

  { id: 'linked-list-cycle-mcq-1', problemId: 'linked-list-cycle', difficulty: 'medium',
    question: 'How does Floyd\'s cycle detection (tortoise and hare) work?',
    options: ['Mark visited nodes with a flag', 'Fast pointer moves 2 steps, slow moves 1; they meet if cycle exists', 'Store all node addresses in a Set', 'Reverse the list and check if head is reached again'],
    correctIndex: 1, explanation: 'If there\'s a cycle, the fast pointer (2x speed) will eventually catch the slow pointer inside the cycle. O(1) space.' },

  { id: 'reorder-list-mcq-1', problemId: 'reorder-list', difficulty: 'hard',
    question: 'What are the three steps to reorder a linked list L0->L1->...->Ln to L0->Ln->L1->Ln-1...?',
    options: ['Reverse then merge', 'Find middle, reverse second half, merge alternately', 'Use a deque to interleave', 'Copy to array, rearrange, rebuild list'],
    correctIndex: 1, explanation: 'Find middle (slow/fast pointers), reverse the second half, then merge the two halves by alternating nodes.' },

  { id: 'reverse-ll-mcq-1', problemId: 'reverse-linked-list', difficulty: 'medium',
    question: 'In iterative linked list reversal, how many pointers do you need?',
    options: ['1 (current)', '2 (prev, current)', '3 (prev, current, next)', '4 (head, prev, current, next)'],
    correctIndex: 2, explanation: 'You need prev (initially null), current, and next (saved before reversing). At each step: save next, reverse pointer, advance prev and current.' },

  // ===== TREES =====
  { id: 'validate-bst-mcq-1', problemId: 'validate-binary-search-tree', difficulty: 'hard',
    question: 'Why is checking node.left.val < node.val < node.right.val insufficient for BST validation?',
    options: ['It doesn\'t handle null nodes', 'It only checks immediate children, not all descendants', 'BSTs allow equal values', 'It doesn\'t work with negative numbers'],
    correctIndex: 1, explanation: 'A node in the left subtree could be greater than an ancestor. You need to pass min/max bounds down the tree.' },

  { id: 'level-order-mcq-1', problemId: 'binary-tree-level-order-traversal', difficulty: 'medium',
    question: 'Which data structure is used for level order traversal?',
    options: ['Stack', 'Queue', 'Priority Queue', 'Hash Map'],
    correctIndex: 1, explanation: 'BFS uses a queue. Process all nodes at current level (queue size), pushing their children for the next level.' },

  { id: 'max-depth-mcq-1', problemId: 'maximum-depth-of-binary-tree', difficulty: 'medium',
    question: 'What is the recursive formula for max depth of a binary tree?',
    options: ['1 + left.depth + right.depth', '1 + max(left.depth, right.depth)', 'max(left.depth, right.depth)', '1 + min(left.depth, right.depth)'],
    correctIndex: 1, explanation: 'Max depth = 1 (current node) + maximum of left and right subtree depths. Base case: null node returns 0.' },

  { id: 'construct-tree-mcq-1', problemId: 'construct-binary-tree-from-preorder-and-inorder-traversal', difficulty: 'hard',
    question: 'In constructing a tree from preorder and inorder traversals, what does the first preorder element tell you?',
    options: ['The leftmost leaf', 'The root of the current subtree', 'The rightmost node', 'The tree depth'],
    correctIndex: 1, explanation: 'Preorder visits root first. Find this root in inorder to split into left and right subtrees. Recurse on each half.' },

  { id: 'max-path-sum-mcq-1', problemId: 'binary-tree-maximum-path-sum', difficulty: 'hard',
    question: 'In Binary Tree Maximum Path Sum, why can\'t you return the path through both children to the parent?',
    options: ['It would be too slow', 'A path through both children forms a "V" which can\'t extend upward', 'Children might be null', 'The sum might be negative'],
    correctIndex: 1, explanation: 'A path that goes left-child -> node -> right-child can\'t also go to the parent (would visit the node twice). So we return max(left, right) + node to parent, but track the V-path as a candidate answer.' },

  { id: 'invert-tree-mcq-1', problemId: 'invert-binary-tree', difficulty: 'medium',
    question: 'What does inverting a binary tree mean?',
    options: ['Reverse the values in-order', 'Swap left and right children at every node', 'Rotate the tree 180 degrees', 'Mirror only the leaf nodes'],
    correctIndex: 1, explanation: 'Recursively swap left and right children at every node. The result is a mirror image of the original tree.' },

  { id: 'kth-smallest-bst-mcq-1', problemId: 'kth-smallest-element-in-a-bst', difficulty: 'medium',
    question: 'Which traversal gives BST elements in sorted order?',
    options: ['Preorder', 'Inorder', 'Postorder', 'Level order'],
    correctIndex: 1, explanation: 'Inorder traversal of a BST visits nodes in ascending order. The kth element visited is the kth smallest.' },

  { id: 'lca-bst-mcq-1', problemId: 'lowest-common-ancestor-of-a-bst', difficulty: 'medium',
    question: 'How do you find LCA in a BST efficiently?',
    options: ['Find paths to both nodes and compare', 'If both values < node, go left; if both > node, go right; otherwise current is LCA', 'Do BFS and find the deepest common parent', 'Use parent pointers'],
    correctIndex: 1, explanation: 'BST property: if p and q are on different sides (or one equals current), current node is the LCA. O(h) time.' },

  { id: 'serialize-tree-mcq-1', problemId: 'serialize-and-deserialize-binary-tree', difficulty: 'hard',
    question: 'Why do you need null markers when serializing a binary tree?',
    options: ['To preserve the tree shape', 'To handle duplicate values', 'To mark leaf nodes', 'To reduce string length'],
    correctIndex: 0, explanation: 'Without null markers, you can\'t distinguish between different tree structures that have the same values. Nulls encode the exact shape.' },

  { id: 'subtree-mcq-1', problemId: 'subtree-of-another-tree', difficulty: 'hard',
    question: 'What is the time complexity of the naive recursive subtree check?',
    options: ['O(n)', 'O(m)', 'O(n * m)', 'O(n + m)'],
    correctIndex: 2, explanation: 'For each of n nodes in the main tree, we might compare up to m nodes of the subtree. Worst case O(n * m).' },

  // ===== TRIE =====
  { id: 'trie-mcq-1', problemId: 'implement-trie-prefix-tree', difficulty: 'medium',
    question: 'What is the space complexity of a Trie storing n words of average length k?',
    options: ['O(n)', 'O(n * k)', 'O(26^k)', 'O(n * k * 26)'],
    correctIndex: 1, explanation: 'In the worst case (no shared prefixes), each word needs k nodes. With shared prefixes, actual usage is less. Each node has up to 26 children pointers.' },

  { id: 'word-dict-mcq-1', problemId: 'design-add-and-search-words-data-structure', difficulty: 'hard',
    question: 'How do you handle the "." wildcard in word search with a Trie?',
    options: ['Replace "." with all 26 letters and search each', 'At ".", branch to ALL children recursively', 'Skip the "." level entirely', 'Use regex on serialized Trie'],
    correctIndex: 1, explanation: 'When encountering ".", try all 26 possible children. If any path succeeds, return true. This is essentially DFS with branching at wildcards.' },

  { id: 'word-search-ii-mcq-1', problemId: 'word-search-ii', difficulty: 'hard',
    question: 'Why is a Trie better than checking each word individually in Word Search II?',
    options: ['Tries use less memory', 'Shared prefixes are searched once instead of repeated DFS per word', 'Tries support wildcards', 'Tries are faster to build'],
    correctIndex: 1, explanation: 'Multiple words with shared prefixes reuse the same DFS path. Without a Trie, each word triggers a full DFS. Trie prunes entire branches early.' },

  // ===== HEAP =====
  { id: 'find-median-mcq-1', problemId: 'find-median-from-data-stream', difficulty: 'hard',
    question: 'Which data structure combination finds the running median efficiently?',
    options: ['Sorted array with binary insertion', 'Max-heap for lower half + min-heap for upper half', 'AVL tree with order statistics', 'Hash map of value -> count'],
    correctIndex: 1, explanation: 'Max-heap stores the smaller half, min-heap stores the larger half. Median is the top of one or average of both tops. O(log n) per insertion.' },
  { id: 'find-median-mcq-2', problemId: 'find-median-from-data-stream', difficulty: 'hard',
    question: 'After adding [2, 3, 4] to the median stream, what are the heap tops?',
    options: ['MaxHeap: 2, MinHeap: 4', 'MaxHeap: 3, MinHeap: 4', 'MaxHeap: 2, MinHeap: 3', 'MaxHeap: 3, MinHeap: 3'],
    correctIndex: 1, explanation: 'Lower half (max-heap): [2, 3], top=3. Upper half (min-heap): [4], top=4. Median = 3 (odd count, take from larger heap).' },

  // ===== BACKTRACKING =====
  { id: 'combination-sum-mcq-1', problemId: 'combination-sum', difficulty: 'medium',
    question: 'In Combination Sum, how do you allow reusing the same number?',
    options: ['Start the next recursion from index 0', 'Start from the current index (not i+1)', 'Use a visited array', 'Add the number multiple times before recursing'],
    correctIndex: 1, explanation: 'By recursing with the same index i (not i+1), we allow the same candidate to be used again. Moving to i+1 would prevent reuse.' },
  { id: 'combination-sum-mcq-2', problemId: 'combination-sum', difficulty: 'hard',
    question: 'For candidates = [2, 3, 6, 7] and target = 7, how many unique combinations sum to the target?',
    options: ['1', '2', '3', '4'],
    correctIndex: 1, explanation: 'Two combinations: [2, 2, 3] and [7].' },

  { id: 'word-search-mcq-1', problemId: 'word-search', difficulty: 'hard',
    question: 'In Word Search on a grid, why must you mark cells as visited during DFS?',
    options: ['To improve time complexity', 'To prevent using the same cell twice in one path', 'To avoid infinite loops in cycles', 'To track which words are found'],
    correctIndex: 1, explanation: 'Each cell can only be used once per word path. Mark as visited before exploring neighbors, unmark when backtracking.' },

  // ===== GRAPHS =====
  { id: 'clone-graph-mcq-1', problemId: 'clone-graph', difficulty: 'medium',
    question: 'What prevents infinite loops when cloning a graph with cycles?',
    options: ['Using BFS instead of DFS', 'A hash map from original node -> cloned node', 'Processing each edge only once', 'Sorting nodes by value first'],
    correctIndex: 1, explanation: 'The map serves as both a "visited" check and a way to reuse already-cloned nodes. If a node is in the map, return the clone instead of recursing.' },

  { id: 'num-islands-mcq-1', problemId: 'number-of-islands', difficulty: 'medium',
    question: 'What is the time complexity of BFS/DFS for Number of Islands on an m x n grid?',
    options: ['O(m * n)', 'O(m + n)', 'O(m * n * 4)', 'O((m * n)^2)'],
    correctIndex: 0, explanation: 'Each cell is visited at most once (marked as visited). The 4-directional check per cell is constant. Total: O(m * n).' },
  { id: 'num-islands-mcq-2', problemId: 'number-of-islands', difficulty: 'hard',
    question: 'For grid = [["1","1","0"],["1","1","0"],["0","0","1"]], how many islands?',
    options: ['1', '2', '3', '4'],
    correctIndex: 1, explanation: 'Two islands: the 2x2 block of 1s in the top-left, and the single 1 in the bottom-right.' },

  { id: 'course-schedule-mcq-1', problemId: 'course-schedule', difficulty: 'medium',
    question: 'Course Schedule is essentially detecting what in a directed graph?',
    options: ['Connected components', 'Shortest path', 'Cycles', 'Bridges'],
    correctIndex: 2, explanation: 'If there\'s a cycle in the prerequisite graph, you can\'t complete all courses. Use topological sort or DFS cycle detection.' },
  { id: 'course-schedule-mcq-2', problemId: 'course-schedule', difficulty: 'hard',
    question: 'In DFS cycle detection, what do the three node states (unvisited, in-progress, completed) represent?',
    options: ['BFS layers', 'Node colors in graph coloring', 'White: unvisited, Gray: in current DFS path, Black: fully explored', 'Priority levels for processing'],
    correctIndex: 2, explanation: 'Encountering a gray node during DFS means we\'ve found a back edge (cycle). Black nodes are safe - their subtree has no cycles.' },

  { id: 'graph-valid-tree-mcq-1', problemId: 'graph-valid-tree', difficulty: 'hard',
    question: 'Which condition is necessary and sufficient for an undirected graph to be a valid tree?',
    options: ['It has n-1 edges', 'It is connected and has no cycles', 'Every node has at most 2 children', 'It has exactly one root node'],
    correctIndex: 1, explanation: 'A tree is a connected acyclic graph. Equivalently: n nodes, n-1 edges, and connected. Having n-1 edges alone isn\'t sufficient (could be disconnected).' },

  { id: 'connected-components-mcq-1', problemId: 'number-of-connected-components-in-an-undirected-graph', difficulty: 'medium',
    question: 'Which approach efficiently counts connected components?',
    options: ['Floyd-Warshall all-pairs shortest path', 'Union-Find (Disjoint Set Union)', 'Dijkstra from every node', 'Adjacency matrix multiplication'],
    correctIndex: 1, explanation: 'Union-Find with path compression and union by rank gives near O(n) for n union/find operations. DFS/BFS also works in O(V+E).' },

  { id: 'pacific-atlantic-mcq-1', problemId: 'pacific-atlantic-water-flow', difficulty: 'hard',
    question: 'Why is it better to BFS from the oceans inward rather than from each cell outward?',
    options: ['BFS is faster than DFS', 'Starting from oceans, you traverse uphill and avoid redundant work', 'Ocean cells are easier to identify', 'Inward BFS uses less memory'],
    correctIndex: 1, explanation: 'BFS from ocean borders marks all cells that can reach that ocean. The intersection of Pacific-reachable and Atlantic-reachable cells is the answer. Each cell is visited at most twice.' },

  // ===== 1D DP =====
  { id: 'longest-palindrome-substr-mcq-1', problemId: 'longest-palindromic-substring', difficulty: 'medium',
    question: 'What is the expand-around-center approach for Longest Palindromic Substring?',
    options: ['Check all substrings with two pointers', 'For each center (and between-center), expand outward while chars match', 'Use DP table to mark palindromes', 'Reverse string and find longest common substring'],
    correctIndex: 1, explanation: 'Try each of 2n-1 centers (each char + each gap). Expand outward while characters match. O(n^2) time, O(1) space.' },

  { id: 'climbing-stairs-mcq-1', problemId: 'climbing-stairs', difficulty: 'medium',
    question: 'Climbing Stairs is equivalent to which famous sequence?',
    options: ['Catalan numbers', 'Fibonacci sequence', 'Pascal\'s triangle', 'Prime numbers'],
    correctIndex: 1, explanation: 'f(n) = f(n-1) + f(n-2), same as Fibonacci. From step n-1 take 1 step, or from step n-2 take 2 steps.' },
  { id: 'climbing-stairs-mcq-2', problemId: 'climbing-stairs', difficulty: 'hard',
    question: 'How many ways to climb 5 stairs (1 or 2 steps at a time)?',
    options: ['5', '7', '8', '13'],
    correctIndex: 2, explanation: 'f(1)=1, f(2)=2, f(3)=3, f(4)=5, f(5)=8. It follows the Fibonacci pattern.' },

  { id: 'decode-ways-mcq-1', problemId: 'decode-ways', difficulty: 'hard',
    question: 'In Decode Ways, why does "06" have 0 decodings but "6" has 1?',
    options: ['Leading zeros are invalid in the encoding', '06 is not between 1-26', '0 has no letter mapping, so "06" can\'t start a valid decode', 'Both have the same number of decodings'],
    correctIndex: 2, explanation: '"0" doesn\'t map to any letter (A=1). So "06" can\'t be decoded: "0" alone is invalid, and "06" is not a valid two-digit code.' },

  { id: 'word-break-mcq-1', problemId: 'word-break', difficulty: 'medium',
    question: 'What DP approach solves Word Break?',
    options: ['dp[i] = true if s[0..i] can be segmented into dictionary words', 'dp[i][j] = true if s[i..j] is in the dictionary', 'Greedy: always match the longest word', 'Trie + backtracking'],
    correctIndex: 0, explanation: 'dp[i] is true if s[0..i] can be broken. For each i, check all j < i: if dp[j] is true and s[j..i] is in dict, then dp[i] = true.' },

  { id: 'max-product-subarray-mcq-1', problemId: 'maximum-product-subarray', difficulty: 'hard',
    question: 'Why do you need to track both max AND min product at each position?',
    options: ['To handle arrays with all negatives', 'A negative min * negative number becomes the new max', 'To optimize space complexity', 'To handle zeros in the array'],
    correctIndex: 1, explanation: 'A large negative product can become the largest positive product when multiplied by another negative. Track both and swap when current element is negative.' },
  { id: 'max-product-subarray-mcq-2', problemId: 'maximum-product-subarray', difficulty: 'hard',
    question: 'For nums = [2, 3, -2, 4], what is the maximum product subarray?',
    options: ['4', '6', '8', '24'],
    correctIndex: 1, explanation: 'The subarray [2, 3] gives product 6. Including -2 makes it negative, and [4] alone is only 4.' },

  { id: 'house-robber-mcq-1', problemId: 'house-robber', difficulty: 'medium',
    question: 'Which DP recurrence correctly models the House Robber problem?',
    options: ['dp[i] = dp[i-1] + nums[i]', 'dp[i] = max(dp[i-1], dp[i-2] + nums[i])', 'dp[i] = max(nums[i], dp[i-1])', 'dp[i] = dp[i-2] + nums[i]'],
    correctIndex: 1, explanation: 'At each house: either skip it (dp[i-1]) or rob it (dp[i-2] + nums[i], since adjacent houses can\'t both be robbed).' },
  { id: 'house-robber-mcq-2', problemId: 'house-robber', difficulty: 'hard',
    question: 'For nums = [2, 7, 9, 3, 1], what is the maximum amount?',
    options: ['10', '11', '12', '13'],
    correctIndex: 2, explanation: 'Rob houses with values 2 + 9 + 1 = 12. Alternatively, 7 + 3 = 10. The optimal is 12.' },

  { id: 'house-robber-ii-mcq-1', problemId: 'house-robber-ii', difficulty: 'hard',
    question: 'How does House Robber II differ from House Robber I?',
    options: ['Houses have different values', 'Houses are in a circle so first and last are adjacent', 'You can rob 2 adjacent houses', 'There are two rows of houses'],
    correctIndex: 1, explanation: 'Run House Robber I twice: once on nums[0..n-2] and once on nums[1..n-1]. Take the max. This handles the circular constraint.' },

  { id: 'lis-mcq-1', problemId: 'longest-increasing-subsequence', difficulty: 'medium',
    question: 'What is the O(n log n) approach for Longest Increasing Subsequence?',
    options: ['DP with binary search on a "tails" array', 'Merge sort modified to count inversions', 'Segment tree with point updates', 'Two pointers on sorted array'],
    correctIndex: 0, explanation: 'Maintain an array "tails" where tails[i] is the smallest tail element of all increasing subsequences of length i+1. Binary search to find insertion point.' },
  { id: 'lis-mcq-2', problemId: 'longest-increasing-subsequence', difficulty: 'hard',
    question: 'For nums = [10, 9, 2, 5, 3, 7, 101, 18], what is the LIS length?',
    options: ['3', '4', '5', '6'],
    correctIndex: 1, explanation: 'One LIS is [2, 3, 7, 101] with length 4. Another is [2, 5, 7, 101].' },

  { id: 'coin-change-mcq-1', problemId: 'coin-change', difficulty: 'medium',
    question: 'What does dp[i] represent in the Coin Change problem?',
    options: ['Number of ways to make amount i', 'Minimum coins to make amount i', 'Whether amount i is achievable', 'Maximum coins to make amount i'],
    correctIndex: 1, explanation: 'dp[i] = minimum number of coins needed to make amount i. dp[amount] is the answer. Initialize dp[0] = 0, rest = Infinity.' },
  { id: 'coin-change-mcq-2', problemId: 'coin-change', difficulty: 'hard',
    question: 'For coins = [1, 3, 4], amount = 6, what is the minimum number of coins?',
    options: ['2', '3', '4', '6'],
    correctIndex: 0, explanation: '3 + 3 = 6 using 2 coins. Greedy (4 + 1 + 1) would give 3 coins. DP finds the optimal.' },

  { id: 'palindromic-substr-mcq-1', problemId: 'palindromic-substrings', difficulty: 'hard',
    question: 'For s = "aaa", how many palindromic substrings exist?',
    options: ['3', '4', '5', '6'],
    correctIndex: 3, explanation: '"a"(x3) + "aa"(x2) + "aaa"(x1) = 6 palindromic substrings.' },

  // ===== 2D DP =====
  { id: 'unique-paths-mcq-1', problemId: 'unique-paths', difficulty: 'medium',
    question: 'Which recurrence relation correctly models Unique Paths on an m x n grid?',
    options: ['dp[i][j] = dp[i-1][j] * dp[i][j-1]', 'dp[i][j] = dp[i-1][j] + dp[i][j-1]', 'dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + 1', 'dp[i][j] = max(dp[i-1][j], dp[i][j-1])'],
    correctIndex: 1, explanation: 'Each cell can be reached from above or from the left. Total paths = sum of paths from both directions.' },
  { id: 'unique-paths-mcq-2', problemId: 'unique-paths', difficulty: 'hard',
    question: 'For a 3x7 grid, how many unique paths exist?',
    options: ['21', '28', '35', '42'],
    correctIndex: 1, explanation: 'C(m+n-2, m-1) = C(8, 2) = 28. It\'s a combinatorics problem: choose 2 "downs" from 8 total moves.' },

  { id: 'lcs-mcq-1', problemId: 'longest-common-subsequence', difficulty: 'medium',
    question: 'Which recurrence relation correctly defines Longest Common Subsequence (LCS)?',
    options: ['If chars match: dp[i-1][j-1] + 1; else: max(dp[i-1][j], dp[i][j-1])', 'If chars match: dp[i-1][j-1] + 1; else: 0', 'dp[i][j] = dp[i-1][j] + dp[i][j-1]', 'If chars match: max(dp[i-1][j], dp[i][j-1]) + 1; else: 0'],
    correctIndex: 0, explanation: 'When characters match, extend the LCS. When they don\'t, take the max of skipping either character.' },
  { id: 'lcs-mcq-2', problemId: 'longest-common-subsequence', difficulty: 'hard',
    question: 'For text1 = "abcde" and text2 = "ace", what is the LCS length?',
    options: ['1', '2', '3', '4'],
    correctIndex: 2, explanation: 'The LCS is "ace" with length 3.' },

  // ===== GREEDY =====
  { id: 'max-subarray-mcq-1', problemId: 'maximum-subarray', difficulty: 'medium',
    question: 'What is Kadane\'s algorithm\'s key insight?',
    options: ['Sort the array first', 'At each position, either extend the current subarray or start fresh', 'Use divide and conquer on the midpoint', 'Track prefix sums and find max difference'],
    correctIndex: 1, explanation: 'currentMax = max(nums[i], currentMax + nums[i]). If extending the subarray gives less than starting fresh, start fresh.' },
  { id: 'max-subarray-mcq-2', problemId: 'maximum-subarray', difficulty: 'hard',
    question: 'For nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4], what is the maximum subarray sum?',
    options: ['4', '5', '6', '7'],
    correctIndex: 2, explanation: 'Subarray [4, -1, 2, 1] has sum 6.' },

  { id: 'jump-game-mcq-1', problemId: 'jump-game', difficulty: 'medium',
    question: 'What greedy strategy solves Jump Game in O(n)?',
    options: ['Always jump the maximum distance', 'Track the farthest reachable index, update as you go', 'BFS from index 0', 'DP with dp[i] = can reach index i'],
    correctIndex: 1, explanation: 'Maintain maxReach. For each index i <= maxReach, update maxReach = max(maxReach, i + nums[i]). If maxReach >= n-1, return true.' },

  // ===== INTERVALS =====
  { id: 'merge-intervals-mcq-1', problemId: 'merge-intervals', difficulty: 'medium',
    question: 'What is the first step in Merge Intervals?',
    options: ['Sort by end time', 'Sort by start time', 'Sort by interval length', 'Group overlapping intervals with a hash map'],
    correctIndex: 1, explanation: 'Sort by start time. Then iterate: if current overlaps with last merged interval, extend the end. Otherwise, add as new interval.' },
  { id: 'merge-intervals-mcq-2', problemId: 'merge-intervals', difficulty: 'hard',
    question: 'For intervals = [[1,3],[2,6],[8,10],[15,18]], what is the merged output?',
    options: ['[[1,6],[8,10],[15,18]]', '[[1,6],[8,18]]', '[[1,10],[15,18]]', '[[1,18]]'],
    correctIndex: 0, explanation: '[1,3] and [2,6] overlap -> [1,6]. [8,10] and [15,18] don\'t overlap with anything else.' },

  { id: 'insert-interval-mcq-1', problemId: 'insert-interval', difficulty: 'hard',
    question: 'In Insert Interval, what are the three phases of the algorithm?',
    options: ['Sort, merge, output', 'Add all before, merge overlapping, add all after', 'Binary search, insert, merge neighbors', 'Compare starts, compare ends, combine'],
    correctIndex: 1, explanation: 'Add intervals that end before new interval starts. Merge all overlapping with new interval. Add remaining intervals.' },

  { id: 'meeting-rooms-mcq-1', problemId: 'meeting-rooms', difficulty: 'medium',
    question: 'How do you check if a person can attend all meetings?',
    options: ['Check all pairs for overlap', 'Sort by start time, check if any meeting starts before previous ends', 'Count total meeting hours', 'Use interval tree'],
    correctIndex: 1, explanation: 'Sort by start time. If intervals[i].start < intervals[i-1].end for any i, there\'s a conflict.' },

  { id: 'meeting-rooms-ii-mcq-1', problemId: 'meeting-rooms-ii', difficulty: 'hard',
    question: 'How do you find the minimum number of meeting rooms needed?',
    options: ['Count maximum overlapping intervals at any point', 'Sort by start, use min-heap of end times', 'Graph coloring on conflict graph', 'All of the above work'],
    correctIndex: 3, explanation: 'All work. The heap approach: sort by start, push end times to min-heap. If new meeting starts after heap top, pop (reuse room). Heap size = rooms needed.' },
  { id: 'meeting-rooms-ii-mcq-2', problemId: 'meeting-rooms-ii', difficulty: 'hard',
    question: 'For meetings [[0,30],[5,10],[15,20]], how many rooms are needed?',
    options: ['1', '2', '3', '4'],
    correctIndex: 1, explanation: '[0,30] overlaps with [5,10] (need 2 rooms). But [15,20] can reuse the room from [5,10] since 15 >= 10. So 2 rooms.' },

  { id: 'non-overlapping-mcq-1', problemId: 'non-overlapping-intervals', difficulty: 'hard',
    question: 'To minimize removals for Non-overlapping Intervals, which interval should you keep when two overlap?',
    options: ['The longer one', 'The shorter one', 'The one that ends earlier', 'The one that starts earlier'],
    correctIndex: 2, explanation: 'Keep the interval that ends earliest - it leaves the most room for future intervals. This is the classic interval scheduling greedy.' },

  // ===== MATH & GEOMETRY =====
  { id: 'rotate-image-mcq-1', problemId: 'rotate-image', difficulty: 'medium',
    question: 'How do you rotate a matrix 90 degrees clockwise in-place?',
    options: ['Transpose then reverse each row', 'Reverse each row then transpose', 'Rotate layer by layer from outside in', 'Transpose then reverse each column'],
    correctIndex: 0, explanation: 'Transpose (swap matrix[i][j] with matrix[j][i]) then reverse each row. This achieves 90-degree clockwise rotation.' },

  { id: 'spiral-matrix-mcq-1', problemId: 'spiral-matrix', difficulty: 'hard',
    question: 'For a 3x3 matrix [[1,2,3],[4,5,6],[7,8,9]], what is the spiral order?',
    options: ['[1,2,3,6,9,8,7,4,5]', '[1,2,3,4,5,6,7,8,9]', '[1,4,7,8,9,6,3,2,5]', '[1,2,3,6,5,4,7,8,9]'],
    correctIndex: 0, explanation: 'Spiral: right across top (1,2,3), down right (6,9), left across bottom (8,7), up left (4), then center (5).' },

  { id: 'set-matrix-zeroes-mcq-1', problemId: 'set-matrix-zeroes', difficulty: 'medium',
    question: 'How do you solve Set Matrix Zeroes in O(1) extra space?',
    options: ['Use the first row and column as markers', 'Process zeros in reverse order', 'Use bit manipulation on the matrix values', 'Two passes with in-place XOR marking'],
    correctIndex: 0, explanation: 'Use first row/column to mark which rows/columns should be zeroed. Use a separate flag for whether the first row/column itself should be zeroed.' },

  // ===== BIT MANIPULATION =====
  { id: 'reverse-bits-mcq-1', problemId: 'reverse-bits', difficulty: 'medium',
    question: 'How do you reverse bits of a 32-bit integer?',
    options: ['Convert to string, reverse, convert back', 'Iterate 32 times: extract LSB, shift into result from left', 'XOR with 0xFFFFFFFF', 'Swap adjacent bits, then pairs, then nibbles, etc.'],
    correctIndex: 1, explanation: 'Extract the least significant bit (n & 1), shift result left and OR with it, then shift n right. Repeat 32 times.' },

  { id: 'num-1-bits-mcq-1', problemId: 'number-of-1-bits', difficulty: 'medium',
    question: 'What does n & (n - 1) do?',
    options: ['Flips all bits', 'Removes the lowest set bit', 'Checks if n is a power of 2', 'Doubles the value'],
    correctIndex: 1, explanation: 'n & (n-1) clears the lowest set bit. Count how many times you can do this until n becomes 0 to count set bits.' },

  { id: 'missing-number-mcq-1', problemId: 'missing-number', difficulty: 'medium',
    question: 'How do you find the missing number in [0, n] using bit manipulation?',
    options: ['XOR all numbers with all indices 0..n', 'AND all numbers together', 'OR all numbers together', 'NOT of the sum'],
    correctIndex: 0, explanation: 'XOR of a ^ a = 0. XOR all array values with 0,1,...,n. All pairs cancel except the missing number.' },
  { id: 'missing-number-mcq-2', problemId: 'missing-number', difficulty: 'hard',
    question: 'For nums = [3, 0, 1], what is the missing number and how does XOR find it?',
    options: ['2; XOR(0^1^3) ^ XOR(0^1^2^3) = 2', '4; sum formula', '2; sort and find gap', '2; hash set difference'],
    correctIndex: 0, explanation: 'XOR all values: 3^0^1 = 2. XOR with indices: 0^1^2^3 = 0. Total: 2^0 = 2. The unpaired number remains.' },

  { id: 'counting-bits-mcq-1', problemId: 'counting-bits', difficulty: 'medium',
    question: 'What is the DP relation for counting bits of every number from 0 to n?',
    options: ['dp[i] = dp[i/2] + (i & 1)', 'dp[i] = dp[i-1] + 1', 'dp[i] = dp[i & (i-1)] + 1', 'Both A and C work'],
    correctIndex: 3, explanation: 'dp[i>>1] + (i&1): right-shift removes LSB, add it back. dp[i & (i-1)] + 1: remove lowest set bit, add 1. Both are valid O(n) approaches.' },

  { id: 'sum-two-integers-mcq-1', problemId: 'sum-of-two-integers', difficulty: 'hard',
    question: 'How do you add two integers without using + or -?',
    options: ['Use multiplication and division', 'XOR for sum without carry, AND + left shift for carry, repeat', 'Use bitwise NOT and increment', 'Use logarithms: exp(log(a) + log(b))'],
    correctIndex: 1, explanation: 'a XOR b gives sum without carry. (a AND b) << 1 gives the carry. Repeat until carry is 0.' },
  { id: 'sum-two-integers-mcq-2', problemId: 'sum-of-two-integers', difficulty: 'hard',
    question: 'To compute 5 + 3 using bit manipulation: 5 = 101, 3 = 011. What is XOR and carry after step 1?',
    options: ['XOR = 110 (6), Carry = 010 (2)', 'XOR = 111 (7), Carry = 001 (1)', 'XOR = 100 (4), Carry = 010 (2)', 'XOR = 000 (0), Carry = 1000 (8)'],
    correctIndex: 0, explanation: '101 XOR 011 = 110 (6). (101 AND 011) << 1 = 001 << 1 = 010 (2). Next: 110 XOR 010 = 100, carry = (110 AND 010) << 1 = 100. Then 100 XOR 100 = 000, carry = 1000. Finally 1000 XOR 000 = 1000 = 8. Correct!' },

  { id: 'same-tree-mcq-1', problemId: 'same-tree', difficulty: 'medium',
    question: 'What are the base cases for checking if two trees are the same?',
    options: ['Both null: true. One null: false. Values differ: false.', 'Both null: false. One null: true.', 'Only check leaf nodes', 'Compare level by level with BFS'],
    correctIndex: 0, explanation: 'Both null = same (true). One null, other not = different (false). Both non-null with different values = false. Otherwise recurse on left and right.' },
];

// ─── HLD MCQ Cards ──────────────────────────────────────────────────────────
export const HLD_MCQ_CARDS: MCQCard[] = [
  // === Storage & Retrieval ===
  { id: 'hld-url-shortener-mcq-1', problemId: 'hld-url-shortener', difficulty: 'medium',
    question: 'Which encoding scheme produces short, URL-safe keys for a URL shortener?',
    options: ['Base64', 'Base62 (a-z, A-Z, 0-9)', 'Hexadecimal (Base16)', 'UUID v4'],
    correctIndex: 1, explanation: 'Base62 uses only alphanumeric characters (62 chars), all URL-safe. A 7-char Base62 key gives 62^7 ≈ 3.5 trillion unique URLs.' },
  { id: 'hld-url-shortener-mcq-2', problemId: 'hld-url-shortener', difficulty: 'hard',
    question: 'What is the typical read/write ratio for a URL shortener like TinyURL?',
    options: ['1:1', '10:1', '100:1', '1000:1'],
    correctIndex: 3, explanation: 'URL shorteners are extremely read-heavy. A URL is created once but redirected thousands of times. This means caching is critical for performance.' },
  { id: 'hld-url-shortener-mcq-3', problemId: 'hld-url-shortener', difficulty: 'hard',
    question: 'How does a Key Generation Service (KGS) avoid hash collisions in a URL shortener?',
    options: ['Retry with different hash functions', 'Pre-generate unique keys and assign them on demand', 'Use auto-incrementing IDs', 'Check the database before each insertion'],
    correctIndex: 1, explanation: 'A KGS pre-generates unique keys and stores them. When a URL is created, it assigns the next available key. This eliminates collision checking entirely.' },

  { id: 'hld-pastebin-mcq-1', problemId: 'hld-pastebin', difficulty: 'medium',
    question: 'Why use Object Storage (S3) instead of a database for storing paste content in Pastebin?',
    options: ['S3 is faster for reads', 'Object storage handles large blobs cheaply and scales independently from metadata', 'Databases cannot store text', 'S3 supports SQL queries'],
    correctIndex: 1, explanation: 'Object storage (S3) is optimized for large blobs at low cost. Metadata (title, author, expiry) stays in the database. This separates concerns and scales each independently.' },

  { id: 'hld-key-value-store-mcq-1', problemId: 'hld-key-value-store', difficulty: 'hard',
    question: 'What does the CAP theorem state about distributed systems?',
    options: ['You can have Consistency, Availability, and Partition tolerance simultaneously', 'You can only pick 2 of: Consistency, Availability, Partition tolerance', 'Consistency always beats Availability', 'Partition tolerance is optional'],
    correctIndex: 1, explanation: 'The CAP theorem states you can only guarantee 2 of the 3. Since network partitions are unavoidable, you choose between CP (consistency) and AP (availability).' },
  { id: 'hld-key-value-store-mcq-2', problemId: 'hld-key-value-store', difficulty: 'hard',
    question: 'Which technique distributes keys across nodes while minimizing data movement when nodes join or leave?',
    options: ['Hash modulo N', 'Consistent Hashing', 'Random assignment', 'Range-based partitioning'],
    correctIndex: 1, explanation: 'Consistent hashing maps keys and nodes onto a ring. When a node joins/leaves, only K/N keys are remapped on average, compared to nearly all keys with hash mod N.' },

  // === Distributed Infrastructure ===
  { id: 'hld-rate-limiter-mcq-1', problemId: 'hld-rate-limiter', difficulty: 'medium',
    question: 'Which rate limiting algorithm allows short bursts up to a maximum capacity?',
    options: ['Fixed Window Counter', 'Leaky Bucket', 'Token Bucket', 'Sliding Window Log'],
    correctIndex: 2, explanation: 'Token Bucket adds tokens at a fixed rate up to a max capacity. Requests consume tokens. A full bucket allows a burst of requests. Leaky Bucket enforces a smooth constant rate.' },
  { id: 'hld-rate-limiter-mcq-2', problemId: 'hld-rate-limiter', difficulty: 'hard',
    question: 'What is the main challenge of distributed rate limiting across multiple servers?',
    options: ['Network latency', 'Synchronizing counters across nodes without a central bottleneck', 'Supporting multiple algorithms', 'Logging rate limit events'],
    correctIndex: 1, explanation: 'Each server may see different request counts. Using Redis as a centralized counter works but adds latency. Sliding window counters in Redis with Lua scripts provide atomic, distributed rate limiting.' },

  { id: 'hld-distributed-cache-mcq-1', problemId: 'hld-distributed-cache', difficulty: 'medium',
    question: 'Which cache eviction policy removes the item that was used least recently?',
    options: ['FIFO (First In First Out)', 'LRU (Least Recently Used)', 'LFU (Least Frequently Used)', 'Random Replacement'],
    correctIndex: 1, explanation: 'LRU evicts the item whose last access was the longest ago. It is the most common eviction policy, balancing simplicity and effectiveness.' },
  { id: 'hld-distributed-cache-mcq-2', problemId: 'hld-distributed-cache', difficulty: 'hard',
    question: 'What is the "thundering herd" problem in caching?',
    options: ['Cache grows too large', 'When a cache key expires, many concurrent requests hit the database simultaneously', 'Cache nodes fail in sequence', 'Hot keys cause memory overflow'],
    correctIndex: 1, explanation: 'When a popular cache key expires, all concurrent requests miss the cache and stampede to the database. Solutions: cache locking (only one request rebuilds), staggered TTLs, or early refresh.' },

  // === Social Media & Feeds ===
  { id: 'hld-twitter-mcq-1', problemId: 'hld-twitter', difficulty: 'hard',
    question: 'In Twitter\'s "fan-out on write" approach, when is the timeline computed?',
    options: ['When a user opens their feed', 'When a tweet is posted, it is pushed to all followers\' timelines', 'Once per hour via batch processing', 'Only when explicitly refreshed'],
    correctIndex: 1, explanation: 'Fan-out on write pre-computes timelines at post time. A tweet is written to every follower\'s timeline cache. This makes reads fast but writes expensive, especially for users with millions of followers.' },
  { id: 'hld-twitter-mcq-2', problemId: 'hld-twitter', difficulty: 'hard',
    question: 'Why does Twitter use a hybrid fan-out approach for celebrity users?',
    options: ['Celebrities post more often', 'Fan-out on write for millions of followers is too slow and resource-intensive', 'Celebrity tweets need different ranking', 'Legal compliance requirements'],
    correctIndex: 1, explanation: 'A celebrity with 50M followers would require 50M writes per tweet. Instead, celebrity tweets are merged at read time (fan-out on read). Regular users use fan-out on write. This hybrid approach balances cost.' },

  { id: 'hld-instagram-mcq-1', problemId: 'hld-instagram', difficulty: 'medium',
    question: 'What is the primary purpose of a CDN in Instagram\'s architecture?',
    options: ['Database replication', 'Serving photos and videos from edge servers closest to users', 'Running ML models', 'User authentication'],
    correctIndex: 1, explanation: 'CDN edge servers cache and serve static content (photos/videos) from locations geographically close to users, dramatically reducing latency and offloading origin servers.' },

  { id: 'hld-tiktok-mcq-1', problemId: 'hld-tiktok', difficulty: 'hard',
    question: 'What makes TikTok\'s recommendation system different from traditional social media feeds?',
    options: ['It uses a social graph', 'Content-based recommendations from watch behavior, not follow graph', 'It only shows verified content', 'It uses chronological ordering'],
    correctIndex: 1, explanation: 'TikTok\'s "For You" page relies on content-based signals (watch time, replays, likes) rather than who you follow. This allows new creators to go viral and creates a highly engaging discovery feed.' },

  // === Messaging & Real-Time ===
  { id: 'hld-whatsapp-mcq-1', problemId: 'hld-whatsapp', difficulty: 'medium',
    question: 'Which protocol maintains a persistent bidirectional connection for real-time messaging?',
    options: ['HTTP long polling', 'WebSocket', 'gRPC', 'SMTP'],
    correctIndex: 1, explanation: 'WebSocket provides full-duplex communication over a single TCP connection. Unlike HTTP, it keeps the connection open for real-time bidirectional messaging without repeated handshakes.' },
  { id: 'hld-whatsapp-mcq-2', problemId: 'hld-whatsapp', difficulty: 'hard',
    question: 'How does WhatsApp handle message delivery when the recipient is offline?',
    options: ['Messages are dropped', 'Store-and-forward: messages are persisted and delivered when recipient reconnects', 'Messages are sent via SMS fallback', 'The sender is notified to retry later'],
    correctIndex: 1, explanation: 'Messages are stored on the server until the recipient comes online. Upon reconnection, queued messages are pushed. Messages are deleted from the server after delivery confirmation.' },

  { id: 'hld-notification-service-mcq-1', problemId: 'hld-notification-service', difficulty: 'medium',
    question: 'What determines which delivery channel (push/email/SMS) to use for a notification?',
    options: ['Random selection', 'User preferences combined with notification priority and urgency', 'Always use all channels', 'System administrator choice'],
    correctIndex: 1, explanation: 'A notification service checks user preferences (opt-in channels), notification priority (urgent = push, digest = email), and channel availability to route through the optimal delivery path.' },

  // === Streaming & Media ===
  { id: 'hld-youtube-mcq-1', problemId: 'hld-youtube', difficulty: 'medium',
    question: 'What is the primary purpose of video transcoding in YouTube\'s pipeline?',
    options: ['Compressing videos to save storage', 'Converting uploaded videos into multiple resolutions and formats for different devices', 'Adding watermarks', 'Detecting copyright violations'],
    correctIndex: 1, explanation: 'Transcoding converts a single upload into multiple formats (H.264, VP9, AV1) and resolutions (360p to 4K). This allows adaptive bitrate streaming where quality adjusts to the viewer\'s bandwidth.' },
  { id: 'hld-youtube-mcq-2', problemId: 'hld-youtube', difficulty: 'hard',
    question: 'What is adaptive bitrate streaming (ABR) and why is it used?',
    options: ['Streaming at the highest quality always', 'Dynamically switching video quality based on network conditions', 'Compressing video in real-time', 'Streaming only audio when bandwidth is low'],
    correctIndex: 1, explanation: 'ABR splits video into small chunks at different quality levels. The client monitors bandwidth and switches quality per-chunk, ensuring smooth playback even on variable networks.' },

  { id: 'hld-netflix-mcq-1', problemId: 'hld-netflix', difficulty: 'hard',
    question: 'What pattern does Netflix use to prevent cascading failures across microservices?',
    options: ['Load balancing', 'Circuit Breaker pattern', 'Database replication', 'Caching'],
    correctIndex: 1, explanation: 'The Circuit Breaker pattern stops calling a failing service after a threshold, returning a fallback response instead. This prevents one failing service from bringing down the entire system.' },

  { id: 'hld-spotify-mcq-1', problemId: 'hld-spotify', difficulty: 'medium',
    question: 'How does Spotify enable instant music playback without buffering?',
    options: ['Pre-downloading all songs', 'Client-side caching of recently/frequently played songs plus predictive prefetching', 'Using only low-quality audio', 'Direct database streaming'],
    correctIndex: 1, explanation: 'Spotify caches recently played songs locally and prefetches upcoming tracks in a playlist. Combined with CDN delivery, this creates near-instant playback.' },

  // === Location & Transport ===
  { id: 'hld-uber-mcq-1', problemId: 'hld-uber', difficulty: 'hard',
    question: 'Which spatial indexing approach efficiently answers "find all drivers within 2km of this location"?',
    options: ['Linear scan of all driver positions', 'Geohash grid or Quadtree', 'SQL BETWEEN query on lat/lng', 'Binary search on coordinates'],
    correctIndex: 1, explanation: 'Geohash converts 2D coordinates into 1D strings where nearby locations share prefixes. Quadtrees recursively divide space into quadrants. Both enable efficient spatial range queries.' },
  { id: 'hld-uber-mcq-2', problemId: 'hld-uber', difficulty: 'hard',
    question: 'How does Uber implement surge pricing?',
    options: ['Manual price adjustment', 'Real-time supply/demand ratio per geographic zone using driver availability vs ride requests', 'Fixed schedule based on time of day', 'Random price increases'],
    correctIndex: 1, explanation: 'Uber divides the city into hexagonal zones. When demand (ride requests) exceeds supply (available drivers) in a zone, a surge multiplier is applied to incentivize more drivers to that area.' },

  { id: 'hld-google-maps-mcq-1', problemId: 'hld-google-maps', difficulty: 'hard',
    question: 'How does Google Maps efficiently render maps at different zoom levels?',
    options: ['Re-rendering the entire map each time', 'Pre-computed map tiles at each zoom level served from CDN', 'Client-side vector rendering only', 'Streaming raw geographic data'],
    correctIndex: 1, explanation: 'Maps are divided into 256x256px tiles pre-rendered at each zoom level. The client requests only visible tiles. CDN caching makes delivery fast. Vector tiles are increasingly used for dynamic styling.' },

  // === E-Commerce & Payments ===
  { id: 'hld-amazon-mcq-1', problemId: 'hld-amazon', difficulty: 'hard',
    question: 'What pattern prevents overselling inventory in a distributed e-commerce system?',
    options: ['First come first served without locks', 'Reservation pattern: temporarily hold inventory during checkout with TTL', 'Allowing negative inventory and reconciling later', 'Single-threaded order processing'],
    correctIndex: 1, explanation: 'When a user starts checkout, inventory is reserved (decremented) with a TTL. If checkout completes, the reservation becomes permanent. If it times out, inventory is released back.' },

  { id: 'hld-payment-system-mcq-1', problemId: 'hld-payment-system', difficulty: 'hard',
    question: 'What property ensures processing a payment request multiple times has the same effect as processing it once?',
    options: ['Atomicity', 'Idempotency', 'Durability', 'Isolation'],
    correctIndex: 1, explanation: 'Idempotency keys (unique per request) ensure retries don\'t cause duplicate charges. The server checks if a request with this key was already processed and returns the cached result.' },
  { id: 'hld-payment-system-mcq-2', problemId: 'hld-payment-system', difficulty: 'hard',
    question: 'Which pattern handles multi-step distributed transactions (e.g., charge card, update inventory, send email)?',
    options: ['Two-phase commit', 'Saga pattern with compensating transactions', 'Single database transaction', 'Eventual consistency without coordination'],
    correctIndex: 1, explanation: 'The Saga pattern breaks a distributed transaction into local transactions with compensating actions. If step 3 fails, steps 1 and 2 are rolled back via compensation (e.g., refund the charge).' },

  { id: 'hld-ticketmaster-mcq-1', problemId: 'hld-ticketmaster', difficulty: 'hard',
    question: 'How do you prevent two users from booking the same concert seat simultaneously?',
    options: ['Optimistic locking with retries', 'Distributed lock on the seat with TTL', 'Queue all requests and process sequentially', 'Allow double-booking and reconcile later'],
    correctIndex: 1, explanation: 'A distributed lock (e.g., Redis SETNX) on the seat ID with a TTL prevents concurrent booking. If a user doesn\'t complete purchase within TTL, the lock expires and the seat becomes available.' },

  // === Search & Discovery ===
  { id: 'hld-search-engine-mcq-1', problemId: 'hld-search-engine', difficulty: 'medium',
    question: 'What is the core data structure that maps words to the documents containing them?',
    options: ['B-tree', 'Inverted Index', 'Hash Table', 'Trie'],
    correctIndex: 1, explanation: 'An inverted index maps each word to a sorted list of document IDs containing that word. This enables fast full-text search by intersecting posting lists for multi-word queries.' },

  { id: 'hld-web-crawler-mcq-1', problemId: 'hld-web-crawler', difficulty: 'hard',
    question: 'What is "politeness" in the context of web crawling?',
    options: ['Only crawling public pages', 'Rate-limiting requests per domain to avoid overloading target servers', 'Asking permission before crawling', 'Using HTTPS instead of HTTP'],
    correctIndex: 1, explanation: 'Politeness means respecting robots.txt, adding delays between requests to the same domain, and not overwhelming servers. A polite crawler uses per-domain rate limiting and respects crawl-delay directives.' },

  { id: 'hld-typeahead-mcq-1', problemId: 'hld-typeahead', difficulty: 'medium',
    question: 'Which data structure is ideal for prefix-based search suggestions in typeahead?',
    options: ['Hash Map', 'Trie (prefix tree)', 'B-tree', 'Bloom Filter'],
    correctIndex: 1, explanation: 'A Trie allows O(p) prefix lookup where p is prefix length. Each node can store the top-k suggestions for that prefix, enabling instant typeahead results.' },
  { id: 'hld-typeahead-mcq-2', problemId: 'hld-typeahead', difficulty: 'hard',
    question: 'How do you rank typeahead suggestions in real-time?',
    options: ['Alphabetical order', 'By search frequency, updated periodically with a MapReduce pipeline', 'Random ordering', 'By string length'],
    correctIndex: 1, explanation: 'Each trie node stores the top-k suggestions sorted by search frequency. A periodic MapReduce job processes search logs and updates the trie. Recent trends can be weighted higher.' },

  { id: 'hld-recommendation-system-mcq-1', problemId: 'hld-recommendation-system', difficulty: 'hard',
    question: 'What is collaborative filtering in a recommendation system?',
    options: ['Filtering inappropriate content', 'Recommending items based on similar users\' preferences and behaviors', 'Using item descriptions to match user interests', 'A/B testing different recommendation strategies'],
    correctIndex: 1, explanation: 'Collaborative filtering finds users with similar behavior (e.g., ratings, purchases) and recommends items those similar users liked. It doesn\'t need item content understanding.' },

  // === Collaboration & Productivity ===
  { id: 'hld-dropbox-mcq-1', problemId: 'hld-dropbox', difficulty: 'hard',
    question: 'How does Dropbox minimize upload bandwidth for large files?',
    options: ['Compressing the entire file', 'Chunking files and only uploading changed chunks (delta sync)', 'Limiting file size', 'Uploading during off-peak hours only'],
    correctIndex: 1, explanation: 'Files are split into 4MB chunks, each identified by a content hash. When a file changes, only modified chunks are re-uploaded. Identical chunks across files/users are deduplicated.' },

  { id: 'hld-google-docs-mcq-1', problemId: 'hld-google-docs', difficulty: 'hard',
    question: 'Which algorithm enables real-time collaborative editing without conflicts in Google Docs?',
    options: ['Locking the document for one editor at a time', 'Operational Transformation (OT) or CRDT', 'Last-write-wins conflict resolution', 'Manual merge like git'],
    correctIndex: 1, explanation: 'OT transforms concurrent operations to maintain consistency. CRDTs (Conflict-free Replicated Data Types) mathematically guarantee convergence. Both allow multiple users to edit simultaneously without locks.' },

  // === Monitoring & Analytics ===
  { id: 'hld-metrics-logging-mcq-1', problemId: 'hld-metrics-logging', difficulty: 'medium',
    question: 'What is the purpose of a time-series database (TSDB) in a metrics system?',
    options: ['Storing user profiles', 'Efficiently storing and querying timestamped data points with compression and fast range queries', 'Running SQL analytics', 'Caching frequently accessed data'],
    correctIndex: 1, explanation: 'TSDBs (InfluxDB, Prometheus, TimescaleDB) are optimized for time-stamped data: efficient compression, fast time-range queries, automatic downsampling, and retention policies.' },

  { id: 'hld-cdn-mcq-1', problemId: 'hld-cdn', difficulty: 'medium',
    question: 'What is "origin shielding" in a CDN architecture?',
    options: ['Encrypting the origin server', 'An intermediate cache layer between edge servers and origin to reduce origin load', 'DDoS protection for the origin', 'Hiding the origin server IP'],
    correctIndex: 1, explanation: 'Origin shield is a mid-tier cache. Instead of every edge server hitting the origin on a cache miss, they hit the shield. This consolidates origin requests and protects it from traffic spikes.' },

  { id: 'hld-load-balancer-mcq-1', problemId: 'hld-load-balancer', difficulty: 'medium',
    question: 'What is the difference between L4 and L7 load balancing?',
    options: ['L4 is faster but L7 doesn\'t exist', 'L4 operates on TCP/UDP (transport layer), L7 inspects HTTP content (application layer) for smarter routing', 'L4 handles more traffic', 'They are identical'],
    correctIndex: 1, explanation: 'L4 load balancers route based on IP/port (fast, simple). L7 load balancers can inspect HTTP headers, URLs, cookies to make routing decisions (e.g., route /api to backend, /static to CDN).' },
  { id: 'hld-load-balancer-mcq-2', problemId: 'hld-load-balancer', difficulty: 'hard',
    question: 'Which load balancing algorithm sends requests to the server with the fewest active connections?',
    options: ['Round Robin', 'Least Connections', 'Weighted Round Robin', 'IP Hash'],
    correctIndex: 1, explanation: 'Least Connections routes to the server handling the fewest active requests. This is better than Round Robin when request processing times vary, as it naturally balances the actual load.' },

  { id: 'hld-distributed-message-queue-mcq-1', problemId: 'hld-distributed-message-queue', difficulty: 'hard',
    question: 'What delivery guarantee means every message is delivered at least once but possibly more?',
    options: ['At-most-once', 'At-least-once', 'Exactly-once', 'Best-effort'],
    correctIndex: 1, explanation: 'At-least-once delivery retries until acknowledged, so duplicates are possible. Consumers must be idempotent. Exactly-once is the hardest to achieve and usually requires idempotent processing.' },
  { id: 'hld-distributed-message-queue-mcq-2', problemId: 'hld-distributed-message-queue', difficulty: 'hard',
    question: 'How do you ensure ordered message processing in a distributed queue?',
    options: ['Use a single consumer', 'Partition messages by key; ordering is guaranteed within a partition', 'Timestamps on each message', 'Sort messages before processing'],
    correctIndex: 1, explanation: 'Messages with the same partition key go to the same partition and are consumed in order. Different partition keys can be processed in parallel. Kafka uses this approach.' },
];

// ─── Category MCQ Map (easy to add/subtract per category) ───────────────────
export const MCQ_CARDS_BY_CATEGORY: Record<string, MCQCard[]> = {
  dsa: DSA_MCQ_CARDS,
  hld: HLD_MCQ_CARDS,
  // lld: [],        // No review for LLD
  // behavioral: [], // No review for Behavioral
};

// Backwards-compatible export (default = DSA)
export const MCQ_CARDS = DSA_MCQ_CARDS;
