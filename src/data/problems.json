{
  "patterns": [
    {
      "id": "array-hashing",
      "name": "Arrays & Hashing",
      "icon": "üóÉÔ∏è",
      "description": "Hash maps, sets, and frequency counting"
    },
    {
      "id": "two-pointers",
      "name": "Two Pointers",
      "icon": "üëàüëâ",
      "description": "Left/right pointers converging or diverging"
    },
    {
      "id": "sliding-window",
      "name": "Sliding Window",
      "icon": "ü™ü",
      "description": "Variable or fixed-size window over sequential data"
    },
    {
      "id": "stack",
      "name": "Stack",
      "icon": "üìö",
      "description": "LIFO ‚Äî matching, parsing, monotonic stacks"
    },
    {
      "id": "binary-search",
      "name": "Binary Search",
      "icon": "üîç",
      "description": "Halving search space on sorted data"
    },
    {
      "id": "linked-list",
      "name": "Linked List",
      "icon": "üîó",
      "description": "Pointer manipulation, fast/slow, reversal"
    },
    {
      "id": "trees",
      "name": "Trees",
      "icon": "üå≥",
      "description": "Binary trees, BSTs, DFS/BFS traversals"
    },
    {
      "id": "tries",
      "name": "Trie",
      "icon": "üî§",
      "description": "Prefix trees for string search & autocomplete"
    },
    {
      "id": "heap",
      "name": "Heap / Priority Queue",
      "icon": "‚è´",
      "description": "Top-K, median, streaming min/max"
    },
    {
      "id": "backtracking",
      "name": "Backtracking",
      "icon": "üîô",
      "description": "Explore all paths, prune invalid branches"
    },
    {
      "id": "graphs",
      "name": "Graphs",
      "icon": "üï∏Ô∏è",
      "description": "BFS, DFS, topological sort, union-find"
    },
    {
      "id": "dp-1d",
      "name": "1D Dynamic Programming",
      "icon": "üìä",
      "description": "Overlapping subproblems, memoization, tabulation"
    },
    {
      "id": "dp-2d",
      "name": "2D Dynamic Programming",
      "icon": "üìà",
      "description": "Grid paths, sequence alignment, 2D state"
    },
    {
      "id": "greedy",
      "name": "Greedy",
      "icon": "üèÉ",
      "description": "Locally optimal choices ‚Üí global optimum"
    },
    {
      "id": "intervals",
      "name": "Intervals",
      "icon": "üìè",
      "description": "Merge, insert, overlap detection"
    },
    {
      "id": "math-geometry",
      "name": "Math & Geometry",
      "icon": "üìê",
      "description": "Matrix rotation, spiral traversal, math tricks"
    },
    {
      "id": "bit-manipulation",
      "name": "Bit Manipulation",
      "icon": "üßÆ",
      "description": "XOR, AND, shifts ‚Äî O(1) space tricks"
    }
  ],
  "problems": [
    {
      "id": "two-sum",
      "title": "Two Sum",
      "difficulty": "Easy",
      "pattern": "array-hashing",
      "leetcodeUrl": "https://leetcode.com/problems/two-sum/",
      "leetcodeNumber": 1,
      "description": "Given an array of integers `nums` and an integer `target`, return the indices of the two numbers that add up to `target`.\n\nYou may assume that each input would have exactly one solution, and you may not use the same element twice.\n\nYou can return the answer in any order.\n\n**Example 1:**\nInput: nums = [2,7,11,15], target = 9\nOutput: [0,1]\nExplanation: Because nums[0] + nums[1] == 9, we return [0, 1].\n\n**Example 2:**\nInput: nums = [3,2,4], target = 6\nOutput: [1,2]\n\n**Example 3:**\nInput: nums = [3,3], target = 6\nOutput: [0,1]",
      "starterCode": "function twoSum(nums, target) {\n  // Your code here\n  \n}",
      "steps": [
        {
          "title": "Understand the Problem",
          "hint": "You need to find two numbers in the array that add up to the target. Think about what information you need to track as you scan through the array.",
          "approach": "We are given an array of numbers and a target sum. We need to find the two indices whose corresponding values add up to the target. There is exactly one valid answer, and we cannot use the same element twice."
        },
        {
          "title": "Brute Force Approach",
          "hint": "Try every pair of numbers using two nested loops.",
          "approach": "Check every possible pair (i, j) where i < j. If nums[i] + nums[j] equals the target, return [i, j]. This requires two nested loops iterating through all combinations.",
          "code": "function twoSum(nums, target) {\n  for (let i = 0; i < nums.length; i++) {\n    for (let j = i + 1; j < nums.length; j++) {\n      if (nums[i] + nums[j] === target) {\n        return [i, j];\n      }\n    }\n  }\n  return [];\n}",
          "complexity": "Time: O(n^2), Space: O(1)"
        },
        {
          "title": "Optimal Approach",
          "hint": "Use a hash map to store numbers you have already seen. For each number, check if its complement (target - num) is in the map.",
          "approach": "Iterate through the array once. For each element, compute the complement (target - nums[i]). If the complement already exists in a hash map, we found our pair. Otherwise, store the current number and its index in the map. This gives us O(1) lookups instead of scanning the rest of the array.",
          "code": "function twoSum(nums, target) {\n  const map = new Map();\n  for (let i = 0; i < nums.length; i++) {\n    const complement = target - nums[i];\n    if (map.has(complement)) {\n      return [map.get(complement), i];\n    }\n    map.set(nums[i], i);\n  }\n  return [];\n}",
          "complexity": "Time: O(n), Space: O(n)"
        }
      ],
      "testCases": [
        {
          "args": [
            [
              2,
              7,
              11,
              15
            ],
            9
          ],
          "expected": [
            0,
            1
          ],
          "description": "Basic case: first two elements sum to target"
        },
        {
          "args": [
            [
              3,
              2,
              4
            ],
            6
          ],
          "expected": [
            1,
            2
          ],
          "description": "Answer is not the first two elements"
        },
        {
          "args": [
            [
              3,
              3
            ],
            6
          ],
          "expected": [
            0,
            1
          ],
          "description": "Duplicate values that sum to target"
        }
      ],
      "ankiCards": [
        {
          "id": "two-sum-pattern",
          "front": "In the Two Sum problem, what data structure allows you to go from O(n^2) brute force to O(n)?",
          "back": "A hash map (Map or object). Store each number's value as the key and its index as the value. For each new number, check if (target - num) already exists in the map. This turns the inner loop lookup from O(n) into O(1)."
        },
        {
          "id": "two-sum-complexity",
          "front": "What is the time and space complexity of the optimal Two Sum solution using a hash map?",
          "back": "Time: O(n) - single pass through the array. Space: O(n) - in the worst case, we store nearly all elements in the hash map before finding the pair."
        }
      ]
    },
    {
      "id": "group-anagrams",
      "title": "Group Anagrams",
      "difficulty": "Medium",
      "pattern": "array-hashing",
      "leetcodeUrl": "https://leetcode.com/problems/group-anagrams/",
      "leetcodeNumber": 49,
      "description": "Given an array of strings `strs`, group the anagrams together. You can return the answer in any order.\n\nAn anagram is a word formed by rearranging the letters of another word, using all the original letters exactly once.\n\n**Example 1:**\nInput: strs = [\"eat\",\"tea\",\"tan\",\"ate\",\"nat\",\"bat\"]\nOutput: [[\"bat\"],[\"nat\",\"tan\"],[\"ate\",\"eat\",\"tea\"]]\n\n**Example 2:**\nInput: strs = [\"\"]\nOutput: [[\"\"]]\n\n**Example 3:**\nInput: strs = [\"a\"]\nOutput: [[\"a\"]]",
      "starterCode": "function groupAnagrams(strs) {\n  // Your code here\n  \n}",
      "steps": [
        {
          "title": "Understand the Problem",
          "hint": "All anagrams share the same set of characters with the same frequencies. How can you create a 'key' that is identical for all anagrams of the same word?",
          "approach": "We need to group strings such that all anagrams end up in the same group. The key insight is that anagrams, when sorted character-by-character, produce the same sorted string. We can use this sorted string as a grouping key."
        },
        {
          "title": "Brute Force Approach",
          "hint": "For each string, compare it with every other string to check if they are anagrams. This is very slow.",
          "approach": "For each ungrouped string, iterate through all remaining strings and check if each is an anagram (using frequency counting). Group matching strings together. This requires O(n^2) comparisons, each taking O(k) time where k is the max string length.",
          "code": "function groupAnagrams(strs) {\n  const used = new Array(strs.length).fill(false);\n  const result = [];\n  for (let i = 0; i < strs.length; i++) {\n    if (used[i]) continue;\n    const group = [strs[i]];\n    used[i] = true;\n    for (let j = i + 1; j < strs.length; j++) {\n      if (used[j]) continue;\n      if (isAnagram(strs[i], strs[j])) {\n        group.push(strs[j]);\n        used[j] = true;\n      }\n    }\n    result.push(group);\n  }\n  return result;\n}\n\nfunction isAnagram(a, b) {\n  if (a.length !== b.length) return false;\n  const count = {};\n  for (const c of a) count[c] = (count[c] || 0) + 1;\n  for (const c of b) {\n    if (!count[c]) return false;\n    count[c]--;\n  }\n  return true;\n}",
          "complexity": "Time: O(n^2 * k), Space: O(n * k)"
        },
        {
          "title": "Optimal Approach",
          "hint": "Sort each string to create a canonical key, then group by that key using a hash map.",
          "approach": "For each string, sort its characters to produce a canonical key (e.g., 'eat' -> 'aet', 'tea' -> 'aet'). Use a hash map where the key is the sorted string and the value is the list of original strings that share that sorted form. Finally, return all the values from the map.",
          "code": "function groupAnagrams(strs) {\n  const map = new Map();\n  for (const str of strs) {\n    const key = str.split('').sort().join('');\n    if (!map.has(key)) {\n      map.set(key, []);\n    }\n    map.get(key).push(str);\n  }\n  return Array.from(map.values());\n}",
          "complexity": "Time: O(n * k log k) where k is max string length, Space: O(n * k)"
        }
      ],
      "testCases": [
        {
          "args": [
            [
              "eat",
              "tea",
              "tan",
              "ate",
              "nat",
              "bat"
            ]
          ],
          "expected": [
            [
              "eat",
              "tea",
              "ate"
            ],
            [
              "tan",
              "nat"
            ],
            [
              "bat"
            ]
          ],
          "description": "Multiple anagram groups"
        },
        {
          "args": [
            [
              ""
            ]
          ],
          "expected": [
            [
              ""
            ]
          ],
          "description": "Single empty string"
        },
        {
          "args": [
            [
              "a"
            ]
          ],
          "expected": [
            [
              "a"
            ]
          ],
          "description": "Single character string"
        }
      ],
      "ankiCards": [
        {
          "id": "group-anagrams-pattern",
          "front": "In Group Anagrams, how do you create a 'canonical key' so all anagrams map to the same bucket?",
          "back": "Sort each string's characters alphabetically. All anagrams produce the same sorted string (e.g., 'eat', 'tea', 'ate' all become 'aet'). Use this sorted string as the key in a hash map, and group all original strings under their shared key."
        },
        {
          "id": "group-anagrams-complexity",
          "front": "What is the time complexity of Group Anagrams using sorted keys, and can you do better than O(n * k log k)?",
          "back": "Using sorted keys: O(n * k log k) where n = number of strings and k = max string length. You can achieve O(n * k) by using a character frequency count as the key instead of sorting (e.g., key = '1#0#0#...#0' representing counts of each letter)."
        }
      ]
    },
    {
      "id": "longest-consecutive-sequence",
      "title": "Longest Consecutive Sequence",
      "difficulty": "Medium",
      "pattern": "array-hashing",
      "leetcodeUrl": "https://leetcode.com/problems/longest-consecutive-sequence/",
      "leetcodeNumber": 128,
      "description": "Given an unsorted array of integers `nums`, return the length of the longest consecutive elements sequence.\n\nYou must write an algorithm that runs in O(n) time.\n\n**Example 1:**\nInput: nums = [100,4,200,1,3,2]\nOutput: 4\nExplanation: The longest consecutive sequence is [1, 2, 3, 4]. Its length is 4.\n\n**Example 2:**\nInput: nums = [0,3,7,2,5,8,4,6,0,1]\nOutput: 9\nExplanation: The longest consecutive sequence is [0, 1, 2, 3, 4, 5, 6, 7, 8]. Its length is 9.",
      "starterCode": "function longestConsecutive(nums) {\n  // Your code here\n  \n}",
      "steps": [
        {
          "title": "Understand the Problem",
          "hint": "A consecutive sequence means numbers like 1,2,3,4 (each differing by 1). The sequence does not need to be contiguous in the array. Think about how to find the start of each sequence.",
          "approach": "We need to find the longest chain of consecutive integers in the array (regardless of their positions). For example, in [100,4,200,1,3,2], the chain 1->2->3->4 has length 4. We need an O(n) solution, which means sorting (O(n log n)) is not optimal enough."
        },
        {
          "title": "Brute Force Approach",
          "hint": "Sort the array first, then scan for the longest run of consecutive numbers.",
          "approach": "Sort the array, then iterate through it tracking the current consecutive streak. When the next element is exactly 1 more than the current, extend the streak. When it is the same (duplicate), skip. Otherwise, reset the streak. Track the maximum streak length.",
          "code": "function longestConsecutive(nums) {\n  if (nums.length === 0) return 0;\n  nums.sort((a, b) => a - b);\n  let longest = 1;\n  let current = 1;\n  for (let i = 1; i < nums.length; i++) {\n    if (nums[i] === nums[i - 1]) continue;\n    if (nums[i] === nums[i - 1] + 1) {\n      current++;\n    } else {\n      current = 1;\n    }\n    longest = Math.max(longest, current);\n  }\n  return longest;\n}",
          "complexity": "Time: O(n log n), Space: O(1)"
        },
        {
          "title": "Optimal Approach",
          "hint": "Put all numbers in a Set. A number is the start of a sequence only if (num - 1) is NOT in the set. From each start, count consecutive numbers.",
          "approach": "Add all numbers to a Set for O(1) lookups. Then iterate through the set: for each number, check if (num - 1) exists. If it does not, this number is the start of a new sequence. From this start, keep checking if (num + 1), (num + 2), etc. exist and count the length. Although there are nested lookups, each number is visited at most twice (once in the outer loop, once as part of a sequence), so total work is O(n).",
          "code": "function longestConsecutive(nums) {\n  const numSet = new Set(nums);\n  let longest = 0;\n  for (const num of numSet) {\n    if (!numSet.has(num - 1)) {\n      let currentNum = num;\n      let currentStreak = 1;\n      while (numSet.has(currentNum + 1)) {\n        currentNum++;\n        currentStreak++;\n      }\n      longest = Math.max(longest, currentStreak);\n    }\n  }\n  return longest;\n}",
          "complexity": "Time: O(n), Space: O(n)"
        }
      ],
      "testCases": [
        {
          "args": [
            [
              100,
              4,
              200,
              1,
              3,
              2
            ]
          ],
          "expected": 4,
          "description": "Longest consecutive is [1,2,3,4]"
        },
        {
          "args": [
            [
              0,
              3,
              7,
              2,
              5,
              8,
              4,
              6,
              0,
              1
            ]
          ],
          "expected": 9,
          "description": "Longest consecutive is [0..8]"
        },
        {
          "args": [
            []
          ],
          "expected": 0,
          "description": "Empty array returns 0"
        }
      ],
      "ankiCards": [
        {
          "id": "longest-consecutive-pattern",
          "front": "In Longest Consecutive Sequence, how do you identify the start of a sequence in O(n) total time?",
          "back": "Put all numbers in a Set. A number is a sequence start if (num - 1) is NOT in the set. Only start counting from sequence starts. This ensures each number is processed at most twice (once to check if it is a start, once as part of a sequence count), giving O(n) total time."
        },
        {
          "id": "longest-consecutive-complexity",
          "front": "Why is the Longest Consecutive Sequence hash set solution O(n) despite having a while loop inside a for loop?",
          "back": "Because the inner while loop only runs for sequence starts, and each number in the set is visited by the inner loop at most once across the entire execution. The total number of iterations across all inner loop runs is at most n. So the combined work of the outer for loop and inner while loop is O(n)."
        }
      ]
    },
    {
      "id": "contains-duplicate",
      "title": "Contains Duplicate",
      "difficulty": "Easy",
      "pattern": "array-hashing",
      "leetcodeUrl": "https://leetcode.com/problems/contains-duplicate/",
      "leetcodeNumber": 217,
      "description": "Given an integer array `nums`, return `true` if any value appears at least twice in the array, and return `false` if every element is distinct.\n\n**Example 1:**\nInput: nums = [1,2,3,1]\nOutput: true\nExplanation: The element 1 occurs at indices 0 and 3.\n\n**Example 2:**\nInput: nums = [1,2,3,4]\nOutput: false\nExplanation: All elements are distinct.\n\n**Example 3:**\nInput: nums = [1,1,1,3,3,4,3,2,4,2]\nOutput: true",
      "starterCode": "function containsDuplicate(nums) {\n  // Your code here\n  \n}",
      "steps": [
        {
          "title": "Understand the Problem",
          "hint": "You just need to detect if any number appears more than once. Think about what data structures are good at tracking 'have I seen this before?'",
          "approach": "We need to check if any element in the array is repeated. If we find even one duplicate, return true. If all elements are unique, return false."
        },
        {
          "title": "Brute Force Approach",
          "hint": "Compare every element with every other element using nested loops.",
          "approach": "Use two nested loops: for each element at index i, check all elements at indices j > i. If nums[i] === nums[j], return true. If no duplicates are found after checking all pairs, return false.",
          "code": "function containsDuplicate(nums) {\n  for (let i = 0; i < nums.length; i++) {\n    for (let j = i + 1; j < nums.length; j++) {\n      if (nums[i] === nums[j]) {\n        return true;\n      }\n    }\n  }\n  return false;\n}",
          "complexity": "Time: O(n^2), Space: O(1)"
        },
        {
          "title": "Optimal Approach",
          "hint": "Use a Set. What property of a Set makes it perfect for duplicate detection?",
          "approach": "Use a Set to track numbers we have seen. As we iterate through the array, check if the current number is already in the Set. If it is, we found a duplicate. Otherwise, add it to the Set. Alternatively, simply compare the Set size to the array length.",
          "code": "function containsDuplicate(nums) {\n  const seen = new Set();\n  for (const num of nums) {\n    if (seen.has(num)) {\n      return true;\n    }\n    seen.add(num);\n  }\n  return false;\n}",
          "complexity": "Time: O(n), Space: O(n)"
        }
      ],
      "testCases": [
        {
          "args": [
            [
              1,
              2,
              3,
              1
            ]
          ],
          "expected": true,
          "description": "Has duplicate: 1 appears twice"
        },
        {
          "args": [
            [
              1,
              2,
              3,
              4
            ]
          ],
          "expected": false,
          "description": "All elements are distinct"
        },
        {
          "args": [
            [
              1,
              1,
              1,
              3,
              3,
              4,
              3,
              2,
              4,
              2
            ]
          ],
          "expected": true,
          "description": "Multiple duplicates present"
        }
      ],
      "ankiCards": [
        {
          "id": "contains-duplicate-pattern",
          "front": "What is the most efficient data structure for detecting duplicates in an array and why?",
          "back": "A Set (hash set). It provides O(1) average-time lookups and insertions. You iterate through the array once, checking if each element is already in the set. If yes, it is a duplicate. If no, add it to the set."
        },
        {
          "id": "contains-duplicate-complexity",
          "front": "What is the time and space complexity of detecting duplicates using a Set?",
          "back": "Time: O(n) - we iterate through the array once, with O(1) Set operations. Space: O(n) - in the worst case (no duplicates), we store all n elements in the Set."
        }
      ]
    },
    {
      "id": "product-of-array-except-self",
      "title": "Product of Array Except Self",
      "difficulty": "Medium",
      "pattern": "array-hashing",
      "leetcodeUrl": "https://leetcode.com/problems/product-of-array-except-self/",
      "leetcodeNumber": 238,
      "description": "Given an integer array `nums`, return an array `answer` such that `answer[i]` is equal to the product of all the elements of `nums` except `nums[i]`.\n\nThe product of any prefix or suffix of `nums` is guaranteed to fit in a 32-bit integer.\n\nYou must write an algorithm that runs in O(n) time and **without using the division operation**.\n\n**Example 1:**\nInput: nums = [1,2,3,4]\nOutput: [24,12,8,6]\nExplanation: For index 0: 2*3*4=24, for index 1: 1*3*4=12, etc.\n\n**Example 2:**\nInput: nums = [-1,1,0,-3,3]\nOutput: [0,0,9,0,0]",
      "starterCode": "function productExceptSelf(nums) {\n  // Your code here\n  \n}",
      "steps": [
        {
          "title": "Understand the Problem",
          "hint": "For each position, you need the product of everything to its left multiplied by everything to its right. Think about prefix and suffix products.",
          "approach": "For each index i, the result is the product of all elements except nums[i]. We cannot use division, so we need another strategy. Notice that product-except-self at index i = (product of elements before i) * (product of elements after i). These are prefix and suffix products."
        },
        {
          "title": "Brute Force Approach",
          "hint": "For each element, compute the product of all other elements using a nested loop.",
          "approach": "For each index i, multiply all elements at every other index j where j !== i. This requires an inner loop for each element.",
          "code": "function productExceptSelf(nums) {\n  const n = nums.length;\n  const result = new Array(n);\n  for (let i = 0; i < n; i++) {\n    let product = 1;\n    for (let j = 0; j < n; j++) {\n      if (j !== i) {\n        product *= nums[j];\n      }\n    }\n    result[i] = product;\n  }\n  return result;\n}",
          "complexity": "Time: O(n^2), Space: O(1) excluding output array"
        },
        {
          "title": "Optimal Approach",
          "hint": "Make two passes: one left-to-right building prefix products, one right-to-left building suffix products. You can use the output array itself to save space.",
          "approach": "First pass (left to right): for each index, store the product of all elements to its left. Second pass (right to left): multiply each position by the product of all elements to its right. After both passes, each position holds the product of all elements except itself.",
          "code": "function productExceptSelf(nums) {\n  const n = nums.length;\n  const result = new Array(n);\n  result[0] = 1;\n  for (let i = 1; i < n; i++) {\n    result[i] = result[i - 1] * nums[i - 1];\n  }\n  let rightProduct = 1;\n  for (let i = n - 1; i >= 0; i--) {\n    result[i] *= rightProduct;\n    rightProduct *= nums[i];\n  }\n  return result;\n}",
          "complexity": "Time: O(n), Space: O(1) excluding output array"
        }
      ],
      "testCases": [
        {
          "args": [
            [
              1,
              2,
              3,
              4
            ]
          ],
          "expected": [
            24,
            12,
            8,
            6
          ],
          "description": "Standard case with positive numbers"
        },
        {
          "args": [
            [
              -1,
              1,
              0,
              -3,
              3
            ]
          ],
          "expected": [
            0,
            0,
            9,
            0,
            0
          ],
          "description": "Array containing zero and negatives"
        },
        {
          "args": [
            [
              2,
              3
            ]
          ],
          "expected": [
            3,
            2
          ],
          "description": "Minimum length array (2 elements)"
        }
      ],
      "ankiCards": [
        {
          "id": "product-except-self-pattern",
          "front": "How do you compute Product of Array Except Self without division in O(n) time?",
          "back": "Use prefix and suffix products. Pass 1 (left to right): result[i] = product of all elements before index i. Pass 2 (right to left): multiply result[i] by the product of all elements after index i. Each position ends up with the product of everything except itself."
        },
        {
          "id": "product-except-self-complexity",
          "front": "In the optimal Product Except Self solution, why is the space complexity O(1)?",
          "back": "The output array does not count as extra space per the problem constraints. We use the output array to store prefix products, then a single variable (rightProduct) for the suffix pass. No additional arrays are needed, so extra space is O(1)."
        }
      ]
    },
    {
      "id": "valid-anagram",
      "title": "Valid Anagram",
      "difficulty": "Easy",
      "pattern": "array-hashing",
      "leetcodeUrl": "https://leetcode.com/problems/valid-anagram/",
      "leetcodeNumber": 242,
      "description": "Given two strings `s` and `t`, return `true` if `t` is an anagram of `s`, and `false` otherwise.\n\nAn anagram is a word formed by rearranging the letters of another word, using all the original letters exactly once.\n\n**Example 1:**\nInput: s = \"anagram\", t = \"nagaram\"\nOutput: true\n\n**Example 2:**\nInput: s = \"rat\", t = \"car\"\nOutput: false\n\n**Constraints:**\n- s and t consist of lowercase English letters.",
      "starterCode": "function isAnagram(s, t) {\n  // Your code here\n  \n}",
      "steps": [
        {
          "title": "Understand the Problem",
          "hint": "An anagram uses the exact same letters the exact same number of times. How can you verify this?",
          "approach": "Two strings are anagrams if and only if they contain the same characters with the same frequencies. So 'listen' and 'silent' are anagrams because both have the same letter counts. If the lengths differ, they cannot be anagrams."
        },
        {
          "title": "Brute Force Approach",
          "hint": "Sort both strings and compare them.",
          "approach": "If two strings are anagrams, sorting them will produce the same string. Split each string into an array of characters, sort the arrays, and join them back. Compare the two sorted strings.",
          "code": "function isAnagram(s, t) {\n  if (s.length !== t.length) return false;\n  return s.split('').sort().join('') === t.split('').sort().join('');\n}",
          "complexity": "Time: O(n log n), Space: O(n)"
        },
        {
          "title": "Optimal Approach",
          "hint": "Use a frequency counter (hash map). Count characters in one string and decrement for the other.",
          "approach": "Create a frequency map from the first string, counting occurrences of each character. Then iterate through the second string, decrementing counts. If any count goes below zero or the lengths differ, they are not anagrams.",
          "code": "function isAnagram(s, t) {\n  if (s.length !== t.length) return false;\n  const count = {};\n  for (const char of s) {\n    count[char] = (count[char] || 0) + 1;\n  }\n  for (const char of t) {\n    if (!count[char]) return false;\n    count[char]--;\n  }\n  return true;\n}",
          "complexity": "Time: O(n), Space: O(1) - at most 26 lowercase letters"
        }
      ],
      "testCases": [
        {
          "args": [
            "anagram",
            "nagaram"
          ],
          "expected": true,
          "description": "Valid anagram"
        },
        {
          "args": [
            "rat",
            "car"
          ],
          "expected": false,
          "description": "Not an anagram - different letters"
        },
        {
          "args": [
            "a",
            "ab"
          ],
          "expected": false,
          "description": "Different lengths"
        }
      ],
      "ankiCards": [
        {
          "id": "valid-anagram-pattern",
          "front": "What are two common approaches to check if two strings are anagrams?",
          "back": "1) Sort both strings and compare - O(n log n) time. 2) Use a character frequency counter (hash map) - count chars in the first string, decrement for the second. If all counts reach zero, they are anagrams. O(n) time."
        },
        {
          "id": "valid-anagram-complexity",
          "front": "Why is the space complexity of the frequency-counter anagram solution considered O(1)?",
          "back": "Because the character set is fixed (26 lowercase English letters), the hash map can have at most 26 entries regardless of input size. The space does not grow with the input length n, so it is O(1) or more precisely O(k) where k is the alphabet size."
        }
      ]
    },
    {
      "id": "top-k-frequent-elements",
      "title": "Top K Frequent Elements",
      "difficulty": "Medium",
      "pattern": "array-hashing",
      "leetcodeUrl": "https://leetcode.com/problems/top-k-frequent-elements/",
      "leetcodeNumber": 347,
      "description": "Given an integer array `nums` and an integer `k`, return the `k` most frequent elements. You may return the answer in any order.\n\n**Example 1:**\nInput: nums = [1,1,1,2,2,3], k = 2\nOutput: [1,2]\nExplanation: 1 appears 3 times, 2 appears 2 times. The two most frequent elements are 1 and 2.\n\n**Example 2:**\nInput: nums = [1], k = 1\nOutput: [1]\n\n**Constraints:**\n- It is guaranteed that the answer is unique.\n- k is always valid (1 <= k <= number of distinct elements).",
      "starterCode": "function topKFrequent(nums, k) {\n  // Your code here\n  \n}",
      "steps": [
        {
          "title": "Understand the Problem",
          "hint": "First count how often each number appears, then figure out which k numbers appear most often.",
          "approach": "We need to find the k elements that appear most frequently in the array. First we need to count the frequency of each element, then select the top k by frequency. The result order does not matter."
        },
        {
          "title": "Brute Force Approach",
          "hint": "Count frequencies with a hash map, then sort entries by frequency and take the top k.",
          "approach": "Build a frequency map, convert it to an array of [num, count] pairs, sort by count in descending order, and return the first k elements.",
          "code": "function topKFrequent(nums, k) {\n  const freqMap = {};\n  for (const num of nums) {\n    freqMap[num] = (freqMap[num] || 0) + 1;\n  }\n  const sorted = Object.entries(freqMap)\n    .sort((a, b) => b[1] - a[1]);\n  return sorted.slice(0, k).map(entry => Number(entry[0]));\n}",
          "complexity": "Time: O(n log n), Space: O(n)"
        },
        {
          "title": "Optimal Approach",
          "hint": "Use bucket sort. The maximum frequency any element can have is n (the array length). Create an array of buckets where index = frequency.",
          "approach": "After counting frequencies, use bucket sort: create an array of size n+1 where each index represents a frequency. Place each number into the bucket corresponding to its frequency. Then iterate from the highest bucket down, collecting elements until we have k elements. This avoids comparison-based sorting.",
          "code": "function topKFrequent(nums, k) {\n  const freqMap = new Map();\n  for (const num of nums) {\n    freqMap.set(num, (freqMap.get(num) || 0) + 1);\n  }\n  const buckets = new Array(nums.length + 1).fill(null).map(() => []);\n  for (const [num, freq] of freqMap) {\n    buckets[freq].push(num);\n  }\n  const result = [];\n  for (let i = buckets.length - 1; i >= 0 && result.length < k; i--) {\n    for (const num of buckets[i]) {\n      result.push(num);\n      if (result.length === k) break;\n    }\n  }\n  return result;\n}",
          "complexity": "Time: O(n), Space: O(n)"
        }
      ],
      "testCases": [
        {
          "args": [
            [
              1,
              1,
              1,
              2,
              2,
              3
            ],
            2
          ],
          "expected": [
            1,
            2
          ],
          "description": "Top 2 frequent: 1 appears 3 times, 2 appears 2 times"
        },
        {
          "args": [
            [
              1
            ],
            1
          ],
          "expected": [
            1
          ],
          "description": "Single element array"
        },
        {
          "args": [
            [
              4,
              4,
              4,
              1,
              1,
              2,
              2,
              2,
              3
            ],
            2
          ],
          "expected": [
            4,
            2
          ],
          "description": "Two elements tied for high frequency"
        }
      ],
      "ankiCards": [
        {
          "id": "top-k-frequent-pattern",
          "front": "How does bucket sort help solve 'Top K Frequent Elements' in O(n) time?",
          "back": "After counting frequencies with a hash map, create an array of buckets where index = frequency. The max possible frequency is n (array length). Place each number into its frequency bucket. Then iterate backwards from the highest bucket, collecting elements until you have k. No comparison sort needed."
        },
        {
          "id": "top-k-frequent-complexity",
          "front": "What are the time complexities of the sorting vs. bucket sort approaches for Top K Frequent Elements?",
          "back": "Sorting approach: O(n log n) - dominated by the sort step. Bucket sort approach: O(n) - counting is O(n), building buckets is O(n), and collecting results is O(n). Both use O(n) space."
        }
      ]
    },
    {
      "id": "container-with-most-water",
      "title": "Container With Most Water",
      "difficulty": "Medium",
      "pattern": "two-pointers",
      "leetcodeUrl": "https://leetcode.com/problems/container-with-most-water/",
      "leetcodeNumber": 11,
      "description": "You are given an integer array `height` of length `n`. There are `n` vertical lines drawn such that the two endpoints of the i-th line are `(i, 0)` and `(i, height[i])`.\n\nFind two lines that together with the x-axis forms a container that holds the most water.\n\nReturn the maximum amount of water a container can store.\n\nNotice that you may not slant the container.\n\n**Example 1:**\nInput: height = [1,8,6,2,5,4,8,3,7]\nOutput: 49\nExplanation: The lines at index 1 (height 8) and index 8 (height 7) form a container of width 7 and height min(8,7)=7, area = 7 * 7 = 49.\n\n**Example 2:**\nInput: height = [1,1]\nOutput: 1",
      "starterCode": "function maxArea(height) {\n  // Your code here\n  \n}",
      "steps": [
        {
          "title": "Understand the Problem",
          "hint": "The water held between two lines is determined by the shorter line's height multiplied by the distance between them. Think about why moving the shorter pointer inward is always the right choice.",
          "approach": "We want to find two vertical lines that form a container holding the maximum water. The water volume is: min(height[left], height[right]) * (right - left). We need to maximize this across all pairs of lines."
        },
        {
          "title": "Brute Force Approach",
          "hint": "Try every pair of lines and calculate the area for each.",
          "approach": "Use two nested loops to check every pair of lines. For each pair (i, j), compute the area as min(height[i], height[j]) * (j - i). Track the maximum area.",
          "code": "function maxArea(height) {\n  let maxWater = 0;\n  for (let i = 0; i < height.length; i++) {\n    for (let j = i + 1; j < height.length; j++) {\n      const area = Math.min(height[i], height[j]) * (j - i);\n      maxWater = Math.max(maxWater, area);\n    }\n  }\n  return maxWater;\n}",
          "complexity": "Time: O(n^2), Space: O(1)"
        },
        {
          "title": "Optimal Approach",
          "hint": "Use two pointers at the edges. Always move the pointer pointing to the shorter line inward. Why? Because moving the taller line can only decrease the area.",
          "approach": "Start with pointers at the two ends (maximum width). Calculate the area. Then move the pointer with the shorter height inward. Rationale: the area is limited by the shorter line. Moving the taller line inward would reduce width without any possibility of increasing height (it is already not the bottleneck). Moving the shorter line gives a chance to find a taller line that increases the area.",
          "code": "function maxArea(height) {\n  let left = 0;\n  let right = height.length - 1;\n  let maxWater = 0;\n\n  while (left < right) {\n    const area = Math.min(height[left], height[right]) * (right - left);\n    maxWater = Math.max(maxWater, area);\n    if (height[left] < height[right]) {\n      left++;\n    } else {\n      right--;\n    }\n  }\n  return maxWater;\n}",
          "complexity": "Time: O(n), Space: O(1)"
        }
      ],
      "testCases": [
        {
          "args": [
            [
              1,
              8,
              6,
              2,
              5,
              4,
              8,
              3,
              7
            ]
          ],
          "expected": 49,
          "description": "Classic example: max area between index 1 and 8"
        },
        {
          "args": [
            [
              1,
              1
            ]
          ],
          "expected": 1,
          "description": "Minimum case: two lines of height 1"
        },
        {
          "args": [
            [
              4,
              3,
              2,
              1,
              4
            ]
          ],
          "expected": 16,
          "description": "Max area between first and last lines"
        }
      ],
      "ankiCards": [
        {
          "id": "container-water-pattern",
          "front": "In Container With Most Water, why do we always move the pointer at the shorter line?",
          "back": "The area is min(height[left], height[right]) * width. Moving the taller pointer inward reduces width and cannot increase the minimum height (the shorter line is still the bottleneck), so the area can only decrease. Moving the shorter pointer gives a chance to find a taller line, which could increase the area despite the reduced width."
        },
        {
          "id": "container-water-complexity",
          "front": "What is the time and space complexity of the two-pointer solution for Container With Most Water?",
          "back": "Time: O(n) - each pointer moves at most n times, and we process one step per iteration. Space: O(1) - only a few variables for pointers and tracking the max area."
        }
      ]
    },
    {
      "id": "3sum",
      "title": "3Sum",
      "difficulty": "Medium",
      "pattern": "two-pointers",
      "leetcodeUrl": "https://leetcode.com/problems/3sum/",
      "leetcodeNumber": 15,
      "description": "Given an integer array `nums`, return all the triplets `[nums[i], nums[j], nums[k]]` such that `i != j`, `i != k`, and `j != k`, and `nums[i] + nums[j] + nums[k] == 0`.\n\nNotice that the solution set must not contain duplicate triplets.\n\n**Example 1:**\nInput: nums = [-1,0,1,2,-1,-4]\nOutput: [[-1,-1,2],[-1,0,1]]\nExplanation:\nnums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0\nnums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0\nnums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0\nThe distinct triplets are [-1,-1,2] and [-1,0,1].\n\n**Example 2:**\nInput: nums = [0,1,1]\nOutput: []\nExplanation: The only possible triplet does not sum to 0.\n\n**Example 3:**\nInput: nums = [0,0,0]\nOutput: [[0,0,0]]",
      "starterCode": "function threeSum(nums) {\n  // Your code here\n  \n}",
      "steps": [
        {
          "title": "Understand the Problem",
          "hint": "You need to find all unique triplets that sum to zero. The hardest part is avoiding duplicate triplets. Sorting the array first helps with both the search and deduplication.",
          "approach": "Find all unique sets of three numbers from the array that add up to zero. The key challenges are: (1) efficiently finding triplets and (2) avoiding duplicates in the result. Sorting the array enables both: we can use the two-pointer technique and skip duplicate values."
        },
        {
          "title": "Brute Force Approach",
          "hint": "Use three nested loops and a set to track seen triplets.",
          "approach": "Try every combination of three distinct indices. Check if they sum to zero. To avoid duplicates, sort each triplet and store it as a string in a Set. Convert the Set back to the result array. This works but is very slow.",
          "code": "function threeSum(nums) {\n  const result = [];\n  const seen = new Set();\n  for (let i = 0; i < nums.length; i++) {\n    for (let j = i + 1; j < nums.length; j++) {\n      for (let k = j + 1; k < nums.length; k++) {\n        if (nums[i] + nums[j] + nums[k] === 0) {\n          const triplet = [nums[i], nums[j], nums[k]].sort((a, b) => a - b);\n          const key = triplet.join(',');\n          if (!seen.has(key)) {\n            seen.add(key);\n            result.push(triplet);\n          }\n        }\n      }\n    }\n  }\n  return result;\n}",
          "complexity": "Time: O(n^3), Space: O(n)"
        },
        {
          "title": "Optimal Approach",
          "hint": "Sort the array. Fix one number and use two pointers on the remaining sorted portion to find pairs that sum to the negative of the fixed number. Skip duplicates at each level.",
          "approach": "Sort the array. For each element nums[i], use two pointers (left = i+1, right = end) to find pairs that sum to -nums[i]. Skip duplicate values of nums[i] by checking if nums[i] === nums[i-1]. When a triplet is found, skip duplicates for left and right pointers too. This reduces from O(n^3) to O(n^2).",
          "code": "function threeSum(nums) {\n  nums.sort((a, b) => a - b);\n  const result = [];\n\n  for (let i = 0; i < nums.length - 2; i++) {\n    if (i > 0 && nums[i] === nums[i - 1]) continue;\n    let left = i + 1;\n    let right = nums.length - 1;\n\n    while (left < right) {\n      const sum = nums[i] + nums[left] + nums[right];\n      if (sum === 0) {\n        result.push([nums[i], nums[left], nums[right]]);\n        while (left < right && nums[left] === nums[left + 1]) left++;\n        while (left < right && nums[right] === nums[right - 1]) right--;\n        left++;\n        right--;\n      } else if (sum < 0) {\n        left++;\n      } else {\n        right--;\n      }\n    }\n  }\n  return result;\n}",
          "complexity": "Time: O(n^2), Space: O(1) excluding output"
        }
      ],
      "testCases": [
        {
          "args": [
            [
              -1,
              0,
              1,
              2,
              -1,
              -4
            ]
          ],
          "expected": [
            [
              -1,
              -1,
              2
            ],
            [
              -1,
              0,
              1
            ]
          ],
          "description": "Multiple valid triplets"
        },
        {
          "args": [
            [
              0,
              1,
              1
            ]
          ],
          "expected": [],
          "description": "No valid triplets"
        },
        {
          "args": [
            [
              0,
              0,
              0
            ]
          ],
          "expected": [
            [
              0,
              0,
              0
            ]
          ],
          "description": "All zeros"
        }
      ],
      "ankiCards": [
        {
          "id": "3sum-pattern",
          "front": "How does 3Sum reduce from O(n^3) to O(n^2), and how are duplicates handled?",
          "back": "Sort the array first. Fix one element (outer loop), then use two pointers to find pairs summing to its negative (like Two Sum II). This makes the inner search O(n) instead of O(n^2). Duplicates are handled by: (1) skipping the outer element if it equals the previous one, (2) after finding a triplet, advancing both pointers past duplicate values."
        },
        {
          "id": "3sum-complexity",
          "front": "What is the time and space complexity of the optimal 3Sum solution?",
          "back": "Time: O(n^2) - O(n log n) for sorting plus O(n) two-pointer search for each of n elements. Space: O(1) excluding the output array (or O(log n) for the sort stack, depending on the implementation)."
        }
      ]
    },
    {
      "id": "trapping-rain-water",
      "title": "Trapping Rain Water",
      "difficulty": "Hard",
      "pattern": "two-pointers",
      "leetcodeUrl": "https://leetcode.com/problems/trapping-rain-water/",
      "leetcodeNumber": 42,
      "description": "Given `n` non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it can trap after raining.\n\n**Example 1:**\nInput: height = [0,1,0,2,1,0,1,3,2,1,2,1]\nOutput: 6\nExplanation: The elevation map [0,1,0,2,1,0,1,3,2,1,2,1] can trap 6 units of rain water. Water fills in the gaps between taller bars.\n\n**Example 2:**\nInput: height = [4,2,0,3,2,5]\nOutput: 9",
      "starterCode": "function trap(height) {\n  // Your code here\n  \n}",
      "steps": [
        {
          "title": "Understand the Problem",
          "hint": "For each position, the water level is determined by the minimum of the tallest bar to its left and the tallest bar to its right. Water at position i = min(maxLeft, maxRight) - height[i].",
          "approach": "Imagine rain falling on the elevation map. Water gets trapped in valleys between bars. For each position i, the water above it equals min(max height to the left, max height to the right) - height[i]. If this value is negative, no water is trapped there. We need to sum the water at all positions."
        },
        {
          "title": "Brute Force Approach",
          "hint": "For each position, scan left to find the max height and scan right to find the max height.",
          "approach": "For each index i, find the maximum height to the left (including i) and the maximum height to the right (including i). The water at position i is min(leftMax, rightMax) - height[i]. Sum all positive values. The leftMax and rightMax scans make this O(n) per position.",
          "code": "function trap(height) {\n  let totalWater = 0;\n  for (let i = 0; i < height.length; i++) {\n    let leftMax = 0;\n    let rightMax = 0;\n    for (let j = 0; j <= i; j++) {\n      leftMax = Math.max(leftMax, height[j]);\n    }\n    for (let j = i; j < height.length; j++) {\n      rightMax = Math.max(rightMax, height[j]);\n    }\n    totalWater += Math.min(leftMax, rightMax) - height[i];\n  }\n  return totalWater;\n}",
          "complexity": "Time: O(n^2), Space: O(1)"
        },
        {
          "title": "Optimal Approach",
          "hint": "Use two pointers from both ends. Track leftMax and rightMax. Process the side with the smaller max because that side determines the water level.",
          "approach": "Use two pointers (left and right) starting at the edges, tracking leftMax and rightMax. At each step, process the pointer with the smaller max value. If leftMax <= rightMax, we know the water at the left pointer is determined by leftMax (the right side is at least as tall). Add (leftMax - height[left]) to the total and move left forward. Similarly for the right side. This works because the water level at any position is limited by the smaller of the two maxes.",
          "code": "function trap(height) {\n  let left = 0;\n  let right = height.length - 1;\n  let leftMax = 0;\n  let rightMax = 0;\n  let totalWater = 0;\n\n  while (left < right) {\n    if (height[left] < height[right]) {\n      if (height[left] >= leftMax) {\n        leftMax = height[left];\n      } else {\n        totalWater += leftMax - height[left];\n      }\n      left++;\n    } else {\n      if (height[right] >= rightMax) {\n        rightMax = height[right];\n      } else {\n        totalWater += rightMax - height[right];\n      }\n      right--;\n    }\n  }\n  return totalWater;\n}",
          "complexity": "Time: O(n), Space: O(1)"
        }
      ],
      "testCases": [
        {
          "args": [
            [
              0,
              1,
              0,
              2,
              1,
              0,
              1,
              3,
              2,
              1,
              2,
              1
            ]
          ],
          "expected": 6,
          "description": "Classic elevation map trapping 6 units"
        },
        {
          "args": [
            [
              4,
              2,
              0,
              3,
              2,
              5
            ]
          ],
          "expected": 9,
          "description": "V-shaped valley trapping 9 units"
        },
        {
          "args": [
            [
              1,
              2,
              3,
              4,
              5
            ]
          ],
          "expected": 0,
          "description": "Ascending bars: no water trapped"
        }
      ],
      "ankiCards": [
        {
          "id": "trapping-rain-water-pattern",
          "front": "In Trapping Rain Water, why does the two-pointer approach process the side with the smaller max height?",
          "back": "Water at any position is min(leftMax, rightMax) - height[i]. If leftMax < rightMax, the water at the left pointer is fully determined by leftMax (regardless of what rightMax actually is, since we know it is at least as large). So we can safely compute the water at the left position and advance. The same logic applies symmetrically for the right side."
        },
        {
          "id": "trapping-rain-water-complexity",
          "front": "What are three approaches to solve Trapping Rain Water, and what are their complexities?",
          "back": "1) Brute force: for each position scan left and right for max. O(n^2) time, O(1) space. 2) Prefix arrays: precompute leftMax[] and rightMax[] arrays. O(n) time, O(n) space. 3) Two pointers: track leftMax and rightMax while processing from both ends. O(n) time, O(1) space. The two-pointer approach is optimal."
        }
      ]
    },
    {
      "id": "valid-palindrome",
      "title": "Valid Palindrome",
      "difficulty": "Easy",
      "pattern": "two-pointers",
      "leetcodeUrl": "https://leetcode.com/problems/valid-palindrome/",
      "leetcodeNumber": 125,
      "description": "A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. Alphanumeric characters include letters and numbers.\n\nGiven a string `s`, return `true` if it is a palindrome, or `false` otherwise.\n\n**Example 1:**\nInput: s = \"A man, a plan, a canal: Panama\"\nOutput: true\nExplanation: \"amanaplanacanalpanama\" is a palindrome.\n\n**Example 2:**\nInput: s = \"race a car\"\nOutput: false\nExplanation: \"raceacar\" is not a palindrome.\n\n**Example 3:**\nInput: s = \" \"\nOutput: true\nExplanation: After removing non-alphanumeric characters, s is an empty string. An empty string is a palindrome by definition.",
      "starterCode": "function isPalindrome(s) {\n  // Your code here\n  \n}",
      "steps": [
        {
          "title": "Understand the Problem",
          "hint": "First strip out all non-alphanumeric characters and convert to lowercase, then check if the result reads the same forwards and backwards.",
          "approach": "We need to check if a string is a palindrome, but only considering alphanumeric characters (letters and digits) and ignoring case. So 'A man, a plan, a canal: Panama' becomes 'amanaplanacanalpanama', which is a palindrome."
        },
        {
          "title": "Brute Force Approach",
          "hint": "Clean the string first (remove non-alphanumeric, lowercase), then reverse it and compare.",
          "approach": "Filter the string to keep only alphanumeric characters, convert to lowercase, then reverse the result and compare it with the original cleaned string.",
          "code": "function isPalindrome(s) {\n  const cleaned = s.replace(/[^a-zA-Z0-9]/g, '').toLowerCase();\n  const reversed = cleaned.split('').reverse().join('');\n  return cleaned === reversed;\n}",
          "complexity": "Time: O(n), Space: O(n)"
        },
        {
          "title": "Optimal Approach",
          "hint": "Use two pointers: one at the start, one at the end. Skip non-alphanumeric characters and compare.",
          "approach": "Use a left pointer starting at index 0 and a right pointer starting at the end. Move each pointer inward, skipping any non-alphanumeric characters. At each step, compare the characters (case-insensitive). If they differ, return false. If the pointers cross without finding a mismatch, return true. This avoids creating extra strings.",
          "code": "function isPalindrome(s) {\n  let left = 0;\n  let right = s.length - 1;\n\n  while (left < right) {\n    while (left < right && !isAlphaNumeric(s[left])) left++;\n    while (left < right && !isAlphaNumeric(s[right])) right--;\n    if (s[left].toLowerCase() !== s[right].toLowerCase()) {\n      return false;\n    }\n    left++;\n    right--;\n  }\n  return true;\n}\n\nfunction isAlphaNumeric(c) {\n  return /[a-zA-Z0-9]/.test(c);\n}",
          "complexity": "Time: O(n), Space: O(1)"
        }
      ],
      "testCases": [
        {
          "args": [
            "A man, a plan, a canal: Panama"
          ],
          "expected": true,
          "description": "Classic palindrome with spaces and punctuation"
        },
        {
          "args": [
            "race a car"
          ],
          "expected": false,
          "description": "Not a palindrome"
        },
        {
          "args": [
            " "
          ],
          "expected": true,
          "description": "Empty/whitespace string is a palindrome"
        }
      ],
      "ankiCards": [
        {
          "id": "valid-palindrome-pattern",
          "front": "How do two pointers help check if a string is a valid palindrome (ignoring non-alphanumeric characters)?",
          "back": "Place one pointer at the start and one at the end. Move each inward, skipping non-alphanumeric characters. Compare the characters at each position (case-insensitive). If they mismatch, it is not a palindrome. This achieves O(1) space since no new string is created."
        },
        {
          "id": "valid-palindrome-complexity",
          "front": "What is the space advantage of the two-pointer palindrome approach over the reverse-and-compare approach?",
          "back": "Two-pointer: O(1) space - no extra strings are created, comparison is done in-place. Reverse-and-compare: O(n) space - requires creating a cleaned string and its reversed copy. Both are O(n) time."
        }
      ]
    },
    {
      "id": "two-sum-ii",
      "title": "Two Sum II - Input Array Is Sorted",
      "difficulty": "Medium",
      "pattern": "two-pointers",
      "leetcodeUrl": "https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/",
      "leetcodeNumber": 167,
      "description": "Given a 1-indexed array of integers `numbers` that is already sorted in non-decreasing order, find two numbers such that they add up to a specific `target` number.\n\nReturn the indices of the two numbers (1-indexed) as an integer array `[index1, index2]` where 1 <= index1 < index2 <= numbers.length.\n\nYou may not use the same element twice. Your solution must use only constant extra space.\n\n**Example 1:**\nInput: numbers = [2,7,11,15], target = 9\nOutput: [1,2]\nExplanation: 2 + 7 = 9. So index1 = 1, index2 = 2. Return [1, 2].\n\n**Example 2:**\nInput: numbers = [2,3,4], target = 6\nOutput: [1,3]\n\n**Example 3:**\nInput: numbers = [-1,0], target = -1\nOutput: [1,2]",
      "starterCode": "function twoSum(numbers, target) {\n  // Your code here\n  \n}",
      "steps": [
        {
          "title": "Understand the Problem",
          "hint": "The array is sorted. How can you use this property to avoid checking every pair? Think about what happens when the sum of two numbers is too large or too small.",
          "approach": "This is a variant of Two Sum where the array is already sorted. We need to find two numbers that add up to the target and return their 1-indexed positions. The sorted property is the key: it allows us to use two pointers instead of a hash map, achieving O(1) space."
        },
        {
          "title": "Brute Force Approach",
          "hint": "Try all pairs (just like regular Two Sum), ignoring the sorted property.",
          "approach": "Check every pair of numbers using nested loops. If their sum equals the target, return their 1-indexed positions. This does not leverage the sorted order.",
          "code": "function twoSum(numbers, target) {\n  for (let i = 0; i < numbers.length; i++) {\n    for (let j = i + 1; j < numbers.length; j++) {\n      if (numbers[i] + numbers[j] === target) {\n        return [i + 1, j + 1];\n      }\n    }\n  }\n  return [];\n}",
          "complexity": "Time: O(n^2), Space: O(1)"
        },
        {
          "title": "Optimal Approach",
          "hint": "Use two pointers: one at the beginning, one at the end. If the sum is too large, move the right pointer left. If too small, move the left pointer right.",
          "approach": "Since the array is sorted, place a left pointer at the start and a right pointer at the end. Compute their sum. If sum equals target, we found the answer. If sum is less than target, move left pointer right (to increase the sum). If sum is greater than target, move right pointer left (to decrease the sum). The sorted order guarantees this converges to the answer.",
          "code": "function twoSum(numbers, target) {\n  let left = 0;\n  let right = numbers.length - 1;\n\n  while (left < right) {\n    const sum = numbers[left] + numbers[right];\n    if (sum === target) {\n      return [left + 1, right + 1];\n    } else if (sum < target) {\n      left++;\n    } else {\n      right--;\n    }\n  }\n  return [];\n}",
          "complexity": "Time: O(n), Space: O(1)"
        }
      ],
      "testCases": [
        {
          "args": [
            [
              2,
              7,
              11,
              15
            ],
            9
          ],
          "expected": [
            1,
            2
          ],
          "description": "First two elements sum to target"
        },
        {
          "args": [
            [
              2,
              3,
              4
            ],
            6
          ],
          "expected": [
            1,
            3
          ],
          "description": "First and last elements sum to target"
        },
        {
          "args": [
            [
              -1,
              0
            ],
            -1
          ],
          "expected": [
            1,
            2
          ],
          "description": "Negative numbers"
        }
      ],
      "ankiCards": [
        {
          "id": "two-sum-ii-pattern",
          "front": "Why can you use two pointers for Two Sum II but not for the original Two Sum?",
          "back": "Two Sum II has a sorted array, which is the key requirement. With sorted order, if the sum of numbers[left] + numbers[right] is too small, moving left forward increases the sum; if too large, moving right backward decreases it. The original Two Sum has an unsorted array, so this logic does not apply."
        },
        {
          "id": "two-sum-ii-complexity",
          "front": "What is the time and space complexity of the two-pointer solution for Two Sum II?",
          "back": "Time: O(n) - each pointer moves at most n times total. Space: O(1) - only two pointer variables are used, no hash map needed. This is better than the hash map approach which uses O(n) space."
        }
      ]
    },
    {
      "id": "longest-substring-without-repeating-characters",
      "title": "Longest Substring Without Repeating Characters",
      "difficulty": "Medium",
      "pattern": "sliding-window",
      "leetcodeUrl": "https://leetcode.com/problems/longest-substring-without-repeating-characters/",
      "leetcodeNumber": 3,
      "description": "Given a string `s`, find the length of the longest substring without repeating characters.\n\nExample 1:\nInput: s = \"abcabcbb\"\nOutput: 3\nExplanation: The answer is \"abc\", with the length of 3.\n\nExample 2:\nInput: s = \"bbbbb\"\nOutput: 1\nExplanation: The answer is \"b\", with the length of 1.\n\nExample 3:\nInput: s = \"pwwkew\"\nOutput: 3\nExplanation: The answer is \"wke\", with the length of 3.",
      "starterCode": "function lengthOfLongestSubstring(s) {\n  // Your code here\n  \n}",
      "steps": [
        {
          "title": "Understand the Problem",
          "hint": "A substring is contiguous. You need to find the longest window of characters where no character repeats.",
          "approach": "Think about using two pointers to define a window. You need a way to detect duplicates efficiently. A Set or Map can help track characters in the current window."
        },
        {
          "title": "Brute Force",
          "hint": "Check all substrings and verify each has unique characters.",
          "approach": "For every starting index i, extend the substring to the right as long as no character repeats. Use a Set to check for duplicates. Track the maximum length found.",
          "code": "function lengthOfLongestSubstring(s) {\n  let maxLen = 0;\n  for (let i = 0; i < s.length; i++) {\n    const seen = new Set();\n    for (let j = i; j < s.length; j++) {\n      if (seen.has(s[j])) break;\n      seen.add(s[j]);\n      maxLen = Math.max(maxLen, j - i + 1);\n    }\n  }\n  return maxLen;\n}",
          "complexity": "Time: O(n^2), Space: O(min(n, m)) where m is the character set size"
        },
        {
          "title": "Optimal",
          "hint": "Use a sliding window with a Map that stores each character's last-seen index.",
          "approach": "Maintain a left pointer and a Map of character -> last index. Move right pointer through the string. If the character was seen and its last index >= left, move left to lastIndex + 1. Update the map and track the max window size.",
          "code": "function lengthOfLongestSubstring(s) {\n  const map = new Map();\n  let left = 0;\n  let maxLen = 0;\n  for (let right = 0; right < s.length; right++) {\n    if (map.has(s[right]) && map.get(s[right]) >= left) {\n      left = map.get(s[right]) + 1;\n    }\n    map.set(s[right], right);\n    maxLen = Math.max(maxLen, right - left + 1);\n  }\n  return maxLen;\n}",
          "complexity": "Time: O(n), Space: O(min(n, m)) where m is the character set size"
        }
      ],
      "testCases": [
        {
          "args": [
            "abcabcbb"
          ],
          "expected": 3,
          "description": "Longest is 'abc' with length 3"
        },
        {
          "args": [
            "bbbbb"
          ],
          "expected": 1,
          "description": "All same characters, longest is 'b'"
        },
        {
          "args": [
            "pwwkew"
          ],
          "expected": 3,
          "description": "Longest is 'wke' with length 3"
        }
      ],
      "ankiCards": [
        {
          "id": "longest-substring-no-repeat-approach",
          "front": "Longest Substring Without Repeating Characters: What data structure and technique should you use?",
          "back": "Use a sliding window with a HashMap that maps each character to its most recent index. When a duplicate is found within the window, jump the left pointer to one past the duplicate's last position. O(n) time."
        },
        {
          "id": "longest-substring-no-repeat-left-pointer",
          "front": "Longest Substring Without Repeating Characters: When do you move the left pointer and why check >= left?",
          "back": "Move left to map.get(char) + 1 when a duplicate is found. You must check map.get(char) >= left because the duplicate might be from before the current window (already excluded), so you should not move left backward."
        }
      ]
    },
    {
      "id": "minimum-window-substring",
      "title": "Minimum Window Substring",
      "difficulty": "Hard",
      "pattern": "sliding-window",
      "leetcodeUrl": "https://leetcode.com/problems/minimum-window-substring/",
      "leetcodeNumber": 76,
      "description": "Given two strings `s` and `t` of lengths m and n respectively, return the minimum window substring of `s` such that every character in `t` (including duplicates) is included in the window. If there is no such substring, return the empty string \"\".\n\nExample 1:\nInput: s = \"ADOBECODEBANC\", t = \"ABC\"\nOutput: \"BANC\"\nExplanation: The minimum window substring \"BANC\" includes 'A', 'B', and 'C' from string t.\n\nExample 2:\nInput: s = \"a\", t = \"a\"\nOutput: \"a\"\n\nExample 3:\nInput: s = \"a\", t = \"aa\"\nOutput: \"\"\nExplanation: Both 'a's from t must be included, but s only has one 'a'.",
      "starterCode": "function minWindow(s, t) {\n  // Your code here\n  \n}",
      "steps": [
        {
          "title": "Understand the Problem",
          "hint": "You need to find the smallest contiguous substring of s that contains all characters of t (with correct frequencies).",
          "approach": "Use a sliding window. Expand the right side to include characters until all of t is covered, then shrink from the left to find the minimum window. You need a way to efficiently check if the current window satisfies the requirement."
        },
        {
          "title": "Brute Force",
          "hint": "Check all substrings of s and find the smallest one containing all characters of t.",
          "approach": "For every pair of indices (i, j) in s, check if s[i..j] contains all characters of t by comparing frequency maps. Track the minimum valid substring.",
          "code": "function minWindow(s, t) {\n  if (t.length > s.length) return '';\n  const tFreq = {};\n  for (const c of t) tFreq[c] = (tFreq[c] || 0) + 1;\n  let minLen = Infinity;\n  let result = '';\n  for (let i = 0; i < s.length; i++) {\n    const windowFreq = {};\n    for (let j = i; j < s.length; j++) {\n      windowFreq[s[j]] = (windowFreq[s[j]] || 0) + 1;\n      let valid = true;\n      for (const c in tFreq) {\n        if ((windowFreq[c] || 0) < tFreq[c]) { valid = false; break; }\n      }\n      if (valid && (j - i + 1) < minLen) {\n        minLen = j - i + 1;\n        result = s.substring(i, j + 1);\n      }\n    }\n  }\n  return result;\n}",
          "complexity": "Time: O(n^2 * m) where n = s.length, m = t.length, Space: O(n + m)"
        },
        {
          "title": "Optimal",
          "hint": "Use a sliding window with two pointers. Track how many characters from t are satisfied using a 'have' counter vs a 'need' counter.",
          "approach": "Build a frequency map for t. Use two pointers (left, right) and a window frequency map. Maintain a 'have' count (number of unique chars fully satisfied) and 'need' count (unique chars needed). Expand right to satisfy, shrink left to minimize. When have === need, the window is valid.",
          "code": "function minWindow(s, t) {\n  if (t.length > s.length) return '';\n  const tFreq = {};\n  for (const c of t) tFreq[c] = (tFreq[c] || 0) + 1;\n  const need = Object.keys(tFreq).length;\n  let have = 0;\n  const windowFreq = {};\n  let left = 0;\n  let minLen = Infinity;\n  let minStart = 0;\n  for (let right = 0; right < s.length; right++) {\n    const c = s[right];\n    windowFreq[c] = (windowFreq[c] || 0) + 1;\n    if (tFreq[c] && windowFreq[c] === tFreq[c]) have++;\n    while (have === need) {\n      if (right - left + 1 < minLen) {\n        minLen = right - left + 1;\n        minStart = left;\n      }\n      const leftChar = s[left];\n      windowFreq[leftChar]--;\n      if (tFreq[leftChar] && windowFreq[leftChar] < tFreq[leftChar]) have--;\n      left++;\n    }\n  }\n  return minLen === Infinity ? '' : s.substring(minStart, minStart + minLen);\n}",
          "complexity": "Time: O(n + m), Space: O(n + m)"
        }
      ],
      "testCases": [
        {
          "args": [
            "ADOBECODEBANC",
            "ABC"
          ],
          "expected": "BANC",
          "description": "Minimum window containing A, B, C"
        },
        {
          "args": [
            "a",
            "a"
          ],
          "expected": "a",
          "description": "Single character match"
        },
        {
          "args": [
            "a",
            "aa"
          ],
          "expected": "",
          "description": "Not enough characters in s"
        }
      ],
      "ankiCards": [
        {
          "id": "minimum-window-substring-have-need",
          "front": "In Minimum Window Substring, how do the 'have' and 'need' counters decide when to expand vs shrink the window?",
          "back": "'need' = number of unique characters in t. 'have' = number of unique characters whose frequency in the window meets or exceeds the required frequency. When have === need, the window contains all required characters. This avoids rechecking the entire frequency map each time."
        },
        {
          "id": "minimum-window-substring-shrink",
          "front": "Minimum Window Substring: When and how do you shrink the window?",
          "back": "Once have === need (valid window), shrink from the left to minimize window size. Decrement frequency of the left character; if it drops below the required frequency for a character in t, decrement 'have'. Continue shrinking while have === need."
        }
      ]
    },
    {
      "id": "best-time-to-buy-and-sell-stock",
      "title": "Best Time to Buy and Sell Stock",
      "difficulty": "Easy",
      "pattern": "sliding-window",
      "leetcodeUrl": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock/",
      "leetcodeNumber": 121,
      "description": "You are given an array `prices` where `prices[i]` is the price of a given stock on the ith day. You want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock. Return the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return 0.\n\nExample 1:\nInput: prices = [7,1,5,3,6,4]\nOutput: 5\nExplanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6 - 1 = 5.\n\nExample 2:\nInput: prices = [7,6,4,3,1]\nOutput: 0\nExplanation: No profitable transaction is possible, so max profit = 0.",
      "starterCode": "function maxProfit(prices) {\n  // Your code here\n  \n}",
      "steps": [
        {
          "title": "Understand the Problem",
          "hint": "You need to find two days i and j where i < j such that prices[j] - prices[i] is maximized.",
          "approach": "We must buy before we sell. We want to find the maximum difference between a later element and an earlier element. Think about tracking the minimum price seen so far and the maximum profit achievable."
        },
        {
          "title": "Brute Force",
          "hint": "Check every pair of buy and sell days.",
          "approach": "Use two nested loops. For each day i (buy), check every future day j (sell) and track the maximum profit.",
          "code": "function maxProfit(prices) {\n  let maxProfit = 0;\n  for (let i = 0; i < prices.length; i++) {\n    for (let j = i + 1; j < prices.length; j++) {\n      const profit = prices[j] - prices[i];\n      maxProfit = Math.max(maxProfit, profit);\n    }\n  }\n  return maxProfit;\n}",
          "complexity": "Time: O(n^2), Space: O(1)"
        },
        {
          "title": "Optimal",
          "hint": "Use a sliding window / one-pass approach. Track the minimum price seen so far.",
          "approach": "Iterate through the array once. Maintain a variable for the minimum price seen so far. At each step, calculate the profit if we sold today (current price minus min price). Track the maximum profit across all days.",
          "code": "function maxProfit(prices) {\n  let minPrice = Infinity;\n  let maxProfit = 0;\n  for (let i = 0; i < prices.length; i++) {\n    minPrice = Math.min(minPrice, prices[i]);\n    maxProfit = Math.max(maxProfit, prices[i] - minPrice);\n  }\n  return maxProfit;\n}",
          "complexity": "Time: O(n), Space: O(1)"
        }
      ],
      "testCases": [
        {
          "args": [
            [
              7,
              1,
              5,
              3,
              6,
              4
            ]
          ],
          "expected": 5,
          "description": "Buy at 1, sell at 6 for profit of 5"
        },
        {
          "args": [
            [
              7,
              6,
              4,
              3,
              1
            ]
          ],
          "expected": 0,
          "description": "Prices only decrease, no profit possible"
        },
        {
          "args": [
            [
              2,
              4,
              1
            ]
          ],
          "expected": 2,
          "description": "Buy at 2, sell at 4 for profit of 2"
        }
      ],
      "ankiCards": [
        {
          "id": "best-time-to-buy-and-sell-stock-approach",
          "front": "Best Time to Buy and Sell Stock: What is the optimal approach and its complexity?",
          "back": "Track the minimum price seen so far while iterating. At each price, compute profit = current - minPrice and update maxProfit. One pass, O(n) time, O(1) space."
        },
        {
          "id": "best-time-to-buy-and-sell-stock-pattern",
          "front": "Best Time to Buy and Sell Stock: Why is this considered a sliding window problem?",
          "back": "You maintain a 'window' defined by the minimum buy price (left pointer) and the current sell price (right pointer). You slide the left pointer forward whenever you find a new minimum price, effectively shrinking/moving the window."
        }
      ]
    },
    {
      "id": "longest-repeating-character-replacement",
      "title": "Longest Repeating Character Replacement",
      "difficulty": "Medium",
      "pattern": "sliding-window",
      "leetcodeUrl": "https://leetcode.com/problems/longest-repeating-character-replacement/",
      "leetcodeNumber": 424,
      "description": "You are given a string `s` and an integer `k`. You can choose any character of the string and change it to any other uppercase English letter. You can perform this operation at most `k` times. Return the length of the longest substring containing the same letter you can get after performing the above operations.\n\nExample 1:\nInput: s = \"ABAB\", k = 2\nOutput: 4\nExplanation: Replace the two 'A's with 'B's or vice versa.\n\nExample 2:\nInput: s = \"AABABBA\", k = 1\nOutput: 4\nExplanation: Replace the one 'B' in the middle with 'A' to get \"AAAAABA\". The substring \"AAAA\" has length 4.",
      "starterCode": "function characterReplacement(s, k) {\n  // Your code here\n  \n}",
      "steps": [
        {
          "title": "Understand the Problem",
          "hint": "You can replace at most k characters in a window. The remaining characters should all be the same. So the window is valid if windowLength - count(most frequent char) <= k.",
          "approach": "Think about a sliding window where you track character frequencies. The key insight is: in any valid window, the number of characters that need to be replaced equals windowLength - maxFrequency. If this exceeds k, shrink the window."
        },
        {
          "title": "Brute Force",
          "hint": "Try all substrings and check if each can be made uniform with at most k replacements.",
          "approach": "For every pair (i, j), count the frequency of each character in s[i..j]. If (j - i + 1) - maxFrequency <= k, the substring is valid. Track the maximum valid length.",
          "code": "function characterReplacement(s, k) {\n  let maxLen = 0;\n  for (let i = 0; i < s.length; i++) {\n    const freq = {};\n    let maxFreq = 0;\n    for (let j = i; j < s.length; j++) {\n      freq[s[j]] = (freq[s[j]] || 0) + 1;\n      maxFreq = Math.max(maxFreq, freq[s[j]]);\n      if ((j - i + 1) - maxFreq <= k) {\n        maxLen = Math.max(maxLen, j - i + 1);\n      }\n    }\n  }\n  return maxLen;\n}",
          "complexity": "Time: O(n^2), Space: O(26) = O(1)"
        },
        {
          "title": "Optimal",
          "hint": "Use a sliding window. Track the count of the most frequent character in the window. Shrink the window from the left when replacements needed exceed k.",
          "approach": "Maintain a frequency map and a variable maxFreq for the highest frequency of any single character in the current window. Expand right. If windowSize - maxFreq > k, shrink from the left. Note: maxFreq does not need to be perfectly accurate when shrinking because we only care about finding longer valid windows.",
          "code": "function characterReplacement(s, k) {\n  const freq = {};\n  let left = 0;\n  let maxFreq = 0;\n  let maxLen = 0;\n  for (let right = 0; right < s.length; right++) {\n    freq[s[right]] = (freq[s[right]] || 0) + 1;\n    maxFreq = Math.max(maxFreq, freq[s[right]]);\n    while ((right - left + 1) - maxFreq > k) {\n      freq[s[left]]--;\n      left++;\n    }\n    maxLen = Math.max(maxLen, right - left + 1);\n  }\n  return maxLen;\n}",
          "complexity": "Time: O(n), Space: O(26) = O(1)"
        }
      ],
      "testCases": [
        {
          "args": [
            "ABAB",
            2
          ],
          "expected": 4,
          "description": "Replace 2 characters to make all same"
        },
        {
          "args": [
            "AABABBA",
            1
          ],
          "expected": 4,
          "description": "Replace 1 B to get AAAA substring"
        },
        {
          "args": [
            "AAAA",
            0
          ],
          "expected": 4,
          "description": "Already all same, no replacements needed"
        }
      ],
      "ankiCards": [
        {
          "id": "longest-repeating-char-replacement-key-insight",
          "front": "Longest Repeating Character Replacement: What is the key validity condition for the sliding window?",
          "back": "A window is valid if windowLength - maxFrequency <= k. The characters that are NOT the most frequent one need to be replaced. If replacements needed exceed k, shrink the window."
        },
        {
          "id": "longest-repeating-char-replacement-maxfreq",
          "front": "Longest Repeating Character Replacement: Why doesn't maxFreq need to decrease when we shrink the window?",
          "back": "We only care about finding LONGER valid windows. A shorter window with a smaller maxFreq cannot produce a better answer than what we already found. So maxFreq acts as a high-water mark, and we only update the result when we find a valid window that is longer."
        }
      ]
    },
    {
      "id": "valid-parentheses",
      "title": "Valid Parentheses",
      "difficulty": "Easy",
      "pattern": "stack",
      "leetcodeUrl": "https://leetcode.com/problems/valid-parentheses/",
      "leetcodeNumber": 20,
      "description": "Given a string `s` containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid. An input string is valid if:\n1. Open brackets must be closed by the same type of brackets.\n2. Open brackets must be closed in the correct order.\n3. Every close bracket has a corresponding open bracket of the same type.\n\nExample 1:\nInput: s = \"()\"\nOutput: true\n\nExample 2:\nInput: s = \"()[]{}\"\nOutput: true\n\nExample 3:\nInput: s = \"(]\"\nOutput: false",
      "starterCode": "function isValid(s) {\n  // Your code here\n  \n}",
      "steps": [
        {
          "title": "Understand the Problem",
          "hint": "Each opening bracket must be closed by the same type in the correct nesting order. Think about what data structure handles 'last opened, first closed'.",
          "approach": "A stack naturally handles nested structures. Push opening brackets onto the stack. When you encounter a closing bracket, check if the top of the stack is the matching opening bracket. If not, or if the stack is empty, the string is invalid."
        },
        {
          "title": "Brute Force",
          "hint": "Repeatedly remove matching adjacent pairs until no more can be removed.",
          "approach": "Keep replacing '()', '[]', '{}' with empty strings until no more replacements can be made. If the string becomes empty, it was valid.",
          "code": "function isValid(s) {\n  let prev = '';\n  while (s !== prev) {\n    prev = s;\n    s = s.replace('()', '').replace('[]', '').replace('{}', '');\n  }\n  return s === '';\n}",
          "complexity": "Time: O(n^2), Space: O(n)"
        },
        {
          "title": "Optimal",
          "hint": "Use a stack. Push opening brackets, pop and compare for closing brackets.",
          "approach": "Create a map of closing -> opening brackets. Iterate through the string. If the character is an opening bracket, push it. If it is a closing bracket, pop from the stack and check if it matches. At the end, the stack should be empty.",
          "code": "function isValid(s) {\n  const stack = [];\n  const map = { ')': '(', ']': '[', '}': '{' };\n  for (const c of s) {\n    if (map[c]) {\n      if (stack.length === 0 || stack.pop() !== map[c]) return false;\n    } else {\n      stack.push(c);\n    }\n  }\n  return stack.length === 0;\n}",
          "complexity": "Time: O(n), Space: O(n)"
        }
      ],
      "testCases": [
        {
          "args": [
            "()"
          ],
          "expected": true,
          "description": "Simple matching pair"
        },
        {
          "args": [
            "()[]{}"
          ],
          "expected": true,
          "description": "Multiple matching pairs"
        },
        {
          "args": [
            "(]"
          ],
          "expected": false,
          "description": "Mismatched bracket types"
        }
      ],
      "ankiCards": [
        {
          "id": "valid-parentheses-approach",
          "front": "Valid Parentheses: What data structure should you use and why?",
          "back": "Use a stack. Opening brackets are pushed on. When a closing bracket appears, pop the stack and check if it matches. The stack enforces LIFO order which matches the nesting requirement. O(n) time, O(n) space."
        },
        {
          "id": "valid-parentheses-edge-cases",
          "front": "Valid Parentheses: What edge cases should you handle?",
          "back": "1. Stack is empty when encountering a closing bracket (no matching opener). 2. Stack is NOT empty at the end (unmatched openers). 3. Empty string is considered valid."
        }
      ]
    },
    {
      "id": "search-in-rotated-sorted-array",
      "title": "Search in Rotated Sorted Array",
      "difficulty": "Medium",
      "pattern": "binary-search",
      "leetcodeUrl": "https://leetcode.com/problems/search-in-rotated-sorted-array/",
      "leetcodeNumber": 33,
      "description": "There is an integer array `nums` sorted in ascending order (with distinct values). Prior to being passed to your function, nums is possibly rotated at an unknown pivot index. Given the array `nums` after the possible rotation and an integer `target`, return the index of `target` if it is in nums, or -1 if it is not.\n\nYou must write an algorithm with O(log n) runtime complexity.\n\nExample 1:\nInput: nums = [4,5,6,7,0,1,2], target = 0\nOutput: 4\n\nExample 2:\nInput: nums = [4,5,6,7,0,1,2], target = 3\nOutput: -1\n\nExample 3:\nInput: nums = [1], target = 0\nOutput: -1",
      "starterCode": "function search(nums, target) {\n  // Your code here\n  \n}",
      "steps": [
        {
          "title": "Understand the Problem",
          "hint": "This is binary search on a rotated array. At each step, one half is guaranteed to be sorted. Use that to decide which half to search.",
          "approach": "With binary search, identify which half (left or right of mid) is sorted by comparing nums[left] with nums[mid]. Then check if the target falls within the sorted half. If yes, search there; otherwise, search the other half."
        },
        {
          "title": "Brute Force",
          "hint": "Linear scan for the target.",
          "approach": "Iterate through the array and return the index when the target is found.",
          "code": "function search(nums, target) {\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] === target) return i;\n  }\n  return -1;\n}",
          "complexity": "Time: O(n), Space: O(1)"
        },
        {
          "title": "Optimal",
          "hint": "Modified binary search: determine which half is sorted and whether the target lies in that half.",
          "approach": "Standard binary search with an extra check. If the left half is sorted (nums[left] <= nums[mid]), check if target is in [left, mid). If yes, go left; else go right. If the right half is sorted, check if target is in (mid, right]. If yes, go right; else go left.",
          "code": "function search(nums, target) {\n  let left = 0;\n  let right = nums.length - 1;\n  while (left <= right) {\n    const mid = Math.floor((left + right) / 2);\n    if (nums[mid] === target) return mid;\n    // Left half is sorted\n    if (nums[left] <= nums[mid]) {\n      if (target >= nums[left] && target < nums[mid]) {\n        right = mid - 1;\n      } else {\n        left = mid + 1;\n      }\n    } else {\n      // Right half is sorted\n      if (target > nums[mid] && target <= nums[right]) {\n        left = mid + 1;\n      } else {\n        right = mid - 1;\n      }\n    }\n  }\n  return -1;\n}",
          "complexity": "Time: O(log n), Space: O(1)"
        }
      ],
      "testCases": [
        {
          "args": [
            [
              4,
              5,
              6,
              7,
              0,
              1,
              2
            ],
            0
          ],
          "expected": 4,
          "description": "Target 0 found at index 4"
        },
        {
          "args": [
            [
              4,
              5,
              6,
              7,
              0,
              1,
              2
            ],
            3
          ],
          "expected": -1,
          "description": "Target 3 not in array"
        },
        {
          "args": [
            [
              1
            ],
            0
          ],
          "expected": -1,
          "description": "Single element, target not found"
        }
      ],
      "ankiCards": [
        {
          "id": "search-rotated-sorted-identify-half",
          "front": "Search in Rotated Sorted Array: How do you identify which half is sorted?",
          "back": "Compare nums[left] with nums[mid]. If nums[left] <= nums[mid], the left half [left, mid] is sorted. Otherwise, the right half [mid, right] is sorted. One half is always guaranteed to be properly sorted in a rotated array."
        },
        {
          "id": "search-rotated-sorted-decision",
          "front": "Search in Rotated Sorted Array: Once you know which half is sorted, how do you decide where to search?",
          "back": "Check if the target falls within the range of the sorted half. If left half is sorted and target is in [nums[left], nums[mid]), search left. Otherwise search right. If right half is sorted and target is in (nums[mid], nums[right]], search right. Otherwise search left."
        }
      ]
    },
    {
      "id": "find-minimum-in-rotated-sorted-array",
      "title": "Find Minimum in Rotated Sorted Array",
      "difficulty": "Medium",
      "pattern": "binary-search",
      "leetcodeUrl": "https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/",
      "leetcodeNumber": 153,
      "description": "Suppose an array of length n sorted in ascending order is rotated between 1 and n times. For example, the array nums = [0,1,2,4,5,6,7] might become [4,5,6,7,0,1,2] if rotated 4 times. Given the sorted rotated array `nums` of unique elements, return the minimum element of this array. You must write an algorithm that runs in O(log n) time.\n\nExample 1:\nInput: nums = [3,4,5,1,2]\nOutput: 1\nExplanation: The original array was [1,2,3,4,5] rotated 3 times.\n\nExample 2:\nInput: nums = [4,5,6,7,0,1,2]\nOutput: 0\n\nExample 3:\nInput: nums = [11,13,15,17]\nOutput: 11\nExplanation: Not rotated (or rotated n times).",
      "starterCode": "function findMin(nums) {\n  // Your code here\n  \n}",
      "steps": [
        {
          "title": "Understand the Problem",
          "hint": "The array has two sorted halves due to rotation. The minimum is at the 'pivot' point where the rotation happened.",
          "approach": "In a rotated sorted array, one half is always sorted. The minimum element is the point where the order breaks. You can use binary search by comparing the mid element with the right element to determine which half contains the minimum."
        },
        {
          "title": "Brute Force",
          "hint": "Scan through the entire array to find the minimum.",
          "approach": "Simply iterate through the array and return the minimum value. This works but does not meet the O(log n) requirement.",
          "code": "function findMin(nums) {\n  let min = nums[0];\n  for (let i = 1; i < nums.length; i++) {\n    min = Math.min(min, nums[i]);\n  }\n  return min;\n}",
          "complexity": "Time: O(n), Space: O(1)"
        },
        {
          "title": "Optimal",
          "hint": "Use binary search. Compare nums[mid] with nums[right] to decide which half to search.",
          "approach": "If nums[mid] > nums[right], the minimum is in the right half (the rotation point is there), so move left = mid + 1. Otherwise, the minimum is at mid or in the left half, so move right = mid. When left === right, that is the minimum.",
          "code": "function findMin(nums) {\n  let left = 0;\n  let right = nums.length - 1;\n  while (left < right) {\n    const mid = Math.floor((left + right) / 2);\n    if (nums[mid] > nums[right]) {\n      left = mid + 1;\n    } else {\n      right = mid;\n    }\n  }\n  return nums[left];\n}",
          "complexity": "Time: O(log n), Space: O(1)"
        }
      ],
      "testCases": [
        {
          "args": [
            [
              3,
              4,
              5,
              1,
              2
            ]
          ],
          "expected": 1,
          "description": "Rotated 3 times, min is 1"
        },
        {
          "args": [
            [
              4,
              5,
              6,
              7,
              0,
              1,
              2
            ]
          ],
          "expected": 0,
          "description": "Rotated 4 times, min is 0"
        },
        {
          "args": [
            [
              11,
              13,
              15,
              17
            ]
          ],
          "expected": 11,
          "description": "Not rotated, min is first element"
        }
      ],
      "ankiCards": [
        {
          "id": "find-min-rotated-sorted-comparison",
          "front": "Find Minimum in Rotated Sorted Array: What comparison drives the binary search?",
          "back": "Compare nums[mid] with nums[right]. If nums[mid] > nums[right], the pivot (minimum) is in the right half, so left = mid + 1. Otherwise, the minimum is at mid or to the left, so right = mid."
        },
        {
          "id": "find-min-rotated-sorted-termination",
          "front": "Find Minimum in Rotated Sorted Array: Why use left < right (not <=) and right = mid (not mid - 1)?",
          "back": "When nums[mid] <= nums[right], mid itself could be the answer, so we cannot skip it (right = mid, not mid - 1). The loop terminates when left === right, converging on the minimum. Using <= would cause an infinite loop."
        }
      ]
    },
    {
      "id": "remove-nth-node-from-end-of-list",
      "title": "Remove Nth Node From End of List",
      "difficulty": "Medium",
      "pattern": "linked-list",
      "leetcodeUrl": "https://leetcode.com/problems/remove-nth-node-from-end-of-list/",
      "leetcodeNumber": 19,
      "description": "Given the head of a linked list, remove the nth node from the end of the list and return its head.\n\nExample 1:\nInput: head = [1,2,3,4,5], n = 2\nOutput: [1,2,3,5]\nExplanation: Remove the 2nd node from the end (node with value 4).\n\nExample 2:\nInput: head = [1], n = 1\nOutput: []\n\nExample 3:\nInput: head = [1,2], n = 1\nOutput: [1]\n\nNote: For testing purposes, linked lists are represented as arrays.",
      "starterCode": "function removeNthFromEnd(head, n) {\n  // head is an array representing a linked list\n  // n is the position from the end to remove\n  // Return the modified array\n  // Your code here\n  \n}",
      "steps": [
        {
          "title": "Understand the Problem",
          "hint": "The nth node from the end is the (length - n + 1)th node from the beginning. Can you find it in one pass?",
          "approach": "Use two pointers separated by n nodes. When the fast pointer reaches the end, the slow pointer is at the node just before the one to remove. This avoids needing to know the length beforehand."
        },
        {
          "title": "Brute Force",
          "hint": "First find the length, then remove the (length - n)th node.",
          "approach": "Pass 1: Count the total number of nodes. Pass 2: Navigate to the (length - n)th node and remove it by adjusting pointers. Two passes total.",
          "code": "// Array-based (for testing):\nfunction removeNthFromEnd(head, n) {\n  const index = head.length - n;\n  return head.filter((_, i) => i !== index);\n}\n\n// Linked list two-pass approach:\n// function removeNthFromEnd(head, n) {\n//   let length = 0;\n//   let curr = head;\n//   while (curr) { length++; curr = curr.next; }\n//   if (length === n) return head.next;\n//   curr = head;\n//   for (let i = 0; i < length - n - 1; i++) curr = curr.next;\n//   curr.next = curr.next.next;\n//   return head;\n// }",
          "complexity": "Time: O(n), Space: O(1)"
        },
        {
          "title": "Optimal",
          "hint": "Use two pointers with a gap of n between them. One pass only.",
          "approach": "Create a dummy node before head. Advance the fast pointer n + 1 steps from dummy. Then move both fast and slow together until fast reaches null. Slow is now right before the target node. Remove it with slow.next = slow.next.next.",
          "code": "// Array-based (for testing):\nfunction removeNthFromEnd(head, n) {\n  const index = head.length - n;\n  const result = [...head];\n  result.splice(index, 1);\n  return result;\n}\n\n// Actual linked list approach (one pass):\n// function removeNthFromEnd(head, n) {\n//   const dummy = new ListNode(0);\n//   dummy.next = head;\n//   let fast = dummy, slow = dummy;\n//   for (let i = 0; i <= n; i++) fast = fast.next;\n//   while (fast !== null) {\n//     fast = fast.next;\n//     slow = slow.next;\n//   }\n//   slow.next = slow.next.next;\n//   return dummy.next;\n// }",
          "complexity": "Time: O(n), Space: O(1)"
        }
      ],
      "testCases": [
        {
          "args": [
            [
              1,
              2,
              3,
              4,
              5
            ],
            2
          ],
          "expected": [
            1,
            2,
            3,
            5
          ],
          "description": "Remove 2nd from end (value 4)"
        },
        {
          "args": [
            [
              1
            ],
            1
          ],
          "expected": [],
          "description": "Remove only element"
        },
        {
          "args": [
            [
              1,
              2
            ],
            1
          ],
          "expected": [
            1
          ],
          "description": "Remove last element"
        }
      ],
      "ankiCards": [
        {
          "id": "remove-nth-from-end-two-pointer-gap",
          "front": "Remove Nth Node From End: How does the two-pointer gap technique work?",
          "back": "Advance fast pointer n+1 steps ahead of slow (both start at dummy). Then move both one step at a time. When fast hits null, slow is right before the node to delete. Remove with slow.next = slow.next.next. One pass, O(1) space."
        },
        {
          "id": "remove-nth-from-end-dummy-node",
          "front": "Remove Nth Node From End: Why use a dummy node?",
          "back": "The dummy node handles the edge case where the head itself needs to be removed (e.g., n equals the list length). Without it, you need special-case logic. With dummy, the algorithm is uniform."
        }
      ]
    },
    {
      "id": "merge-two-sorted-lists",
      "title": "Merge Two Sorted Lists",
      "difficulty": "Easy",
      "pattern": "linked-list",
      "leetcodeUrl": "https://leetcode.com/problems/merge-two-sorted-lists/",
      "leetcodeNumber": 21,
      "description": "You are given the heads of two sorted linked lists list1 and list2. Merge the two lists into one sorted list. The list should be made by splicing together the nodes of the first two lists. Return the head of the merged linked list.\n\nExample 1:\nInput: list1 = [1,2,4], list2 = [1,3,4]\nOutput: [1,1,2,3,4,4]\n\nExample 2:\nInput: list1 = [], list2 = []\nOutput: []\n\nExample 3:\nInput: list1 = [], list2 = [0]\nOutput: [0]\n\nNote: For testing purposes, linked lists are represented as arrays.",
      "starterCode": "function mergeTwoLists(list1, list2) {\n  // list1 and list2 are sorted arrays representing linked lists\n  // Return the merged sorted array\n  // Your code here\n  \n}",
      "steps": [
        {
          "title": "Understand the Problem",
          "hint": "Both lists are already sorted. You need to weave them together maintaining sorted order.",
          "approach": "Compare the heads of both lists. The smaller value goes next in the merged list. Continue until one list is exhausted, then append the rest of the other. A dummy head node simplifies edge cases."
        },
        {
          "title": "Brute Force",
          "hint": "Concatenate both lists and sort the result.",
          "approach": "Combine all elements into a single array/list and then sort. This ignores the fact that the inputs are already sorted.",
          "code": "// Array-based (for testing):\nfunction mergeTwoLists(list1, list2) {\n  return [...list1, ...list2].sort((a, b) => a - b);\n}\n\n// Linked list brute force would similarly collect all values, sort, and rebuild.",
          "complexity": "Time: O((n+m) log(n+m)), Space: O(n+m)"
        },
        {
          "title": "Optimal",
          "hint": "Use two pointers to merge in sorted order, similar to the merge step in merge sort.",
          "approach": "Use two pointers i and j for list1 and list2. Compare elements at both pointers, take the smaller one, and advance that pointer. Continue until one list is exhausted, then append the remaining elements.",
          "code": "// Array-based (for testing):\nfunction mergeTwoLists(list1, list2) {\n  const result = [];\n  let i = 0, j = 0;\n  while (i < list1.length && j < list2.length) {\n    if (list1[i] <= list2[j]) {\n      result.push(list1[i++]);\n    } else {\n      result.push(list2[j++]);\n    }\n  }\n  while (i < list1.length) result.push(list1[i++]);\n  while (j < list2.length) result.push(list2[j++]);\n  return result;\n}\n\n// Actual linked list approach:\n// function mergeTwoLists(l1, l2) {\n//   const dummy = new ListNode(0);\n//   let current = dummy;\n//   while (l1 && l2) {\n//     if (l1.val <= l2.val) {\n//       current.next = l1;\n//       l1 = l1.next;\n//     } else {\n//       current.next = l2;\n//       l2 = l2.next;\n//     }\n//     current = current.next;\n//   }\n//   current.next = l1 || l2;\n//   return dummy.next;\n// }",
          "complexity": "Time: O(n + m), Space: O(1) for linked list, O(n + m) for array version"
        }
      ],
      "testCases": [
        {
          "args": [
            [
              1,
              2,
              4
            ],
            [
              1,
              3,
              4
            ]
          ],
          "expected": [
            1,
            1,
            2,
            3,
            4,
            4
          ],
          "description": "Merge two 3-element sorted lists"
        },
        {
          "args": [
            [],
            []
          ],
          "expected": [],
          "description": "Both lists empty"
        },
        {
          "args": [
            [],
            [
              0
            ]
          ],
          "expected": [
            0
          ],
          "description": "One list empty, other has one element"
        }
      ],
      "ankiCards": [
        {
          "id": "merge-two-sorted-lists-dummy-node",
          "front": "Merge Two Sorted Lists: Why use a dummy node?",
          "back": "A dummy node simplifies the code by avoiding special-case logic for initializing the head of the merged list. You always append to dummy's chain, then return dummy.next as the actual head."
        },
        {
          "id": "merge-two-sorted-lists-technique",
          "front": "Merge Two Sorted Lists: What is the core technique?",
          "back": "Two-pointer merge (same as merge sort's merge step). Compare heads of both lists, take the smaller, advance that pointer. When one list is exhausted, append the other. O(n + m) time, O(1) space."
        }
      ]
    },
    {
      "id": "merge-k-sorted-lists",
      "title": "Merge K Sorted Lists",
      "difficulty": "Hard",
      "pattern": "linked-list",
      "leetcodeUrl": "https://leetcode.com/problems/merge-k-sorted-lists/",
      "leetcodeNumber": 23,
      "description": "You are given an array of k linked-lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it.\n\nExample 1:\nInput: lists = [[1,4,5],[1,3,4],[2,6]]\nOutput: [1,1,2,3,4,4,5,6]\n\nExample 2:\nInput: lists = []\nOutput: []\n\nExample 3:\nInput: lists = [[]]\nOutput: []\n\nNote: For testing purposes, linked lists are represented as arrays.",
      "starterCode": "function mergeKLists(lists) {\n  // lists is an array of sorted arrays\n  // Return a single merged sorted array\n  // Your code here\n  \n}",
      "steps": [
        {
          "title": "Understand the Problem",
          "hint": "This is an extension of merging two sorted lists. With k lists, you need an efficient way to repeatedly find the smallest element across all list heads.",
          "approach": "Several approaches exist: (1) Merge lists one by one. (2) Use a min-heap/priority queue to always pick the smallest head. (3) Divide and conquer - merge pairs of lists, reducing k by half each round."
        },
        {
          "title": "Brute Force",
          "hint": "Collect all values, sort them, and create the result.",
          "approach": "Iterate through all lists, collect every value into a single array, sort it, and return the sorted array.",
          "code": "// Array-based (for testing):\nfunction mergeKLists(lists) {\n  const all = [];\n  for (const list of lists) {\n    for (const val of list) {\n      all.push(val);\n    }\n  }\n  return all.sort((a, b) => a - b);\n}",
          "complexity": "Time: O(N log N) where N is total number of elements, Space: O(N)"
        },
        {
          "title": "Optimal",
          "hint": "Use divide and conquer: repeatedly merge pairs of lists until one remains.",
          "approach": "Pair up the k lists and merge each pair (using the merge two sorted lists technique). This gives k/2 lists. Repeat until one list remains. Each level processes all N elements, and there are log(k) levels.",
          "code": "// Array-based (for testing):\nfunction mergeKLists(lists) {\n  if (lists.length === 0) return [];\n  \n  function mergeTwoLists(l1, l2) {\n    const result = [];\n    let i = 0, j = 0;\n    while (i < l1.length && j < l2.length) {\n      if (l1[i] <= l2[j]) result.push(l1[i++]);\n      else result.push(l2[j++]);\n    }\n    while (i < l1.length) result.push(l1[i++]);\n    while (j < l2.length) result.push(l2[j++]);\n    return result;\n  }\n  \n  while (lists.length > 1) {\n    const merged = [];\n    for (let i = 0; i < lists.length; i += 2) {\n      const l1 = lists[i];\n      const l2 = i + 1 < lists.length ? lists[i + 1] : [];\n      merged.push(mergeTwoLists(l1, l2));\n    }\n    lists = merged;\n  }\n  return lists[0];\n}\n\n// Actual linked list divide and conquer:\n// function mergeKLists(lists) {\n//   if (lists.length === 0) return null;\n//   while (lists.length > 1) {\n//     const merged = [];\n//     for (let i = 0; i < lists.length; i += 2) {\n//       const l1 = lists[i];\n//       const l2 = i + 1 < lists.length ? lists[i + 1] : null;\n//       merged.push(mergeTwoLists(l1, l2));\n//     }\n//     lists = merged;\n//   }\n//   return lists[0];\n// }",
          "complexity": "Time: O(N log k) where N is total elements and k is number of lists, Space: O(1) for linked list version"
        }
      ],
      "testCases": [
        {
          "args": [
            [
              [
                1,
                4,
                5
              ],
              [
                1,
                3,
                4
              ],
              [
                2,
                6
              ]
            ]
          ],
          "expected": [
            1,
            1,
            2,
            3,
            4,
            4,
            5,
            6
          ],
          "description": "Merge 3 sorted lists"
        },
        {
          "args": [
            []
          ],
          "expected": [],
          "description": "Empty input"
        },
        {
          "args": [
            [
              []
            ]
          ],
          "expected": [],
          "description": "Single empty list"
        }
      ],
      "ankiCards": [
        {
          "id": "merge-k-sorted-lists-divide-conquer",
          "front": "Merge K Sorted Lists: How does the divide and conquer approach work?",
          "back": "Pair up k lists and merge each pair using merge-two-sorted-lists. This halves the number of lists each round. After log(k) rounds, one merged list remains. O(N log k) time where N = total elements."
        },
        {
          "id": "merge-k-sorted-lists-approaches",
          "front": "Merge K Sorted Lists: What are the three main approaches and their complexities?",
          "back": "1) Brute force: collect all, sort - O(N log N). 2) Min-heap/priority queue: always extract the smallest head - O(N log k). 3) Divide and conquer: merge pairs repeatedly - O(N log k). Approaches 2 and 3 are optimal."
        }
      ]
    },
    {
      "id": "linked-list-cycle",
      "title": "Linked List Cycle",
      "difficulty": "Easy",
      "pattern": "linked-list",
      "leetcodeUrl": "https://leetcode.com/problems/linked-list-cycle/",
      "leetcodeNumber": 141,
      "description": "Given head, the head of a linked list, determine if the linked list has a cycle in it. There is a cycle if some node in the list can be reached again by continuously following the next pointer. Return true if there is a cycle, false otherwise.\n\nExample 1:\nInput: head = [3,2,0,-4], pos = 1\nOutput: true\nExplanation: There is a cycle where the tail connects to the 1st node (0-indexed).\n\nExample 2:\nInput: head = [1,2], pos = 0\nOutput: true\n\nExample 3:\nInput: head = [1], pos = -1\nOutput: false\nExplanation: There is no cycle.\n\nNote: For testing purposes, we represent cycles as [array, pos] where pos is the index the tail connects to. pos = -1 means no cycle. The function receives the array and pos, and returns a boolean.",
      "starterCode": "function hasCycle(head, pos) {\n  // head is an array, pos is the index where the tail connects to (-1 if no cycle)\n  // Return true if there is a cycle, false otherwise\n  // Your code here\n  \n}",
      "steps": [
        {
          "title": "Understand the Problem",
          "hint": "A cycle means if you keep following pointers, you will visit the same node again. How can you detect if you are revisiting nodes?",
          "approach": "Two approaches: (1) Use a Set to track visited nodes - if you see a node again, there is a cycle. (2) Use Floyd's tortoise and hare algorithm - two pointers moving at different speeds will meet if there is a cycle."
        },
        {
          "title": "Brute Force",
          "hint": "Use a hash set to track visited nodes.",
          "approach": "Traverse the list. At each node, check if it is in the visited set. If yes, there is a cycle. If you reach null, there is no cycle.",
          "code": "// Array-based (for testing):\nfunction hasCycle(head, pos) {\n  return pos >= 0;\n}\n\n// Linked list hash set approach:\n// function hasCycle(head) {\n//   const visited = new Set();\n//   let current = head;\n//   while (current !== null) {\n//     if (visited.has(current)) return true;\n//     visited.add(current);\n//     current = current.next;\n//   }\n//   return false;\n// }",
          "complexity": "Time: O(n), Space: O(n)"
        },
        {
          "title": "Optimal",
          "hint": "Floyd's cycle detection: use slow and fast pointers. If they meet, there is a cycle.",
          "approach": "Initialize slow and fast to head. Move slow by 1 step, fast by 2 steps. If there is a cycle, fast will eventually catch up to slow (they will meet). If fast reaches null, there is no cycle.",
          "code": "// Array-based (for testing):\nfunction hasCycle(head, pos) {\n  return pos >= 0;\n}\n\n// Actual linked list Floyd's algorithm:\n// function hasCycle(head) {\n//   let slow = head, fast = head;\n//   while (fast !== null && fast.next !== null) {\n//     slow = slow.next;\n//     fast = fast.next.next;\n//     if (slow === fast) return true;\n//   }\n//   return false;\n// }",
          "complexity": "Time: O(n), Space: O(1)"
        }
      ],
      "testCases": [
        {
          "args": [
            [
              3,
              2,
              0,
              -4
            ],
            1
          ],
          "expected": true,
          "description": "Cycle: tail connects to index 1"
        },
        {
          "args": [
            [
              1,
              2
            ],
            0
          ],
          "expected": true,
          "description": "Cycle: tail connects to index 0"
        },
        {
          "args": [
            [
              1
            ],
            -1
          ],
          "expected": false,
          "description": "No cycle, single node"
        }
      ],
      "ankiCards": [
        {
          "id": "linked-list-cycle-floyds",
          "front": "In Linked List Cycle detection, how does Floyd's tortoise-and-hare algorithm guarantee a cycle is found?",
          "back": "Use two pointers: slow moves 1 step, fast moves 2 steps. If there is a cycle, fast will eventually lap slow and they will meet. If fast reaches null, there is no cycle. O(n) time, O(1) space."
        },
        {
          "id": "linked-list-cycle-why-meet",
          "front": "Linked List Cycle: Why are the slow and fast pointers guaranteed to meet in a cycle?",
          "back": "Once both are in the cycle, the gap between them decreases by 1 each step (fast gains 1 step per iteration). So they must eventually meet. The meeting takes at most one full loop around the cycle."
        }
      ]
    },
    {
      "id": "reorder-list",
      "title": "Reorder List",
      "difficulty": "Medium",
      "pattern": "linked-list",
      "leetcodeUrl": "https://leetcode.com/problems/reorder-list/",
      "leetcodeNumber": 143,
      "description": "You are given the head of a singly linked-list: L0 -> L1 -> ... -> Ln-1 -> Ln. Reorder the list to be: L0 -> Ln -> L1 -> Ln-1 -> L2 -> Ln-2 -> ...\n\nYou may not modify the values in the list's nodes. Only nodes themselves may be changed.\n\nExample 1:\nInput: head = [1,2,3,4]\nOutput: [1,4,2,3]\n\nExample 2:\nInput: head = [1,2,3,4,5]\nOutput: [1,5,2,4,3]\n\nNote: For testing purposes, linked lists are represented as arrays.",
      "starterCode": "function reorderList(head) {\n  // head is an array representing a linked list\n  // Reorder in-place and return the result\n  // Your code here\n  \n}",
      "steps": [
        {
          "title": "Understand the Problem",
          "hint": "You interleave from the front and back: first, last, second, second-last, etc.",
          "approach": "Three steps: (1) Find the middle of the list using slow/fast pointers. (2) Reverse the second half. (3) Merge the two halves by alternating nodes."
        },
        {
          "title": "Brute Force",
          "hint": "Store all nodes in an array, then reorder using two pointers from both ends.",
          "approach": "Traverse the list and store all nodes in an array. Use two pointers (front and back) to rebuild the list in the required order.",
          "code": "// Array-based (for testing):\nfunction reorderList(head) {\n  if (head.length <= 2) return head;\n  const result = [];\n  let left = 0, right = head.length - 1;\n  while (left <= right) {\n    result.push(head[left]);\n    if (left !== right) result.push(head[right]);\n    left++;\n    right--;\n  }\n  return result;\n}",
          "complexity": "Time: O(n), Space: O(n)"
        },
        {
          "title": "Optimal",
          "hint": "Find middle, reverse second half, merge two halves. All in-place with O(1) space.",
          "approach": "1) Use slow/fast pointers to find the middle. 2) Reverse the second half of the list starting from slow.next. 3) Merge the first and reversed second half by alternating nodes.",
          "code": "// Array-based (for testing):\nfunction reorderList(head) {\n  if (head.length <= 2) return head;\n  const result = [];\n  let left = 0, right = head.length - 1;\n  while (left <= right) {\n    result.push(head[left]);\n    if (left !== right) result.push(head[right]);\n    left++;\n    right--;\n  }\n  return result;\n}\n\n// Actual linked list approach:\n// function reorderList(head) {\n//   if (!head || !head.next) return;\n//   // Find middle\n//   let slow = head, fast = head;\n//   while (fast.next && fast.next.next) {\n//     slow = slow.next;\n//     fast = fast.next.next;\n//   }\n//   // Reverse second half\n//   let prev = null, curr = slow.next;\n//   slow.next = null;\n//   while (curr) {\n//     const next = curr.next;\n//     curr.next = prev;\n//     prev = curr;\n//     curr = next;\n//   }\n//   // Merge two halves\n//   let first = head, second = prev;\n//   while (second) {\n//     const tmp1 = first.next, tmp2 = second.next;\n//     first.next = second;\n//     second.next = tmp1;\n//     first = tmp1;\n//     second = tmp2;\n//   }\n// }",
          "complexity": "Time: O(n), Space: O(1)"
        }
      ],
      "testCases": [
        {
          "args": [
            [
              1,
              2,
              3,
              4
            ]
          ],
          "expected": [
            1,
            4,
            2,
            3
          ],
          "description": "Even-length list reorder"
        },
        {
          "args": [
            [
              1,
              2,
              3,
              4,
              5
            ]
          ],
          "expected": [
            1,
            5,
            2,
            4,
            3
          ],
          "description": "Odd-length list reorder"
        },
        {
          "args": [
            [
              1
            ]
          ],
          "expected": [
            1
          ],
          "description": "Single element, no reorder needed"
        }
      ],
      "ankiCards": [
        {
          "id": "reorder-list-three-steps",
          "front": "Reorder List: What are the three key steps?",
          "back": "1) Find the middle using slow/fast pointers. 2) Reverse the second half of the list. 3) Merge the first half and reversed second half by alternating nodes. O(n) time, O(1) space."
        },
        {
          "id": "reorder-list-pattern",
          "front": "Reorder List: Why is this problem a combination of multiple linked list techniques?",
          "back": "It requires three fundamental linked list operations: finding the middle (slow/fast pointers), reversing a list (three-pointer technique), and merging two lists (interleaving). Mastering this problem means mastering all three sub-problems."
        }
      ]
    },
    {
      "id": "reverse-linked-list",
      "title": "Reverse Linked List",
      "difficulty": "Easy",
      "pattern": "linked-list",
      "leetcodeUrl": "https://leetcode.com/problems/reverse-linked-list/",
      "leetcodeNumber": 206,
      "description": "Given the head of a singly linked list, reverse the list, and return the reversed list.\n\nExample 1:\nInput: head = [1,2,3,4,5]\nOutput: [5,4,3,2,1]\n\nExample 2:\nInput: head = [1,2]\nOutput: [2,1]\n\nExample 3:\nInput: head = []\nOutput: []\n\nNote: For testing purposes, linked lists are represented as arrays.",
      "starterCode": "function reverseList(head) {\n  // head is an array representing a linked list\n  // Return the reversed array\n  // Your code here\n  \n}",
      "steps": [
        {
          "title": "Understand the Problem",
          "hint": "You need to reverse the direction of all pointers in a linked list. Each node's next should point to the previous node instead.",
          "approach": "Think about three pointers: prev, current, and next. At each step, save the next node, reverse the current node's pointer to point to prev, then advance prev and current."
        },
        {
          "title": "Brute Force",
          "hint": "Store all values in an array, then create a new reversed list.",
          "approach": "Traverse the list and collect all values in an array. Then reverse the array (or build a new list from the array in reverse order). This uses extra space.",
          "code": "// Array-based (for testing):\nfunction reverseList(head) {\n  return head.slice().reverse();\n}\n\n// Actual linked list approach (brute force):\n// function reverseList(head) {\n//   const values = [];\n//   let current = head;\n//   while (current) {\n//     values.push(current.val);\n//     current = current.next;\n//   }\n//   let newHead = null;\n//   for (const val of values) {\n//     const node = new ListNode(val);\n//     node.next = newHead;\n//     newHead = node;\n//   }\n//   return newHead;\n// }",
          "complexity": "Time: O(n), Space: O(n)"
        },
        {
          "title": "Optimal",
          "hint": "Reverse pointers in-place using three pointers: prev, current, next.",
          "approach": "Initialize prev = null, current = head. While current is not null: save next = current.next, set current.next = prev, move prev = current, move current = next. At the end, prev is the new head.",
          "code": "// Array-based (for testing):\nfunction reverseList(head) {\n  let left = 0, right = head.length - 1;\n  while (left < right) {\n    [head[left], head[right]] = [head[right], head[left]];\n    left++;\n    right--;\n  }\n  return head;\n}\n\n// Actual linked list approach (optimal):\n// function reverseList(head) {\n//   let prev = null;\n//   let current = head;\n//   while (current !== null) {\n//     const next = current.next;\n//     current.next = prev;\n//     prev = current;\n//     current = next;\n//   }\n//   return prev;\n// }",
          "complexity": "Time: O(n), Space: O(1)"
        }
      ],
      "testCases": [
        {
          "args": [
            [
              1,
              2,
              3,
              4,
              5
            ]
          ],
          "expected": [
            5,
            4,
            3,
            2,
            1
          ],
          "description": "Reverse a 5-element list"
        },
        {
          "args": [
            [
              1,
              2
            ]
          ],
          "expected": [
            2,
            1
          ],
          "description": "Reverse a 2-element list"
        },
        {
          "args": [
            []
          ],
          "expected": [],
          "description": "Empty list returns empty"
        }
      ],
      "ankiCards": [
        {
          "id": "reverse-linked-list-three-pointers",
          "front": "Reverse Linked List: What three pointers do you need and how do they move?",
          "back": "prev (starts null), current (starts at head), next (temp). Each iteration: next = current.next, current.next = prev, prev = current, current = next. When current is null, prev is the new head. O(n) time, O(1) space."
        },
        {
          "id": "reverse-linked-list-recursive",
          "front": "Reverse Linked List: How would you solve this recursively?",
          "back": "Base case: if head is null or head.next is null, return head. Recursive: newHead = reverseList(head.next). Then head.next.next = head; head.next = null. Return newHead. O(n) time, O(n) space for call stack."
        }
      ]
    },
    {
      "id": "validate-binary-search-tree",
      "title": "Validate Binary Search Tree",
      "difficulty": "Medium",
      "pattern": "trees",
      "leetcodeUrl": "https://leetcode.com/problems/validate-binary-search-tree/",
      "leetcodeNumber": 98,
      "description": "Given the `root` of a binary tree, determine if it is a valid binary search tree (BST).\n\nA **valid BST** is defined as follows:\n- The left subtree of a node contains only nodes with keys **less than** the node's key.\n- The right subtree of a node contains only nodes with keys **greater than** the node's key.\n- Both the left and right subtrees must also be binary search trees.\n\n**Example 1:**\n```\nInput: root = [2,1,3]\nOutput: true\n```\n\n**Example 2:**\n```\nInput: root = [5,1,4,null,null,3,6]\nOutput: false\nExplanation: The root node's value is 5 but its right child's value is 4.\n```\n\n**Constraints:**\n- The number of nodes in the tree is in the range [1, 10^4].\n- -2^31 <= Node.val <= 2^31 - 1",
      "starterCode": "function isValidBST(root) {\n  // Tree represented as array: [2,1,3]\n  // Your code here\n  \n}",
      "steps": [
        {
          "title": "Understand the Problem",
          "hint": "A common mistake is only checking if node.left < node and node.right > node. You must ensure ALL nodes in the left subtree are less, and ALL in the right are greater.",
          "approach": "Each node must fall within a valid range. The root can be any value. Going left, the upper bound becomes the parent's value. Going right, the lower bound becomes the parent's value."
        },
        {
          "title": "DFS with Range Validation",
          "hint": "Pass a valid range (min, max) down the recursion. Each node must be within its range.",
          "approach": "Start with range (-Infinity, Infinity). For each node, check if its value is within (min, max). Going left: update max to node.val. Going right: update min to node.val.",
          "code": "function isValidBST(root) {\n  function validate(node, min, max) {\n    if (node === null) return true;\n    \n    if (node.val <= min || node.val >= max) {\n      return false;\n    }\n    \n    return validate(node.left, min, node.val) &&\n           validate(node.right, node.val, max);\n  }\n  \n  return validate(root, -Infinity, Infinity);\n}",
          "complexity": "Time: O(n), Space: O(h)"
        },
        {
          "title": "Inorder Traversal Approach",
          "hint": "An inorder traversal of a valid BST produces values in strictly increasing order.",
          "approach": "Perform an inorder traversal (left, root, right). Track the previously visited value. If the current value is not strictly greater than the previous, it is not a valid BST.",
          "code": "function isValidBST(root) {\n  let prev = -Infinity;\n  \n  function inorder(node) {\n    if (node === null) return true;\n    \n    if (!inorder(node.left)) return false;\n    \n    if (node.val <= prev) return false;\n    prev = node.val;\n    \n    return inorder(node.right);\n  }\n  \n  return inorder(root);\n}",
          "complexity": "Time: O(n), Space: O(h)"
        }
      ],
      "testCases": [
        {
          "args": [
            [
              2,
              1,
              3
            ]
          ],
          "expected": true,
          "description": "Valid BST"
        },
        {
          "args": [
            [
              5,
              1,
              4,
              null,
              null,
              3,
              6
            ]
          ],
          "expected": false,
          "description": "Invalid -- right child 4 < root 5"
        },
        {
          "args": [
            [
              5,
              4,
              6,
              null,
              null,
              3,
              7
            ]
          ],
          "expected": false,
          "description": "Invalid -- 3 is in right subtree but less than root 5"
        }
      ],
      "ankiCards": [
        {
          "id": "validate-bst-range",
          "front": "Validate BST: Why is checking only direct children insufficient?",
          "back": "A node's value must satisfy constraints from ALL ancestors, not just its parent.\n\nExample: [5,1,6,null,null,3,7] -- 3 is a valid left child of 6, but invalid because it is in root 5's right subtree (must be > 5).\n\nSolution: Pass a (min, max) range down the recursion, narrowing it at each level."
        },
        {
          "id": "validate-bst-inorder",
          "front": "Validate BST: How does the inorder traversal approach work?",
          "back": "Key property: Inorder traversal of a valid BST yields strictly increasing values.\n\n1. Do inorder traversal (left -> root -> right)\n2. Track the previous value\n3. If current <= previous, return false\n\nThis is often simpler to implement and reason about.\nTime: O(n), Space: O(h)"
        }
      ]
    },
    {
      "id": "same-tree",
      "title": "Same Tree",
      "difficulty": "Easy",
      "pattern": "trees",
      "leetcodeUrl": "https://leetcode.com/problems/same-tree/",
      "leetcodeNumber": 100,
      "description": "Given the roots of two binary trees `p` and `q`, write a function to check if they are the same or not.\n\nTwo binary trees are considered the same if they are structurally identical, and the nodes have the same value.\n\n**Example 1:**\n```\nInput: p = [1,2,3], q = [1,2,3]\nOutput: true\n```\n\n**Example 2:**\n```\nInput: p = [1,2], q = [1,null,2]\nOutput: false\n```\n\n**Example 3:**\n```\nInput: p = [1,2,1], q = [1,1,2]\nOutput: false\n```\n\n**Constraints:**\n- The number of nodes in both trees is in the range [0, 100].\n- -10^4 <= Node.val <= 10^4",
      "starterCode": "function isSameTree(p, q) {\n  // Trees represented as arrays: [1,2,3]\n  // Your code here\n  \n}",
      "steps": [
        {
          "title": "Understand the Problem",
          "hint": "Two trees are the same if they have the exact same structure AND the same values at every corresponding position.",
          "approach": "We need to check both structure (same shape) and values (same data at each node). Think recursively: two trees are the same if their roots are equal and their left and right subtrees are the same."
        },
        {
          "title": "Recursive DFS Approach",
          "hint": "Compare nodes pairwise: both null = same, one null = different, different values = different, else recurse on children.",
          "approach": "Use recursive comparison. Base cases: both null (return true), one null (return false), different values (return false). Recursive case: check left subtrees AND right subtrees.",
          "code": "function isSameTree(p, q) {\n  // Both null\n  if (p === null && q === null) return true;\n  \n  // One null, other not\n  if (p === null || q === null) return false;\n  \n  // Different values\n  if (p.val !== q.val) return false;\n  \n  // Recursively check subtrees\n  return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n}",
          "complexity": "Time: O(n), Space: O(h) where h is tree height"
        },
        {
          "title": "Iterative BFS Approach",
          "hint": "Use two queues in parallel, comparing nodes at each step.",
          "approach": "Use BFS with two queues, one for each tree. Dequeue from both simultaneously and compare. If any mismatch is found, return false. If both queues empty together, return true.",
          "code": "function isSameTree(p, q) {\n  const queue = [[p, q]];\n  \n  while (queue.length > 0) {\n    const [node1, node2] = queue.shift();\n    \n    if (node1 === null && node2 === null) continue;\n    if (node1 === null || node2 === null) return false;\n    if (node1.val !== node2.val) return false;\n    \n    queue.push([node1.left, node2.left]);\n    queue.push([node1.right, node2.right]);\n  }\n  \n  return true;\n}",
          "complexity": "Time: O(n), Space: O(n)"
        }
      ],
      "testCases": [
        {
          "args": [
            [
              1,
              2,
              3
            ],
            [
              1,
              2,
              3
            ]
          ],
          "expected": true,
          "description": "Identical trees"
        },
        {
          "args": [
            [
              1,
              2
            ],
            [
              1,
              null,
              2
            ]
          ],
          "expected": false,
          "description": "Different structure"
        },
        {
          "args": [
            [
              1,
              2,
              1
            ],
            [
              1,
              1,
              2
            ]
          ],
          "expected": false,
          "description": "Different values"
        }
      ],
      "ankiCards": [
        {
          "id": "same-tree-pattern",
          "front": "Same Tree: What are the base cases for the recursive approach?",
          "back": "Three base cases:\n1. Both nodes null -> return true (same empty subtree)\n2. One node null, other not -> return false (different structure)\n3. Values differ -> return false\n\nRecursive case: return isSameTree(p.left, q.left) && isSameTree(p.right, q.right)\n\nTime: O(n), Space: O(h)"
        },
        {
          "id": "same-tree-comparison",
          "front": "Same Tree: What makes two trees 'the same'?",
          "back": "Two conditions must hold simultaneously:\n1. Structural identity: same shape/topology\n2. Value identity: corresponding nodes have equal values\n\nBoth conditions are checked at every node via recursion or iteration."
        }
      ]
    },
    {
      "id": "binary-tree-level-order-traversal",
      "title": "Binary Tree Level Order Traversal",
      "difficulty": "Medium",
      "pattern": "trees",
      "leetcodeUrl": "https://leetcode.com/problems/binary-tree-level-order-traversal/",
      "leetcodeNumber": 102,
      "description": "Given the `root` of a binary tree, return the level order traversal of its nodes' values (i.e., from left to right, level by level).\n\n**Example 1:**\n```\nInput: root = [3,9,20,null,null,15,7]\nOutput: [[3],[9,20],[15,7]]\n```\n\n**Example 2:**\n```\nInput: root = [1]\nOutput: [[1]]\n```\n\n**Example 3:**\n```\nInput: root = []\nOutput: []\n```\n\n**Constraints:**\n- The number of nodes in the tree is in the range [0, 2000].\n- -1000 <= Node.val <= 1000",
      "starterCode": "function levelOrder(root) {\n  // Tree represented as array: [3,9,20,null,null,15,7]\n  // Your code here\n  \n}",
      "steps": [
        {
          "title": "Understand the Problem",
          "hint": "Level order traversal processes all nodes at depth 0, then all at depth 1, then depth 2, etc. This is BFS.",
          "approach": "We need to group nodes by their level. BFS with a queue naturally processes nodes level by level. The key is knowing when one level ends and the next begins."
        },
        {
          "title": "BFS with Queue (Standard Approach)",
          "hint": "Use a queue. At each step, record the queue size -- that is the number of nodes at the current level. Process exactly that many nodes.",
          "approach": "Use BFS. Before processing each level, capture queue.length (the number of nodes at that level). Process exactly that many nodes, adding their children. Collect values for each level into a sub-array.",
          "code": "function levelOrder(root) {\n  if (root === null) return [];\n  \n  const result = [];\n  const queue = [root];\n  \n  while (queue.length > 0) {\n    const levelSize = queue.length;\n    const level = [];\n    \n    for (let i = 0; i < levelSize; i++) {\n      const node = queue.shift();\n      level.push(node.val);\n      \n      if (node.left) queue.push(node.left);\n      if (node.right) queue.push(node.right);\n    }\n    \n    result.push(level);\n  }\n  \n  return result;\n}",
          "complexity": "Time: O(n), Space: O(n)"
        },
        {
          "title": "DFS with Level Tracking",
          "hint": "You can also use DFS -- pass the current depth and use it as the index into the result array.",
          "approach": "Use recursive DFS, passing the current depth. If result[depth] does not exist, create a new sub-array. Push the current node's value into result[depth]. Recurse on children with depth + 1.",
          "code": "function levelOrder(root) {\n  const result = [];\n  \n  function dfs(node, depth) {\n    if (node === null) return;\n    \n    if (result.length === depth) {\n      result.push([]);\n    }\n    \n    result[depth].push(node.val);\n    dfs(node.left, depth + 1);\n    dfs(node.right, depth + 1);\n  }\n  \n  dfs(root, 0);\n  return result;\n}",
          "complexity": "Time: O(n), Space: O(n)"
        }
      ],
      "testCases": [
        {
          "args": [
            [
              3,
              9,
              20,
              null,
              null,
              15,
              7
            ]
          ],
          "expected": [
            [
              3
            ],
            [
              9,
              20
            ],
            [
              15,
              7
            ]
          ],
          "description": "Standard tree with 3 levels"
        },
        {
          "args": [
            [
              1
            ]
          ],
          "expected": [
            [
              1
            ]
          ],
          "description": "Single node"
        },
        {
          "args": [
            []
          ],
          "expected": [],
          "description": "Empty tree"
        }
      ],
      "ankiCards": [
        {
          "id": "level-order-traversal-technique",
          "front": "Binary Tree Level Order Traversal: How do you separate levels in BFS?",
          "back": "Before each BFS iteration, capture levelSize = queue.length.\n\nProcess exactly levelSize nodes (they are all from the current level). Their children form the next level.\n\nfor (let i = 0; i < levelSize; i++) {\n  const node = queue.shift();\n  // process node, enqueue children\n}\n\nTime: O(n), Space: O(n)"
        },
        {
          "id": "level-order-traversal-dfs-alt",
          "front": "Binary Tree Level Order Traversal: Can you use DFS instead of BFS?",
          "back": "Yes! Use DFS with a depth parameter:\n\nfunction dfs(node, depth) {\n  if (!node) return;\n  if (result.length === depth) result.push([]);\n  result[depth].push(node.val);\n  dfs(node.left, depth + 1);\n  dfs(node.right, depth + 1);\n}\n\nSame time/space complexity. BFS is more intuitive for level-order."
        }
      ]
    },
    {
      "id": "maximum-depth-of-binary-tree",
      "title": "Maximum Depth of Binary Tree",
      "difficulty": "Easy",
      "pattern": "trees",
      "leetcodeUrl": "https://leetcode.com/problems/maximum-depth-of-binary-tree/",
      "leetcodeNumber": 104,
      "description": "Given the `root` of a binary tree, return its maximum depth.\n\nA binary tree's **maximum depth** is the number of nodes along the longest path from the root node down to the farthest leaf node.\n\n**Example 1:**\n```\nInput: root = [3,9,20,null,null,15,7]\nOutput: 3\n```\n\n**Example 2:**\n```\nInput: root = [1,null,2]\nOutput: 2\n```\n\n**Constraints:**\n- The number of nodes in the tree is in the range [0, 10^4].\n- -100 <= Node.val <= 100",
      "starterCode": "function maxDepth(root) {\n  // Tree represented as array: [3,9,20,null,null,15,7]\n  // Your code here\n  \n}",
      "steps": [
        {
          "title": "Understand the Problem",
          "hint": "Maximum depth is the length of the longest root-to-leaf path. An empty tree has depth 0, a single node has depth 1.",
          "approach": "Think recursively: the depth of a tree = 1 + max(depth of left subtree, depth of right subtree). The base case is a null node which has depth 0."
        },
        {
          "title": "Recursive DFS Approach",
          "hint": "The maximum depth of a node is 1 plus the maximum of its children's depths.",
          "approach": "Use recursive DFS. At each node, compute the depth of left and right subtrees, return 1 + max of both. Null nodes return 0.",
          "code": "function maxDepth(root) {\n  if (root === null) return 0;\n  \n  const leftDepth = maxDepth(root.left);\n  const rightDepth = maxDepth(root.right);\n  \n  return 1 + Math.max(leftDepth, rightDepth);\n}",
          "complexity": "Time: O(n), Space: O(h) where h is tree height"
        },
        {
          "title": "Iterative BFS Approach",
          "hint": "Use level-order traversal and count the number of levels.",
          "approach": "Use BFS with a queue. Process nodes level by level. Each time you finish a level, increment the depth counter. The final counter value is the maximum depth.",
          "code": "function maxDepth(root) {\n  if (root === null) return 0;\n  \n  const queue = [root];\n  let depth = 0;\n  \n  while (queue.length > 0) {\n    const levelSize = queue.length;\n    depth++;\n    \n    for (let i = 0; i < levelSize; i++) {\n      const node = queue.shift();\n      if (node.left) queue.push(node.left);\n      if (node.right) queue.push(node.right);\n    }\n  }\n  \n  return depth;\n}",
          "complexity": "Time: O(n), Space: O(n) for the queue"
        }
      ],
      "testCases": [
        {
          "args": [
            [
              3,
              9,
              20,
              null,
              null,
              15,
              7
            ]
          ],
          "expected": 3,
          "description": "Tree with depth 3"
        },
        {
          "args": [
            [
              1,
              null,
              2
            ]
          ],
          "expected": 2,
          "description": "Right-skewed tree"
        },
        {
          "args": [
            []
          ],
          "expected": 0,
          "description": "Empty tree"
        }
      ],
      "ankiCards": [
        {
          "id": "maximum-depth-binary-tree-recursion",
          "front": "Maximum Depth of Binary Tree: What is the recursive formula?",
          "back": "maxDepth(node) = 1 + max(maxDepth(node.left), maxDepth(node.right))\nBase case: maxDepth(null) = 0\n\nThis is a classic post-order DFS traversal.\n\nTime: O(n), Space: O(h)"
        },
        {
          "id": "maximum-depth-binary-tree-bfs",
          "front": "Maximum Depth of Binary Tree: How to solve with BFS?",
          "back": "Use level-order traversal with a queue:\n1. Process all nodes at current level\n2. Increment depth counter after each level\n3. Return final depth count\n\nThe number of complete levels processed = max depth.\n\nTime: O(n), Space: O(n)"
        }
      ]
    },
    {
      "id": "construct-binary-tree-from-preorder-and-inorder-traversal",
      "title": "Construct Binary Tree from Preorder and Inorder Traversal",
      "difficulty": "Medium",
      "pattern": "trees",
      "leetcodeUrl": "https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/",
      "leetcodeNumber": 105,
      "description": "Given two integer arrays `preorder` and `inorder` where `preorder` is the preorder traversal of a binary tree and `inorder` is the inorder traversal of the same tree, construct and return the binary tree.\n\n**Example 1:**\n```\nInput: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]\nOutput: [3,9,20,null,null,15,7]\n```\n\n**Example 2:**\n```\nInput: preorder = [1], inorder = [1]\nOutput: [1]\n```\n\n**Constraints:**\n- 1 <= preorder.length <= 3000\n- inorder.length == preorder.length\n- -3000 <= preorder[i], inorder[i] <= 3000\n- preorder and inorder consist of unique values.\n- Each value of inorder also appears in preorder.\n- preorder is guaranteed to be the preorder traversal of the tree.\n- inorder is guaranteed to be the inorder traversal of the tree.",
      "starterCode": "function buildTree(preorder, inorder) {\n  // Returns tree as array representation\n  // Your code here\n  \n}",
      "steps": [
        {
          "title": "Understand the Problem",
          "hint": "Preorder: root first, then left subtree, then right subtree. Inorder: left subtree, then root, then right subtree. The first element of preorder is always the root.",
          "approach": "Key insight: preorder[0] is the root. Find this root in inorder -- everything to its left is the left subtree, everything to its right is the right subtree. Recurse on these subarrays."
        },
        {
          "title": "Recursive with Array Slicing",
          "hint": "Find root in inorder to determine left and right subtree boundaries, then recurse.",
          "approach": "1. Take first element of preorder as root. 2. Find its index in inorder. 3. Elements left of that index in inorder = left subtree. 4. Elements right = right subtree. 5. Split preorder accordingly and recurse.",
          "code": "function buildTree(preorder, inorder) {\n  if (preorder.length === 0) return null;\n  \n  const rootVal = preorder[0];\n  const root = { val: rootVal, left: null, right: null };\n  \n  const mid = inorder.indexOf(rootVal);\n  \n  root.left = buildTree(\n    preorder.slice(1, mid + 1),\n    inorder.slice(0, mid)\n  );\n  root.right = buildTree(\n    preorder.slice(mid + 1),\n    inorder.slice(mid + 1)\n  );\n  \n  return root;\n}",
          "complexity": "Time: O(n^2) due to indexOf and slice, Space: O(n^2) for sliced arrays"
        },
        {
          "title": "Optimal with HashMap and Indices",
          "hint": "Avoid repeated indexOf calls by building a hashmap of inorder values to indices. Use index pointers instead of slicing arrays.",
          "approach": "Pre-build a map: inorder value -> index. Use a preorder index pointer and inorder range [left, right] to avoid copying arrays. The preorder index advances globally as we construct each node.",
          "code": "function buildTree(preorder, inorder) {\n  const inorderMap = new Map();\n  inorder.forEach((val, idx) => inorderMap.set(val, idx));\n  \n  let preIdx = 0;\n  \n  function build(left, right) {\n    if (left > right) return null;\n    \n    const rootVal = preorder[preIdx++];\n    const root = { val: rootVal, left: null, right: null };\n    \n    const mid = inorderMap.get(rootVal);\n    \n    root.left = build(left, mid - 1);\n    root.right = build(mid + 1, right);\n    \n    return root;\n  }\n  \n  return build(0, inorder.length - 1);\n}",
          "complexity": "Time: O(n), Space: O(n) for the hashmap"
        }
      ],
      "testCases": [
        {
          "args": [
            [
              3,
              9,
              20,
              15,
              7
            ],
            [
              9,
              3,
              15,
              20,
              7
            ]
          ],
          "expected": [
            3,
            9,
            20,
            null,
            null,
            15,
            7
          ],
          "description": "Standard tree construction"
        },
        {
          "args": [
            [
              1
            ],
            [
              1
            ]
          ],
          "expected": [
            1
          ],
          "description": "Single node tree"
        },
        {
          "args": [
            [
              1,
              2
            ],
            [
              2,
              1
            ]
          ],
          "expected": [
            1,
            2
          ],
          "description": "Two node tree (left child only)"
        }
      ],
      "ankiCards": [
        {
          "id": "construct-tree-preorder-inorder-insight",
          "front": "Construct Tree from Preorder & Inorder: What is the key insight?",
          "back": "1. preorder[0] is always the root\n2. Find root's position in inorder (index mid)\n3. inorder[0..mid-1] = left subtree\n4. inorder[mid+1..end] = right subtree\n5. preorder[1..mid] = left subtree preorder\n6. preorder[mid+1..end] = right subtree preorder\n\nRecurse on these subarrays to build the tree."
        },
        {
          "id": "construct-tree-preorder-inorder-optimize",
          "front": "Construct Tree from Preorder & Inorder: How to optimize from O(n^2) to O(n)?",
          "back": "Two optimizations:\n1. Use a HashMap (value -> index) for inorder to avoid O(n) indexOf calls\n2. Use index pointers (left, right) instead of array slicing\n\nThe preorder index increments globally because preorder naturally processes root -> left -> right.\n\nTime: O(n), Space: O(n)"
        }
      ]
    },
    {
      "id": "binary-tree-maximum-path-sum",
      "title": "Binary Tree Maximum Path Sum",
      "difficulty": "Hard",
      "pattern": "trees",
      "leetcodeUrl": "https://leetcode.com/problems/binary-tree-maximum-path-sum/",
      "leetcodeNumber": 124,
      "description": "A **path** in a binary tree is a sequence of nodes where each pair of adjacent nodes in the sequence has an edge connecting them. A node can only appear in the sequence **at most once**. Note that the path does not need to pass through the root.\n\nThe **path sum** of a path is the sum of the node's values in the path.\n\nGiven the `root` of a binary tree, return the maximum path sum of any **non-empty** path.\n\n**Example 1:**\n```\nInput: root = [1,2,3]\nOutput: 6\nExplanation: The optimal path is 2 -> 1 -> 3 with a path sum of 2 + 1 + 3 = 6.\n```\n\n**Example 2:**\n```\nInput: root = [-10,9,20,null,null,15,7]\nOutput: 42\nExplanation: The optimal path is 15 -> 20 -> 7 with a path sum of 15 + 20 + 7 = 42.\n```\n\n**Constraints:**\n- The number of nodes in the tree is in the range [1, 3 * 10^4].\n- -1000 <= Node.val <= 1000",
      "starterCode": "function maxPathSum(root) {\n  // Tree represented as array: [1,2,3]\n  // Your code here\n  \n}",
      "steps": [
        {
          "title": "Understand the Problem",
          "hint": "A path can start and end at any node (not necessarily root or leaf). It can go up through a parent and down into another child -- forming an 'arch'. But each node can only be visited once.",
          "approach": "Key distinction: a path through a node can either (a) extend upward to the parent (can use at most one child branch), or (b) use the node as the 'turning point' (use both children). We need to track both cases."
        },
        {
          "title": "Understanding the Two Values",
          "hint": "For each node, compute two things: (1) the max gain if we extend the path to the parent, and (2) the max path sum using this node as the highest point.",
          "approach": "At each node: (1) 'gain' = node.val + max(leftGain, rightGain, 0) -- the max contribution this subtree can make to a path going upward. (2) 'local max path' = node.val + max(leftGain, 0) + max(rightGain, 0) -- the max path using this node as the arch/peak. Update global max with the local max path.",
          "code": "// At each node we compute:\n// leftGain = max gain from left subtree (0 if negative)\n// rightGain = max gain from right subtree (0 if negative)\n// localMax = node.val + leftGain + rightGain (path through this node)\n// Return to parent: node.val + max(leftGain, rightGain)",
          "complexity": "Understanding the dual nature is the key"
        },
        {
          "title": "Complete DFS Solution",
          "hint": "Use post-order DFS. Each call returns the max gain to the parent. Update a global max with the local path sum at each node.",
          "approach": "Post-order DFS: process children first, then current node. Each call returns max(0, node.val + best child gain) to the parent. Meanwhile, update the global maximum with node.val + leftGain + rightGain (the arch path through this node).",
          "code": "function maxPathSum(root) {\n  let maxSum = -Infinity;\n  \n  function dfs(node) {\n    if (node === null) return 0;\n    \n    // Get max gain from each subtree (ignore negative gains)\n    const leftGain = Math.max(0, dfs(node.left));\n    const rightGain = Math.max(0, dfs(node.right));\n    \n    // Path through this node as the highest point\n    const localMax = node.val + leftGain + rightGain;\n    maxSum = Math.max(maxSum, localMax);\n    \n    // Return max gain extending to parent (can only go one direction)\n    return node.val + Math.max(leftGain, rightGain);\n  }\n  \n  dfs(root);\n  return maxSum;\n}",
          "complexity": "Time: O(n), Space: O(h)"
        }
      ],
      "testCases": [
        {
          "args": [
            [
              1,
              2,
              3
            ]
          ],
          "expected": 6,
          "description": "Path through root: 2 -> 1 -> 3"
        },
        {
          "args": [
            [
              -10,
              9,
              20,
              null,
              null,
              15,
              7
            ]
          ],
          "expected": 42,
          "description": "Path not through root: 15 -> 20 -> 7"
        },
        {
          "args": [
            [
              -3
            ]
          ],
          "expected": -3,
          "description": "Single negative node -- must include at least one node"
        }
      ],
      "ankiCards": [
        {
          "id": "binary-tree-max-path-sum-dual-value",
          "front": "Binary Tree Maximum Path Sum: What two values does each DFS call consider?",
          "back": "At each node:\n1. Gain to parent: node.val + max(leftGain, rightGain) -- can only extend one direction upward\n2. Local max path: node.val + leftGain + rightGain -- the 'arch' path using this node as the peak\n\nReturn #1 to the parent. Update global max with #2.\n\nNegative gains are clamped to 0 (skip that subtree)."
        },
        {
          "id": "binary-tree-max-path-sum-negative",
          "front": "Binary Tree Maximum Path Sum: How do you handle negative values?",
          "back": "Two key rules:\n1. Clamp child gains to 0: max(0, childGain). If a subtree has negative total gain, do not include it.\n2. Initialize maxSum = -Infinity (not 0), because we must include at least one node and all values might be negative.\n\nA single negative node is a valid path."
        }
      ]
    },
    {
      "id": "invert-binary-tree",
      "title": "Invert Binary Tree",
      "difficulty": "Easy",
      "pattern": "trees",
      "leetcodeUrl": "https://leetcode.com/problems/invert-binary-tree/",
      "leetcodeNumber": 226,
      "description": "Given the `root` of a binary tree, invert the tree, and return its root.\n\nInverting a binary tree means swapping every left child with its corresponding right child.\n\n**Example 1:**\n```\nInput: root = [4,2,7,1,3,6,9]\nOutput: [4,7,2,9,6,3,1]\n```\n\n**Example 2:**\n```\nInput: root = [2,1,3]\nOutput: [2,3,1]\n```\n\n**Example 3:**\n```\nInput: root = []\nOutput: []\n```\n\n**Constraints:**\n- The number of nodes in the tree is in the range [0, 100].\n- -100 <= Node.val <= 100",
      "starterCode": "function invertTree(root) {\n  // Tree represented as array: [4,2,7,1,3,6,9]\n  // Your code here\n  \n}",
      "steps": [
        {
          "title": "Understand the Problem",
          "hint": "Inverting a tree means every left child becomes the right child and vice versa, at every level of the tree.",
          "approach": "Think of it recursively: to invert a tree, swap the left and right children of the root, then recursively invert the left subtree and right subtree. The base case is when the node is null."
        },
        {
          "title": "Recursive DFS Approach",
          "hint": "At each node, swap its left and right children, then recurse on both subtrees.",
          "approach": "Use a simple recursive DFS. For each node, swap left and right children, then call invertTree on both children. This naturally processes every node in the tree.",
          "code": "function invertTree(root) {\n  if (root === null) return null;\n  \n  // Swap left and right children\n  const temp = root.left;\n  root.left = root.right;\n  root.right = temp;\n  \n  // Recursively invert subtrees\n  invertTree(root.left);\n  invertTree(root.right);\n  \n  return root;\n}",
          "complexity": "Time: O(n), Space: O(h) where h is tree height (recursion stack)"
        },
        {
          "title": "Iterative BFS Approach",
          "hint": "Use a queue to process nodes level by level, swapping children at each node.",
          "approach": "Use BFS with a queue. For each node dequeued, swap its children, then enqueue both children (if they exist). This processes every node exactly once.",
          "code": "function invertTree(root) {\n  if (root === null) return null;\n  \n  const queue = [root];\n  \n  while (queue.length > 0) {\n    const node = queue.shift();\n    \n    // Swap children\n    const temp = node.left;\n    node.left = node.right;\n    node.right = temp;\n    \n    if (node.left) queue.push(node.left);\n    if (node.right) queue.push(node.right);\n  }\n  \n  return root;\n}",
          "complexity": "Time: O(n), Space: O(n) for the queue"
        }
      ],
      "testCases": [
        {
          "args": [
            [
              4,
              2,
              7,
              1,
              3,
              6,
              9
            ]
          ],
          "expected": [
            4,
            7,
            2,
            9,
            6,
            3,
            1
          ],
          "description": "Complete binary tree"
        },
        {
          "args": [
            [
              2,
              1,
              3
            ]
          ],
          "expected": [
            2,
            3,
            1
          ],
          "description": "Simple 3-node tree"
        },
        {
          "args": [
            []
          ],
          "expected": [],
          "description": "Empty tree"
        }
      ],
      "ankiCards": [
        {
          "id": "invert-binary-tree-pattern",
          "front": "Invert Binary Tree: What is the recursive approach?",
          "back": "Recursively swap left and right children at each node.\n\n1. Base case: if node is null, return null\n2. Swap node.left and node.right\n3. Recursively invert left subtree\n4. Recursively invert right subtree\n5. Return root\n\nTime: O(n), Space: O(h) where h = tree height"
        },
        {
          "id": "invert-binary-tree-iterative",
          "front": "Invert Binary Tree: How can you solve it iteratively?",
          "back": "Use BFS with a queue:\n\n1. Push root into queue\n2. While queue not empty: dequeue node, swap its children, enqueue non-null children\n3. Return root\n\nTime: O(n), Space: O(n) for the queue"
        }
      ]
    },
    {
      "id": "kth-smallest-element-in-a-bst",
      "title": "Kth Smallest Element in a BST",
      "difficulty": "Medium",
      "pattern": "trees",
      "leetcodeUrl": "https://leetcode.com/problems/kth-smallest-element-in-a-bst/",
      "leetcodeNumber": 230,
      "description": "Given the `root` of a binary search tree, and an integer `k`, return the `kth` smallest value (1-indexed) of all the values of the nodes in the tree.\n\n**Example 1:**\n```\nInput: root = [3,1,4,null,2], k = 1\nOutput: 1\n```\n\n**Example 2:**\n```\nInput: root = [5,3,6,2,4,null,null,1], k = 3\nOutput: 3\n```\n\n**Constraints:**\n- The number of nodes in the tree is n.\n- 1 <= k <= n <= 10^4\n- 0 <= Node.val <= 10^4",
      "starterCode": "function kthSmallest(root, k) {\n  // Tree represented as array: [3,1,4,null,2]\n  // Your code here\n  \n}",
      "steps": [
        {
          "title": "Understand the Problem",
          "hint": "In a BST, inorder traversal visits nodes in ascending order. The kth node visited in inorder is the kth smallest.",
          "approach": "The key insight is that inorder traversal of a BST gives sorted order. So the kth smallest element is the kth element in the inorder traversal."
        },
        {
          "title": "Inorder Traversal (Collect All)",
          "hint": "Do a full inorder traversal, collect values in an array, and return the (k-1)th element.",
          "approach": "Simple approach: collect all values via inorder traversal into an array, then return array[k-1]. This visits all nodes even if k is small.",
          "code": "function kthSmallest(root, k) {\n  const values = [];\n  \n  function inorder(node) {\n    if (node === null) return;\n    inorder(node.left);\n    values.push(node.val);\n    inorder(node.right);\n  }\n  \n  inorder(root);\n  return values[k - 1];\n}",
          "complexity": "Time: O(n), Space: O(n)"
        },
        {
          "title": "Optimal: Early Termination Inorder",
          "hint": "You do not need to traverse the entire tree. Stop as soon as you have visited k nodes.",
          "approach": "Use inorder traversal with a counter. Decrement k each time you visit a node (at the 'inorder' position). When k reaches 0, you have found the answer. This avoids visiting unnecessary nodes.",
          "code": "function kthSmallest(root, k) {\n  let count = 0;\n  let result = null;\n  \n  function inorder(node) {\n    if (node === null || result !== null) return;\n    \n    inorder(node.left);\n    \n    count++;\n    if (count === k) {\n      result = node.val;\n      return;\n    }\n    \n    inorder(node.right);\n  }\n  \n  inorder(root);\n  return result;\n}",
          "complexity": "Time: O(h + k), Space: O(h) where h is tree height"
        }
      ],
      "testCases": [
        {
          "args": [
            [
              3,
              1,
              4,
              null,
              2
            ],
            1
          ],
          "expected": 1,
          "description": "Smallest element (k=1)"
        },
        {
          "args": [
            [
              5,
              3,
              6,
              2,
              4,
              null,
              null,
              1
            ],
            3
          ],
          "expected": 3,
          "description": "3rd smallest in larger tree"
        },
        {
          "args": [
            [
              1,
              null,
              2
            ],
            2
          ],
          "expected": 2,
          "description": "Right-skewed tree, k=2"
        }
      ],
      "ankiCards": [
        {
          "id": "kth-smallest-bst-key-insight",
          "front": "Kth Smallest in BST: Why does inorder traversal work?",
          "back": "BST Property: left < root < right.\n\nInorder traversal visits: left -> root -> right.\n\nThis means nodes are visited in ascending sorted order. The kth node visited is the kth smallest.\n\nTime: O(h + k) with early termination, Space: O(h)"
        },
        {
          "id": "kth-smallest-bst-optimization",
          "front": "Kth Smallest in BST: How to optimize for repeated queries?",
          "back": "Augment each node with a 'leftCount' field storing the number of nodes in its left subtree.\n\nTo find kth smallest:\n- If leftCount + 1 == k: current node is answer\n- If leftCount + 1 > k: search left subtree\n- If leftCount + 1 < k: search right with k = k - leftCount - 1\n\nThis gives O(h) per query without full traversal."
        }
      ]
    },
    {
      "id": "lowest-common-ancestor-of-a-bst",
      "title": "Lowest Common Ancestor of a BST",
      "difficulty": "Medium",
      "pattern": "trees",
      "leetcodeUrl": "https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/",
      "leetcodeNumber": 235,
      "description": "Given a binary search tree (BST), find the lowest common ancestor (LCA) node of two given nodes in the BST.\n\nThe lowest common ancestor is defined as the lowest node in the tree that has both `p` and `q` as descendants (where we allow a node to be a descendant of itself).\n\n**Example 1:**\n```\nInput: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8\nOutput: 6\nExplanation: The LCA of nodes 2 and 8 is 6.\n```\n\n**Example 2:**\n```\nInput: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4\nOutput: 2\nExplanation: The LCA of nodes 2 and 4 is 2, since a node can be a descendant of itself.\n```\n\n**Constraints:**\n- The number of nodes in the tree is in the range [2, 10^5].\n- -10^9 <= Node.val <= 10^9\n- All Node.val are unique.\n- p != q\n- p and q will exist in the BST.",
      "starterCode": "function lowestCommonAncestor(root, p, q) {\n  // Tree represented as array: [6,2,8,0,4,7,9,null,null,3,5]\n  // p and q are node values\n  // Your code here\n  \n}",
      "steps": [
        {
          "title": "Understand the Problem",
          "hint": "In a BST, all values in the left subtree are less than the root, and all values in the right subtree are greater. Use this property to find the LCA.",
          "approach": "The LCA is the node where p and q 'split' -- one goes to the left subtree and the other to the right. If both are smaller, LCA is in the left subtree. If both are larger, LCA is in the right subtree. Otherwise, the current node is the LCA."
        },
        {
          "title": "Recursive BST Approach",
          "hint": "Use the BST property: compare p and q with the current node to decide which direction to go.",
          "approach": "If both p and q are less than current node, recurse left. If both are greater, recurse right. Otherwise, the current node is the LCA (the split point).",
          "code": "function lowestCommonAncestor(root, p, q) {\n  if (p < root.val && q < root.val) {\n    return lowestCommonAncestor(root.left, p, q);\n  }\n  if (p > root.val && q > root.val) {\n    return lowestCommonAncestor(root.right, p, q);\n  }\n  return root.val;\n}",
          "complexity": "Time: O(h), Space: O(h) where h is tree height"
        },
        {
          "title": "Iterative Approach (Optimal)",
          "hint": "Eliminate recursion by using a simple while loop -- follow the same logic iteratively.",
          "approach": "Start at root. While both p and q are on the same side (both less or both greater), move to that side. When they split (or one equals current), current node is the LCA.",
          "code": "function lowestCommonAncestor(root, p, q) {\n  let current = root;\n  \n  while (current) {\n    if (p < current.val && q < current.val) {\n      current = current.left;\n    } else if (p > current.val && q > current.val) {\n      current = current.right;\n    } else {\n      return current.val;\n    }\n  }\n}",
          "complexity": "Time: O(h), Space: O(1)"
        }
      ],
      "testCases": [
        {
          "args": [
            [
              6,
              2,
              8,
              0,
              4,
              7,
              9,
              null,
              null,
              3,
              5
            ],
            2,
            8
          ],
          "expected": 6,
          "description": "LCA is root -- nodes split left and right"
        },
        {
          "args": [
            [
              6,
              2,
              8,
              0,
              4,
              7,
              9,
              null,
              null,
              3,
              5
            ],
            2,
            4
          ],
          "expected": 2,
          "description": "LCA is one of the nodes itself"
        },
        {
          "args": [
            [
              2,
              1
            ],
            2,
            1
          ],
          "expected": 2,
          "description": "Small tree -- root is LCA"
        }
      ],
      "ankiCards": [
        {
          "id": "lca-bst-key-insight",
          "front": "Lowest Common Ancestor of a BST: What is the key insight?",
          "back": "Use the BST ordering property:\n- If both p and q < node: LCA is in left subtree\n- If both p and q > node: LCA is in right subtree\n- Otherwise (split point): current node IS the LCA\n\nThis is the 'split point' -- where p and q diverge to different subtrees.\n\nTime: O(h), Space: O(1) iterative"
        },
        {
          "id": "lca-bst-vs-binary-tree",
          "front": "LCA in BST vs LCA in general Binary Tree: What is the difference?",
          "back": "BST LCA: Use ordering property to go left or right. O(h) time, O(1) space.\n\nGeneral Binary Tree LCA: Must check both subtrees recursively. If both subtrees return non-null, current node is LCA. O(n) time, O(h) space.\n\nThe BST property makes it much simpler and faster."
        }
      ]
    },
    {
      "id": "serialize-and-deserialize-binary-tree",
      "title": "Serialize and Deserialize Binary Tree",
      "difficulty": "Hard",
      "pattern": "trees",
      "leetcodeUrl": "https://leetcode.com/problems/serialize-and-deserialize-binary-tree/",
      "leetcodeNumber": 297,
      "description": "Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored or transmitted and reconstructed later.\n\nDesign an algorithm to serialize and deserialize a binary tree. There is no restriction on how your serialization/deserialization algorithm should work. You just need to ensure that a binary tree can be serialized to a string and this string can be deserialized to the original tree structure.\n\n**Example 1:**\n```\nInput: root = [1,2,3,null,null,4,5]\nOutput: [1,2,3,null,null,4,5]\n```\n\n**Example 2:**\n```\nInput: root = []\nOutput: []\n```\n\n**Constraints:**\n- The number of nodes in the tree is in the range [0, 10^4].\n- -1000 <= Node.val <= 1000",
      "starterCode": "function serialize(root) {\n  // Tree represented as array: [1,2,3,null,null,4,5]\n  // Convert tree to a string\n  // Your code here\n  \n}\n\nfunction deserialize(data) {\n  // Convert string back to tree (array representation)\n  // Your code here\n  \n}",
      "steps": [
        {
          "title": "Understand the Problem",
          "hint": "We need two functions: serialize (tree -> string) and deserialize (string -> tree). The format is our choice, but deserialize(serialize(tree)) must reconstruct the original tree.",
          "approach": "We can use preorder traversal with null markers. Preorder (root, left, right) is easy to serialize because the root comes first. We use a special marker (like 'N') for null nodes so we know the exact tree structure."
        },
        {
          "title": "Preorder DFS Approach",
          "hint": "Serialize using preorder DFS with null markers. Deserialize by reading tokens in preorder.",
          "approach": "Serialize: Preorder DFS, append node values separated by commas. Use 'N' for null. Deserialize: Split by comma, use an index pointer, read tokens in preorder order to reconstruct the tree.",
          "code": "function serialize(root) {\n  const result = [];\n  \n  function dfs(node) {\n    if (node === null) {\n      result.push('N');\n      return;\n    }\n    result.push(String(node.val));\n    dfs(node.left);\n    dfs(node.right);\n  }\n  \n  dfs(root);\n  return result.join(',');\n}\n\nfunction deserialize(data) {\n  const tokens = data.split(',');\n  let idx = 0;\n  \n  function dfs() {\n    if (tokens[idx] === 'N') {\n      idx++;\n      return null;\n    }\n    \n    const node = { val: parseInt(tokens[idx]), left: null, right: null };\n    idx++;\n    node.left = dfs();\n    node.right = dfs();\n    return node;\n  }\n  \n  return dfs();\n}",
          "complexity": "Time: O(n), Space: O(n)"
        },
        {
          "title": "BFS Level-Order Approach",
          "hint": "Use BFS to serialize level by level (including nulls). Deserialize by reading level by level with a queue.",
          "approach": "Serialize: BFS, enqueue children (including null). Output each node's value or 'N'. Deserialize: Read first token as root, use a queue. For each node in queue, read next two tokens as its left and right children.",
          "code": "function serialize(root) {\n  if (root === null) return 'N';\n  \n  const result = [];\n  const queue = [root];\n  \n  while (queue.length > 0) {\n    const node = queue.shift();\n    if (node === null) {\n      result.push('N');\n    } else {\n      result.push(String(node.val));\n      queue.push(node.left);\n      queue.push(node.right);\n    }\n  }\n  \n  return result.join(',');\n}\n\nfunction deserialize(data) {\n  const tokens = data.split(',');\n  if (tokens[0] === 'N') return null;\n  \n  const root = { val: parseInt(tokens[0]), left: null, right: null };\n  const queue = [root];\n  let i = 1;\n  \n  while (queue.length > 0) {\n    const node = queue.shift();\n    \n    if (tokens[i] !== 'N') {\n      node.left = { val: parseInt(tokens[i]), left: null, right: null };\n      queue.push(node.left);\n    }\n    i++;\n    \n    if (tokens[i] !== 'N') {\n      node.right = { val: parseInt(tokens[i]), left: null, right: null };\n      queue.push(node.right);\n    }\n    i++;\n  }\n  \n  return root;\n}",
          "complexity": "Time: O(n), Space: O(n)"
        }
      ],
      "testCases": [
        {
          "args": [
            [
              1,
              2,
              3,
              null,
              null,
              4,
              5
            ]
          ],
          "expected": [
            1,
            2,
            3,
            null,
            null,
            4,
            5
          ],
          "description": "Standard tree -- serialize then deserialize"
        },
        {
          "args": [
            []
          ],
          "expected": [],
          "description": "Empty tree"
        },
        {
          "args": [
            [
              1
            ]
          ],
          "expected": [
            1
          ],
          "description": "Single node"
        }
      ],
      "ankiCards": [
        {
          "id": "serialize-deserialize-tree-approach",
          "front": "Serialize/Deserialize Binary Tree: What are the two main approaches?",
          "back": "1. Preorder DFS: Serialize as 'val,left,right' with 'N' for nulls. Deserialize by reading tokens in preorder with a global index pointer.\n\n2. BFS Level-Order: Serialize level by level with nulls. Deserialize by reading pairs of children for each node in a queue.\n\nBoth: Time O(n), Space O(n)"
        },
        {
          "id": "serialize-deserialize-tree-null-markers",
          "front": "Serialize/Deserialize Binary Tree: Why are null markers essential?",
          "back": "Without null markers, we cannot distinguish different tree structures that have the same values.\n\nExample: [1,2,null] vs [1,null,2] both have values {1,2} but different structures.\n\nNull markers encode the exact structure by marking where children are absent, allowing perfect reconstruction."
        }
      ]
    },
    {
      "id": "subtree-of-another-tree",
      "title": "Subtree of Another Tree",
      "difficulty": "Easy",
      "pattern": "trees",
      "leetcodeUrl": "https://leetcode.com/problems/subtree-of-another-tree/",
      "leetcodeNumber": 572,
      "description": "Given the roots of two binary trees `root` and `subRoot`, return `true` if there is a subtree of `root` with the same structure and node values of `subRoot` and `false` otherwise.\n\nA subtree of a binary tree `tree` is a tree that consists of a node in `tree` and all of this node's descendants.\n\n**Example 1:**\n```\nInput: root = [3,4,5,1,2], subRoot = [4,1,2]\nOutput: true\n```\n\n**Example 2:**\n```\nInput: root = [3,4,5,1,2,null,null,null,null,0], subRoot = [4,1,2]\nOutput: false\n```\n\n**Constraints:**\n- The number of nodes in the root tree is in the range [1, 2000].\n- The number of nodes in the subRoot tree is in the range [1, 1000].\n- -10^4 <= root.val <= 10^4\n- -10^4 <= subRoot.val <= 10^4",
      "starterCode": "function isSubtree(root, subRoot) {\n  // Trees represented as arrays: [3,4,5,1,2]\n  // Your code here\n  \n}",
      "steps": [
        {
          "title": "Understand the Problem",
          "hint": "A subtree must match exactly from some node downward -- same structure and same values. It is not just 'contained within' but an exact match of an entire subtree.",
          "approach": "For each node in the main tree, check if the subtree rooted at that node is identical to subRoot. We can reuse the 'Same Tree' logic as a helper."
        },
        {
          "title": "Brute Force: Check Every Node",
          "hint": "Traverse the main tree. At each node, check if the tree rooted there is the same as subRoot.",
          "approach": "Use DFS to traverse every node in root. At each node, use the isSameTree function to check if the subtree matches subRoot. If any match is found, return true.",
          "code": "function isSubtree(root, subRoot) {\n  if (root === null) return false;\n  \n  if (isSameTree(root, subRoot)) return true;\n  \n  return isSubtree(root.left, subRoot) || isSubtree(root.right, subRoot);\n}\n\nfunction isSameTree(p, q) {\n  if (p === null && q === null) return true;\n  if (p === null || q === null) return false;\n  if (p.val !== q.val) return false;\n  return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n}",
          "complexity": "Time: O(m * n) where m and n are tree sizes, Space: O(h) for recursion stack"
        },
        {
          "title": "Optimal: Tree Serialization",
          "hint": "Serialize both trees to strings and check if subRoot's string is a substring of root's string.",
          "approach": "Serialize both trees using preorder traversal with special markers for null nodes and node boundaries. Then check if the serialized subRoot is a substring of the serialized root. Use delimiters to prevent false matches (e.g., '12' matching '2').",
          "code": "function isSubtree(root, subRoot) {\n  function serialize(node) {\n    if (node === null) return '#';\n    return ',' + node.val + serialize(node.left) + serialize(node.right);\n  }\n  \n  const rootStr = serialize(root);\n  const subStr = serialize(subRoot);\n  \n  return rootStr.includes(subStr);\n}",
          "complexity": "Time: O(m + n) with KMP substring matching, Space: O(m + n) for serialized strings"
        }
      ],
      "testCases": [
        {
          "args": [
            [
              3,
              4,
              5,
              1,
              2
            ],
            [
              4,
              1,
              2
            ]
          ],
          "expected": true,
          "description": "subRoot is a subtree"
        },
        {
          "args": [
            [
              3,
              4,
              5,
              1,
              2,
              null,
              null,
              null,
              null,
              0
            ],
            [
              4,
              1,
              2
            ]
          ],
          "expected": false,
          "description": "subRoot has extra node -- not exact match"
        },
        {
          "args": [
            [
              1,
              1
            ],
            [
              1
            ]
          ],
          "expected": true,
          "description": "Single node subtree matches leaf"
        }
      ],
      "ankiCards": [
        {
          "id": "subtree-another-tree-approach",
          "front": "Subtree of Another Tree: What are the two main approaches?",
          "back": "1. Brute Force: For each node in root, run isSameTree(node, subRoot). Time: O(m*n)\n\n2. Serialization: Serialize both trees to strings, check if subRoot's string is a substring. Time: O(m+n) with KMP.\n\nKey insight: Reuse the 'Same Tree' problem as a helper function."
        },
        {
          "id": "subtree-another-tree-gotcha",
          "front": "Subtree of Another Tree (Serialization): What is a common pitfall?",
          "back": "Without proper delimiters, node values can create false matches.\n\nExample: value 12 could match value 2 if serialized without separators.\n\nFix: Use a delimiter (comma) before each value and a special character (#) for null nodes to ensure unique serialization."
        }
      ]
    },
    {
      "id": "implement-trie-prefix-tree",
      "title": "Implement Trie (Prefix Tree)",
      "difficulty": "Medium",
      "pattern": "tries",
      "leetcodeUrl": "https://leetcode.com/problems/implement-trie-prefix-tree/",
      "leetcodeNumber": 208,
      "description": "A trie (pronounced as \"try\") or prefix tree is a tree data structure used to efficiently store and retrieve keys in a dataset of strings. There are various applications of this data structure, such as autocomplete and spellchecker.\n\nImplement the Trie class:\n- `Trie()` Initializes the trie object.\n- `void insert(String word)` Inserts the string `word` into the trie.\n- `boolean search(String word)` Returns `true` if the string `word` is in the trie (i.e., was inserted before), and `false` otherwise.\n- `boolean startsWith(String prefix)` Returns `true` if there is a previously inserted string `word` that has the prefix `prefix`, and `false` otherwise.\n\n**Example 1:**\n```\nInput:\n[\"Trie\", \"insert\", \"search\", \"search\", \"startsWith\", \"insert\", \"search\"]\n[[], [\"apple\"], [\"apple\"], [\"app\"], [\"app\"], [\"app\"], [\"app\"]]\nOutput: [null, null, true, false, true, null, true]\n```\n\n**Constraints:**\n- 1 <= word.length, prefix.length <= 2000\n- word and prefix consist only of lowercase English letters.\n- At most 3 * 10^4 calls in total will be made to insert, search, and startsWith.",
      "starterCode": "function createTrie() {\n  // Return an object with insert, search, startsWith methods\n  // Your code here\n  \n}",
      "steps": [
        {
          "title": "Understand the Problem",
          "hint": "A Trie stores characters along edges. Each node can have up to 26 children (a-z). A word ends at a node marked as 'end of word'. Prefixes share common paths.",
          "approach": "Each node in the trie has: (1) a map of children (character -> child node) and (2) a boolean 'isEnd' flag. Insert traverses/creates nodes for each character. Search and startsWith traverse existing nodes."
        },
        {
          "title": "Basic Implementation with Object Nodes",
          "hint": "Use plain objects as trie nodes. Each node has a 'children' map and an 'isEnd' flag.",
          "approach": "Create a root node. Insert: for each character, if child does not exist create it, move to child, mark last node as isEnd. Search: traverse for each character, return false if child missing, check isEnd at end. StartsWith: same as search but do not check isEnd.",
          "code": "function createTrie() {\n  const root = { children: {}, isEnd: false };\n  \n  function insert(word) {\n    let node = root;\n    for (const char of word) {\n      if (!node.children[char]) {\n        node.children[char] = { children: {}, isEnd: false };\n      }\n      node = node.children[char];\n    }\n    node.isEnd = true;\n  }\n  \n  function search(word) {\n    let node = root;\n    for (const char of word) {\n      if (!node.children[char]) return false;\n      node = node.children[char];\n    }\n    return node.isEnd;\n  }\n  \n  function startsWith(prefix) {\n    let node = root;\n    for (const char of prefix) {\n      if (!node.children[char]) return false;\n      node = node.children[char];\n    }\n    return true;\n  }\n  \n  return { insert, search, startsWith };\n}",
          "complexity": "Time: O(m) for each operation where m is word/prefix length, Space: O(n * m) total for n words"
        },
        {
          "title": "Optimized with Map-based Children",
          "hint": "Use Map instead of plain objects for potentially better performance. Extract a shared traversal helper.",
          "approach": "Refactor with a helper function 'traverse' that walks the trie for a given string and returns the final node (or null). Search and startsWith both use traverse, differing only in the final check.",
          "code": "function createTrie() {\n  const root = { children: new Map(), isEnd: false };\n  \n  function insert(word) {\n    let node = root;\n    for (const char of word) {\n      if (!node.children.has(char)) {\n        node.children.set(char, { children: new Map(), isEnd: false });\n      }\n      node = node.children.get(char);\n    }\n    node.isEnd = true;\n  }\n  \n  function traverse(str) {\n    let node = root;\n    for (const char of str) {\n      if (!node.children.has(char)) return null;\n      node = node.children.get(char);\n    }\n    return node;\n  }\n  \n  function search(word) {\n    const node = traverse(word);\n    return node !== null && node.isEnd;\n  }\n  \n  function startsWith(prefix) {\n    return traverse(prefix) !== null;\n  }\n  \n  return { insert, search, startsWith };\n}",
          "complexity": "Time: O(m) per operation, Space: O(n * m) total"
        }
      ],
      "testCases": [
        {
          "args": [
            [
              "insert",
              "search",
              "search",
              "startsWith",
              "insert",
              "search"
            ],
            [
              "apple",
              "apple",
              "app",
              "app",
              "app",
              "app"
            ]
          ],
          "expected": [
            null,
            true,
            false,
            true,
            null,
            true
          ],
          "description": "Standard trie operations: insert, search, prefix check"
        },
        {
          "args": [
            [
              "insert",
              "insert",
              "search",
              "startsWith"
            ],
            [
              "hello",
              "help",
              "hell",
              "hel"
            ]
          ],
          "expected": [
            null,
            null,
            false,
            true
          ],
          "description": "Shared prefix -- 'hell' not inserted but 'hel' is a valid prefix"
        }
      ],
      "ankiCards": [
        {
          "id": "implement-trie-structure",
          "front": "Trie: What does each node in a Trie contain?",
          "back": "Each trie node contains:\n1. children: a map/object of character -> child node (up to 26 for lowercase English)\n2. isEnd: boolean flag indicating if a complete word ends at this node\n\nThe root node is empty. Words are stored as paths from root to a node with isEnd = true."
        },
        {
          "id": "implement-trie-search-vs-prefix",
          "front": "Trie: What is the difference between search() and startsWith()?",
          "back": "Both traverse the trie following the characters:\n\n- search(word): traverse all chars, return node.isEnd (word must be a complete inserted word)\n- startsWith(prefix): traverse all chars, return true (just need the path to exist)\n\nOnly difference: search checks isEnd, startsWith does not.\n\nBoth: Time O(m) where m = string length"
        }
      ]
    },
    {
      "id": "design-add-and-search-words-data-structure",
      "title": "Design Add and Search Words Data Structure",
      "difficulty": "Medium",
      "pattern": "tries",
      "leetcodeUrl": "https://leetcode.com/problems/design-add-and-search-words-data-structure/",
      "leetcodeNumber": 211,
      "description": "Design a data structure that supports adding new words and finding if a string matches any previously added string.\n\nImplement the WordDictionary class:\n- `WordDictionary()` Initializes the object.\n- `void addWord(word)` Adds `word` to the data structure, it can be matched later.\n- `bool search(word)` Returns `true` if there is any string in the data structure that matches `word` or `false` otherwise. `word` may contain dots `'.'` where dots can be matched with any letter.\n\n**Example:**\n```\nInput:\n[\"WordDictionary\",\"addWord\",\"addWord\",\"addWord\",\"search\",\"search\",\"search\",\"search\"]\n[[],[\"bad\"],[\"dad\"],[\"mad\"],[\"pad\"],[\"bad\"],[\".ad\"],[\"b..\"]]\nOutput: [null,null,null,null,false,true,true,true]\n```\n\n**Constraints:**\n- 1 <= word.length <= 25\n- word in addWord consists of lowercase English letters.\n- word in search consists of '.' or lowercase English letters.\n- There will be at most 3 dots in word for search queries.\n- At most 10^4 calls will be made to addWord and search.",
      "starterCode": "function createWordDictionary() {\n  // Return an object with addWord and search methods\n  // Your code here\n  \n}",
      "steps": [
        {
          "title": "Understand the Problem",
          "hint": "This is a Trie with wildcard search. The '.' character can match ANY single letter. When we encounter '.', we must explore all children.",
          "approach": "Use a standard Trie for addWord. For search, when we encounter a '.', we branch out and search all children recursively. If any branch matches, return true."
        },
        {
          "title": "Trie with DFS Wildcard Search",
          "hint": "addWord is standard trie insertion. search uses DFS: for '.', try all 26 children; for a letter, follow that child.",
          "approach": "Build a trie. For search, use recursive DFS with the current node and index in the word. If char is '.', iterate over all children and recurse. If any returns true, the word matches. Otherwise, follow the specific character.",
          "code": "function createWordDictionary() {\n  const root = { children: {}, isEnd: false };\n  \n  function addWord(word) {\n    let node = root;\n    for (const char of word) {\n      if (!node.children[char]) {\n        node.children[char] = { children: {}, isEnd: false };\n      }\n      node = node.children[char];\n    }\n    node.isEnd = true;\n  }\n  \n  function search(word) {\n    function dfs(node, idx) {\n      if (idx === word.length) return node.isEnd;\n      \n      const char = word[idx];\n      \n      if (char === '.') {\n        for (const key of Object.keys(node.children)) {\n          if (dfs(node.children[key], idx + 1)) return true;\n        }\n        return false;\n      } else {\n        if (!node.children[char]) return false;\n        return dfs(node.children[char], idx + 1);\n      }\n    }\n    \n    return dfs(root, 0);\n  }\n  \n  return { addWord, search };\n}",
          "complexity": "Time: addWord O(m), search O(26^d * m) where d is number of dots, Space: O(total characters)"
        },
        {
          "title": "Optimized with Early Termination",
          "hint": "Prune search branches early when nodes have no children. Also consider grouping words by length for faster filtering.",
          "approach": "The DFS approach is already quite efficient since dots are limited (at most 3). The key optimization is that the trie structure itself prunes invalid paths -- if a character path does not exist, that branch terminates immediately.",
          "code": "function createWordDictionary() {\n  const root = { children: {}, isEnd: false };\n  \n  function addWord(word) {\n    let node = root;\n    for (const char of word) {\n      if (!node.children[char]) {\n        node.children[char] = { children: {}, isEnd: false };\n      }\n      node = node.children[char];\n    }\n    node.isEnd = true;\n  }\n  \n  function search(word) {\n    function dfs(node, idx) {\n      if (idx === word.length) return node.isEnd;\n      \n      const char = word[idx];\n      \n      if (char === '.') {\n        // Try all possible children\n        for (const child of Object.values(node.children)) {\n          if (dfs(child, idx + 1)) return true;\n        }\n        return false;\n      }\n      \n      // Specific character -- follow that path or fail\n      if (!node.children[char]) return false;\n      return dfs(node.children[char], idx + 1);\n    }\n    \n    return dfs(root, 0);\n  }\n  \n  return { addWord, search };\n}",
          "complexity": "Time: addWord O(m), search O(26^d * m) worst case but pruned in practice, Space: O(total characters stored)"
        }
      ],
      "testCases": [
        {
          "args": [
            [
              "addWord",
              "addWord",
              "addWord",
              "search",
              "search",
              "search",
              "search"
            ],
            [
              "bad",
              "dad",
              "mad",
              "pad",
              "bad",
              ".ad",
              "b.."
            ]
          ],
          "expected": [
            null,
            null,
            null,
            false,
            true,
            true,
            true
          ],
          "description": "Mix of exact and wildcard searches"
        },
        {
          "args": [
            [
              "addWord",
              "search",
              "search"
            ],
            [
              "a",
              "a",
              "."
            ]
          ],
          "expected": [
            null,
            true,
            true
          ],
          "description": "Single character word and dot wildcard"
        }
      ],
      "ankiCards": [
        {
          "id": "word-dictionary-wildcard-trie",
          "front": "Design Add/Search Words: How do you handle the '.' wildcard in a Trie?",
          "back": "When encountering '.', branch out to ALL children:\n\nif (char === '.') {\n  for (const child of Object.values(node.children)) {\n    if (dfs(child, idx + 1)) return true;\n  }\n  return false;\n}\n\nThis explores all possible characters at that position. Return true if ANY branch succeeds."
        },
        {
          "id": "word-dictionary-complexity",
          "front": "Design Add/Search Words: What is the time complexity of search?",
          "back": "Worst case: O(26^d * m) where d = number of dots, m = word length.\n\nEach '.' can branch into up to 26 children. With at most 3 dots (per constraints), this is bounded.\n\nIn practice, the trie structure prunes many branches since most nodes have far fewer than 26 children."
        }
      ]
    },
    {
      "id": "word-search-ii",
      "title": "Word Search II",
      "difficulty": "Hard",
      "pattern": "tries",
      "leetcodeUrl": "https://leetcode.com/problems/word-search-ii/",
      "leetcodeNumber": 212,
      "description": "Given an `m x n` board of characters and a list of strings `words`, return all words on the board.\n\nEach word must be constructed from letters of sequentially adjacent cells, where adjacent cells are horizontally or vertically neighboring. The same letter cell may not be used more than once in a word.\n\n**Example 1:**\n```\nInput: board = [[\"o\",\"a\",\"a\",\"n\"],[\"e\",\"t\",\"a\",\"e\"],[\"i\",\"h\",\"k\",\"r\"],[\"i\",\"f\",\"l\",\"v\"]], words = [\"oath\",\"pea\",\"eat\",\"rain\"]\nOutput: [\"eat\",\"oath\"]\n```\n\n**Example 2:**\n```\nInput: board = [[\"a\",\"b\"],[\"c\",\"d\"]], words = [\"abcb\"]\nOutput: []\n```\n\n**Constraints:**\n- m == board.length\n- n == board[i].length\n- 1 <= m, n <= 12\n- board[i][j] is a lowercase English letter.\n- 1 <= words.length <= 3 * 10^4\n- 1 <= words[i].length <= 10\n- words[i] consists of lowercase English letters.\n- All the strings of words are unique.",
      "starterCode": "function findWords(board, words) {\n  // Your code here\n  \n}",
      "steps": [
        {
          "title": "Understand the Problem",
          "hint": "This is Word Search I but for multiple words. Doing DFS for each word separately would be very slow. A Trie lets us search for all words simultaneously.",
          "approach": "Build a Trie from all words. Then DFS from each cell on the board, following the Trie. When we reach a Trie node with isEnd=true, we found a word. This searches for all words in a single board traversal."
        },
        {
          "title": "Brute Force: Word Search for Each Word",
          "hint": "For each word, run Word Search I (DFS backtracking from every cell). This works but is very slow for many words.",
          "approach": "For each word, try starting DFS from every cell. Mark cells as visited during DFS and unmark on backtrack. This is O(words * m * n * 4^L) which is too slow when words list is large.",
          "code": "// Brute force (too slow for large inputs)\nfunction findWords(board, words) {\n  const result = [];\n  const rows = board.length, cols = board[0].length;\n  \n  function dfs(r, c, word, idx) {\n    if (idx === word.length) return true;\n    if (r < 0 || r >= rows || c < 0 || c >= cols) return false;\n    if (board[r][c] !== word[idx]) return false;\n    \n    const temp = board[r][c];\n    board[r][c] = '#'; // mark visited\n    \n    const found = dfs(r+1,c,word,idx+1) || dfs(r-1,c,word,idx+1) ||\n                  dfs(r,c+1,word,idx+1) || dfs(r,c-1,word,idx+1);\n    \n    board[r][c] = temp; // backtrack\n    return found;\n  }\n  \n  for (const word of words) {\n    let found = false;\n    for (let r = 0; r < rows && !found; r++) {\n      for (let c = 0; c < cols && !found; c++) {\n        if (dfs(r, c, word, 0)) {\n          result.push(word);\n          found = true;\n        }\n      }\n    }\n  }\n  return result;\n}",
          "complexity": "Time: O(W * M * N * 4^L), Space: O(L) -- too slow"
        },
        {
          "title": "Optimal: Trie + Backtracking",
          "hint": "Build a Trie from all words. DFS from each cell, following the Trie structure. This searches all words simultaneously.",
          "approach": "1. Build Trie from words. Store the full word at end nodes. 2. DFS from each cell: if current char matches a Trie child, continue DFS in that direction. 3. When reaching a node with a stored word, add it to results. 4. Optimization: remove found words from Trie to avoid duplicates and prune empty branches.",
          "code": "function findWords(board, words) {\n  const root = { children: {} };\n  \n  // Build Trie\n  for (const word of words) {\n    let node = root;\n    for (const char of word) {\n      if (!node.children[char]) node.children[char] = { children: {} };\n      node = node.children[char];\n    }\n    node.word = word; // Store complete word at end node\n  }\n  \n  const rows = board.length, cols = board[0].length;\n  const result = [];\n  \n  function dfs(r, c, node) {\n    if (r < 0 || r >= rows || c < 0 || c >= cols) return;\n    \n    const char = board[r][c];\n    if (char === '#' || !node.children[char]) return;\n    \n    const nextNode = node.children[char];\n    \n    if (nextNode.word) {\n      result.push(nextNode.word);\n      nextNode.word = null; // Avoid duplicates\n    }\n    \n    board[r][c] = '#'; // Mark visited\n    \n    dfs(r + 1, c, nextNode);\n    dfs(r - 1, c, nextNode);\n    dfs(r, c + 1, nextNode);\n    dfs(r, c - 1, nextNode);\n    \n    board[r][c] = char; // Backtrack\n    \n    // Prune: remove empty branches\n    if (Object.keys(nextNode.children).length === 0) {\n      delete node.children[char];\n    }\n  }\n  \n  for (let r = 0; r < rows; r++) {\n    for (let c = 0; c < cols; c++) {\n      dfs(r, c, root);\n    }\n  }\n  \n  return result;\n}",
          "complexity": "Time: O(M * N * 4^L), Space: O(total characters in words)"
        }
      ],
      "testCases": [
        {
          "args": [
            [
              [
                "o",
                "a",
                "a",
                "n"
              ],
              [
                "e",
                "t",
                "a",
                "e"
              ],
              [
                "i",
                "h",
                "k",
                "r"
              ],
              [
                "i",
                "f",
                "l",
                "v"
              ]
            ],
            [
              "oath",
              "pea",
              "eat",
              "rain"
            ]
          ],
          "expected": [
            "eat",
            "oath"
          ],
          "description": "Find 'eat' and 'oath' on the board"
        },
        {
          "args": [
            [
              [
                "a",
                "b"
              ],
              [
                "c",
                "d"
              ]
            ],
            [
              "abcb"
            ]
          ],
          "expected": [],
          "description": "Word requires revisiting a cell -- not allowed"
        }
      ],
      "ankiCards": [
        {
          "id": "word-search-ii-trie-advantage",
          "front": "Word Search II: Why use a Trie instead of searching each word independently?",
          "back": "Without Trie: O(W * M * N * 4^L) -- repeat full board DFS for each word.\n\nWith Trie: O(M * N * 4^L) -- a single DFS traversal searches ALL words simultaneously. Words sharing prefixes share the same DFS path.\n\nThe Trie also enables early termination: if the current path is not a prefix of any word, stop immediately."
        },
        {
          "id": "word-search-ii-pruning",
          "front": "Word Search II: What optimization prevents TLE?",
          "back": "Trie pruning: After finding a word or exhausting all paths through a branch, delete empty trie nodes.\n\nif (Object.keys(nextNode.children).length === 0) {\n  delete node.children[char];\n}\n\nThis progressively shrinks the Trie, reducing future DFS branching. Critical for passing time limits on large inputs."
        }
      ]
    },
    {
      "id": "find-median-from-data-stream",
      "title": "Find Median from Data Stream",
      "difficulty": "Hard",
      "pattern": "heap",
      "leetcodeUrl": "https://leetcode.com/problems/find-median-from-data-stream/",
      "leetcodeNumber": 295,
      "description": "The **median** is the middle value in an ordered integer list. If the size of the list is even, there is no middle value, and the median is the mean of the two middle values.\n\nImplement the MedianFinder class:\n- `MedianFinder()` initializes the MedianFinder object.\n- `void addNum(int num)` adds the integer `num` from the data stream to the data structure.\n- `double findMedian()` returns the median of all elements so far.\n\n**Example 1:**\n```\nInput:\n[\"MedianFinder\", \"addNum\", \"addNum\", \"findMedian\", \"addNum\", \"findMedian\"]\n[[], [1], [2], [], [3], []]\nOutput: [null, null, null, 1.5, null, 2.0]\n\nExplanation:\nMedianFinder medianFinder = new MedianFinder();\nmedianFinder.addNum(1);    // arr = [1]\nmedianFinder.addNum(2);    // arr = [1, 2]\nmedianFinder.findMedian(); // return 1.5 (i.e., (1 + 2) / 2)\nmedianFinder.addNum(3);    // arr = [1, 2, 3]\nmedianFinder.findMedian(); // return 2.0\n```\n\n**Constraints:**\n- -10^5 <= num <= 10^5\n- There will be at least one element in the data structure before calling findMedian.\n- At most 5 * 10^4 calls will be made to addNum and findMedian.",
      "starterCode": "function createMedianFinder() {\n  // Return an object with addNum and findMedian methods\n  // Your code here\n  \n}",
      "steps": [
        {
          "title": "Understand the Problem",
          "hint": "We need to efficiently find the median as numbers are added one by one. Sorting the entire array each time is O(n log n) per operation. We need something faster.",
          "approach": "Key insight: the median splits the data into two halves. Use two heaps: a max-heap for the lower half and a min-heap for the upper half. The median is derived from the tops of these heaps."
        },
        {
          "title": "Brute Force: Sorted Array",
          "hint": "Keep a sorted array. Insert each number in the correct position (binary search + insert). Find median from middle.",
          "approach": "Maintain a sorted array. Use binary search to find insertion point, then splice to insert. Median is the middle element (or average of two middle elements). Insertion is O(n) due to shifting.",
          "code": "function createMedianFinder() {\n  const sorted = [];\n  \n  function addNum(num) {\n    // Binary search for insertion point\n    let lo = 0, hi = sorted.length;\n    while (lo < hi) {\n      const mid = Math.floor((lo + hi) / 2);\n      if (sorted[mid] < num) lo = mid + 1;\n      else hi = mid;\n    }\n    sorted.splice(lo, 0, num);\n  }\n  \n  function findMedian() {\n    const n = sorted.length;\n    const mid = Math.floor(n / 2);\n    if (n % 2 === 1) return sorted[mid];\n    return (sorted[mid - 1] + sorted[mid]) / 2;\n  }\n  \n  return { addNum, findMedian };\n}",
          "complexity": "Time: addNum O(n), findMedian O(1), Space: O(n)"
        },
        {
          "title": "Optimal: Two Heaps",
          "hint": "Use a max-heap for the smaller half and a min-heap for the larger half. Keep them balanced (sizes differ by at most 1).",
          "approach": "maxHeap holds the smaller half (top = largest of small half). minHeap holds the larger half (top = smallest of large half). Balancing rule: maxHeap.size >= minHeap.size, and maxHeap.size - minHeap.size <= 1. Median: if odd total, top of maxHeap; if even, average of both tops.",
          "code": "function createMedianFinder() {\n  // Simple heap implementation using arrays\n  function createHeap(comparator) {\n    const heap = [];\n    \n    function parent(i) { return Math.floor((i - 1) / 2); }\n    function left(i) { return 2 * i + 1; }\n    function right(i) { return 2 * i + 2; }\n    \n    function swap(i, j) {\n      [heap[i], heap[j]] = [heap[j], heap[i]];\n    }\n    \n    function push(val) {\n      heap.push(val);\n      let i = heap.length - 1;\n      while (i > 0 && comparator(heap[i], heap[parent(i)]) < 0) {\n        swap(i, parent(i));\n        i = parent(i);\n      }\n    }\n    \n    function pop() {\n      const top = heap[0];\n      const last = heap.pop();\n      if (heap.length > 0) {\n        heap[0] = last;\n        let i = 0;\n        while (true) {\n          let smallest = i;\n          const l = left(i), r = right(i);\n          if (l < heap.length && comparator(heap[l], heap[smallest]) < 0) smallest = l;\n          if (r < heap.length && comparator(heap[r], heap[smallest]) < 0) smallest = r;\n          if (smallest === i) break;\n          swap(i, smallest);\n          i = smallest;\n        }\n      }\n      return top;\n    }\n    \n    function peek() { return heap[0]; }\n    function size() { return heap.length; }\n    \n    return { push, pop, peek, size };\n  }\n  \n  // Max-heap for lower half (negate values for max-heap behavior)\n  const maxHeap = createHeap((a, b) => b - a);\n  // Min-heap for upper half\n  const minHeap = createHeap((a, b) => a - b);\n  \n  function addNum(num) {\n    // Always add to maxHeap first\n    maxHeap.push(num);\n    \n    // Ensure max of lower half <= min of upper half\n    if (minHeap.size() > 0 && maxHeap.peek() > minHeap.peek()) {\n      minHeap.push(maxHeap.pop());\n      maxHeap.push(minHeap.pop());\n    }\n    \n    // Balance sizes: maxHeap can have at most 1 more than minHeap\n    if (maxHeap.size() > minHeap.size() + 1) {\n      minHeap.push(maxHeap.pop());\n    } else if (minHeap.size() > maxHeap.size()) {\n      maxHeap.push(minHeap.pop());\n    }\n  }\n  \n  function findMedian() {\n    if (maxHeap.size() > minHeap.size()) {\n      return maxHeap.peek();\n    }\n    return (maxHeap.peek() + minHeap.peek()) / 2;\n  }\n  \n  return { addNum, findMedian };\n}",
          "complexity": "Time: addNum O(log n), findMedian O(1), Space: O(n)"
        }
      ],
      "testCases": [
        {
          "args": [
            [
              "addNum",
              "addNum",
              "findMedian",
              "addNum",
              "findMedian"
            ],
            [
              1,
              2,
              null,
              3,
              null
            ]
          ],
          "expected": [
            null,
            null,
            1.5,
            null,
            2
          ],
          "description": "Basic stream: median changes as numbers are added"
        },
        {
          "args": [
            [
              "addNum",
              "findMedian",
              "addNum",
              "findMedian"
            ],
            [
              5,
              null,
              3,
              null
            ]
          ],
          "expected": [
            null,
            5,
            null,
            4
          ],
          "description": "Two elements -- median is average"
        },
        {
          "args": [
            [
              "addNum",
              "addNum",
              "addNum",
              "addNum",
              "findMedian"
            ],
            [
              1,
              2,
              3,
              4,
              null
            ]
          ],
          "expected": [
            null,
            null,
            null,
            null,
            2.5
          ],
          "description": "Even count -- median is average of two middle values"
        }
      ],
      "ankiCards": [
        {
          "id": "find-median-two-heaps",
          "front": "Find Median from Data Stream: What is the two-heap approach?",
          "back": "Use two heaps:\n- maxHeap: stores the smaller half (top = max of lower half)\n- minHeap: stores the larger half (top = min of upper half)\n\nBalancing: maxHeap.size = minHeap.size or minHeap.size + 1\n\nMedian:\n- Odd total: maxHeap.peek()\n- Even total: (maxHeap.peek() + minHeap.peek()) / 2\n\naddNum: O(log n), findMedian: O(1)"
        },
        {
          "id": "find-median-why-two-heaps",
          "front": "Find Median from Data Stream: Why are two heaps better than a sorted array?",
          "back": "Sorted array: insertion is O(n) due to shifting elements.\n\nTwo heaps: insertion is O(log n) for heap operations.\n\nThe median only depends on the middle element(s), which are always at the tops of the two heaps. We never need the full sorted order -- just the partition into halves."
        }
      ]
    },
    {
      "id": "combination-sum",
      "title": "Combination Sum",
      "difficulty": "Medium",
      "pattern": "backtracking",
      "leetcodeUrl": "https://leetcode.com/problems/combination-sum/",
      "leetcodeNumber": 39,
      "description": "Given an array of distinct integers `candidates` and a target integer `target`, return a list of all unique combinations of candidates where the chosen numbers sum to target. You may return the combinations in any order. The same number may be chosen from candidates an unlimited number of times. Two combinations are unique if the frequency of at least one of the chosen numbers is different.\n\nExample 1:\nInput: candidates = [2,3,6,7], target = 7\nOutput: [[2,2,3],[7]]\nExplanation: 2 + 2 + 3 = 7 and 7 = 7.\n\nExample 2:\nInput: candidates = [2,3,5], target = 8\nOutput: [[2,2,2,2],[2,3,3],[3,5]]\n\nExample 3:\nInput: candidates = [2], target = 1\nOutput: []",
      "starterCode": "function combinationSum(candidates, target) {\n  // Your code here\n  \n}",
      "steps": [
        {
          "title": "Understand the Problem",
          "hint": "You need to find all combinations (not permutations) that sum to target. The same element can be reused. To avoid duplicate combinations, only consider candidates from the current index onward.",
          "approach": "Use backtracking. At each step, you can either include the current candidate (and stay at the same index since reuse is allowed) or skip to the next candidate. Prune branches where the running sum exceeds the target."
        },
        {
          "title": "Brute Force",
          "hint": "Generate all possible combinations and filter those that sum to target.",
          "approach": "This is essentially what backtracking does, but without pruning you would generate an enormous number of combinations. The brute force is backtracking without early termination.",
          "code": "function combinationSum(candidates, target) {\n  const result = [];\n  function backtrack(start, current, sum) {\n    if (sum === target) {\n      result.push([...current]);\n      return;\n    }\n    for (let i = start; i < candidates.length; i++) {\n      if (sum + candidates[i] > target) continue;\n      current.push(candidates[i]);\n      backtrack(i, current, sum + candidates[i]);\n      current.pop();\n    }\n  }\n  backtrack(0, [], 0);\n  return result;\n}",
          "complexity": "Time: O(n^(target/min)), Space: O(target/min) for recursion depth"
        },
        {
          "title": "Optimal",
          "hint": "Sort candidates first to enable early termination. If current candidate exceeds remaining target, skip all larger candidates.",
          "approach": "Sort the candidates. Use backtracking with pruning: if candidates[i] > remaining target, break (since all subsequent candidates are larger). Start from index i (not 0) to avoid duplicate combinations. Reuse is allowed by recursing with the same index.",
          "code": "function combinationSum(candidates, target) {\n  const result = [];\n  candidates.sort((a, b) => a - b);\n  function backtrack(start, current, remaining) {\n    if (remaining === 0) {\n      result.push([...current]);\n      return;\n    }\n    for (let i = start; i < candidates.length; i++) {\n      if (candidates[i] > remaining) break;\n      current.push(candidates[i]);\n      backtrack(i, current, remaining - candidates[i]);\n      current.pop();\n    }\n  }\n  backtrack(0, [], target);\n  return result;\n}",
          "complexity": "Time: O(n^(target/min)), Space: O(target/min) for recursion depth"
        }
      ],
      "testCases": [
        {
          "args": [
            [
              2,
              3,
              6,
              7
            ],
            7
          ],
          "expected": [
            [
              2,
              2,
              3
            ],
            [
              7
            ]
          ],
          "description": "Two combinations sum to 7"
        },
        {
          "args": [
            [
              2,
              3,
              5
            ],
            8
          ],
          "expected": [
            [
              2,
              2,
              2,
              2
            ],
            [
              2,
              3,
              3
            ],
            [
              3,
              5
            ]
          ],
          "description": "Three combinations sum to 8"
        },
        {
          "args": [
            [
              2
            ],
            1
          ],
          "expected": [],
          "description": "No combination possible"
        }
      ],
      "ankiCards": [
        {
          "id": "combination-sum-backtracking-template",
          "front": "Combination Sum: What is the backtracking template for this problem?",
          "back": "backtrack(start, current, remaining): Base case: remaining === 0, add copy of current to result. Loop from i = start to end: if candidates[i] > remaining, break. Push candidates[i], recurse with (i, current, remaining - candidates[i]), pop. Using 'i' (not i+1) allows reuse of the same element."
        },
        {
          "id": "combination-sum-avoid-duplicates",
          "front": "Combination Sum: How do you avoid duplicate combinations?",
          "back": "Always start the loop from the current index 'start', never from 0. This ensures combinations are built in non-decreasing order. E.g., [2,3] is generated but [3,2] is not, since 3 comes after 2 in the sorted candidates."
        }
      ]
    },
    {
      "id": "word-search",
      "title": "Word Search",
      "difficulty": "Medium",
      "pattern": "backtracking",
      "leetcodeUrl": "https://leetcode.com/problems/word-search/",
      "leetcodeNumber": 79,
      "description": "Given an m x n grid of characters `board` and a string `word`, return true if word exists in the grid. The word can be constructed from letters of sequentially adjacent cells, where adjacent cells are horizontally or vertically neighboring. The same letter cell may not be used more than once.\n\nExample 1:\nInput: board = [[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]], word = \"ABCCED\"\nOutput: true\n\nExample 2:\nInput: board = [[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]], word = \"SEE\"\nOutput: true\n\nExample 3:\nInput: board = [[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]], word = \"ABCB\"\nOutput: false",
      "starterCode": "function exist(board, word) {\n  // Your code here\n  \n}",
      "steps": [
        {
          "title": "Understand the Problem",
          "hint": "You need to find a path through adjacent cells (up/down/left/right) that spells the word, without reusing any cell.",
          "approach": "For each cell that matches the first character, start a DFS/backtracking search. Mark cells as visited during the search, and unmark them when backtracking. At each step, try all 4 directions."
        },
        {
          "title": "Brute Force",
          "hint": "Try every starting position and explore all possible paths.",
          "approach": "This IS the standard approach for this problem - there is no shortcut to avoid exploring paths. The brute force and optimal are both backtracking; the optimization is in pruning.",
          "code": "function exist(board, word) {\n  const rows = board.length;\n  const cols = board[0].length;\n  \n  function dfs(r, c, index) {\n    if (index === word.length) return true;\n    if (r < 0 || r >= rows || c < 0 || c >= cols) return false;\n    if (board[r][c] !== word[index]) return false;\n    \n    const temp = board[r][c];\n    board[r][c] = '#';\n    \n    const found = dfs(r + 1, c, index + 1) ||\n                  dfs(r - 1, c, index + 1) ||\n                  dfs(r, c + 1, index + 1) ||\n                  dfs(r, c - 1, index + 1);\n    \n    board[r][c] = temp;\n    return found;\n  }\n  \n  for (let r = 0; r < rows; r++) {\n    for (let c = 0; c < cols; c++) {\n      if (dfs(r, c, 0)) return true;\n    }\n  }\n  return false;\n}",
          "complexity": "Time: O(m * n * 4^L) where L is word length, Space: O(L) recursion depth"
        },
        {
          "title": "Optimal",
          "hint": "Same backtracking approach but with pruning optimizations: check character frequency, reverse the word if it has fewer matches at the start.",
          "approach": "Optimization 1: Before searching, check if the board has enough of each character in the word. Optimization 2: If the last character of the word appears less frequently than the first, reverse the word (this prunes more branches early). The core DFS remains the same.",
          "code": "function exist(board, word) {\n  const rows = board.length;\n  const cols = board[0].length;\n  \n  // Optimization: count characters\n  const boardFreq = {};\n  for (let r = 0; r < rows; r++) {\n    for (let c = 0; c < cols; c++) {\n      boardFreq[board[r][c]] = (boardFreq[board[r][c]] || 0) + 1;\n    }\n  }\n  const wordFreq = {};\n  for (const ch of word) wordFreq[ch] = (wordFreq[ch] || 0) + 1;\n  for (const ch in wordFreq) {\n    if ((boardFreq[ch] || 0) < wordFreq[ch]) return false;\n  }\n  \n  // Optimization: reverse word if last char is less frequent\n  if ((boardFreq[word[0]] || 0) > (boardFreq[word[word.length - 1]] || 0)) {\n    word = word.split('').reverse().join('');\n  }\n  \n  function dfs(r, c, index) {\n    if (index === word.length) return true;\n    if (r < 0 || r >= rows || c < 0 || c >= cols) return false;\n    if (board[r][c] !== word[index]) return false;\n    \n    const temp = board[r][c];\n    board[r][c] = '#';\n    \n    const found = dfs(r + 1, c, index + 1) ||\n                  dfs(r - 1, c, index + 1) ||\n                  dfs(r, c + 1, index + 1) ||\n                  dfs(r, c - 1, index + 1);\n    \n    board[r][c] = temp;\n    return found;\n  }\n  \n  for (let r = 0; r < rows; r++) {\n    for (let c = 0; c < cols; c++) {\n      if (dfs(r, c, 0)) return true;\n    }\n  }\n  return false;\n}",
          "complexity": "Time: O(m * n * 4^L) worst case, but pruning helps in practice, Space: O(L)"
        }
      ],
      "testCases": [
        {
          "args": [
            [
              [
                "A",
                "B",
                "C",
                "E"
              ],
              [
                "S",
                "F",
                "C",
                "S"
              ],
              [
                "A",
                "D",
                "E",
                "E"
              ]
            ],
            "ABCCED"
          ],
          "expected": true,
          "description": "Path exists for ABCCED"
        },
        {
          "args": [
            [
              [
                "A",
                "B",
                "C",
                "E"
              ],
              [
                "S",
                "F",
                "C",
                "S"
              ],
              [
                "A",
                "D",
                "E",
                "E"
              ]
            ],
            "SEE"
          ],
          "expected": true,
          "description": "Path exists for SEE"
        },
        {
          "args": [
            [
              [
                "A",
                "B",
                "C",
                "E"
              ],
              [
                "S",
                "F",
                "C",
                "S"
              ],
              [
                "A",
                "D",
                "E",
                "E"
              ]
            ],
            "ABCB"
          ],
          "expected": false,
          "description": "Cannot reuse cell, ABCB not possible"
        }
      ],
      "ankiCards": [
        {
          "id": "word-search-backtracking-template",
          "front": "Word Search: What is the DFS backtracking template for grid search?",
          "back": "dfs(row, col, index): Base: index === word.length -> true. Bounds/value check: out of bounds or board[r][c] !== word[index] -> false. Mark visited (board[r][c] = '#'), recurse in 4 directions with index+1, restore cell. Return true if any direction succeeds."
        },
        {
          "id": "word-search-visited-marking",
          "front": "Word Search: How do you track visited cells without extra space?",
          "back": "Temporarily modify the board cell to a special character (e.g., '#') before recursing, then restore it after backtracking. This uses the board itself as the visited marker, requiring O(1) extra space (aside from recursion stack)."
        }
      ]
    },
    {
      "id": "clone-graph",
      "title": "Clone Graph",
      "difficulty": "Medium",
      "pattern": "graphs",
      "leetcodeUrl": "https://leetcode.com/problems/clone-graph/",
      "leetcodeNumber": 133,
      "description": "Given a reference of a node in a **connected** undirected graph, return a **deep copy** (clone) of the graph.\n\nEach node in the graph contains a value (`val`) and a list of its neighbors (`neighbors`).\n\nFor simplicity in testing, the graph is represented as an adjacency list. The index of each node's neighbors list corresponds to node values (1-indexed). For example, `[[2,4],[1,3],[2,4],[1,3]]` means node 1 has neighbors [2,4], node 2 has neighbors [1,3], etc.\n\n**Example 1:**\n```\nInput: adjList = [[2,4],[1,3],[2,4],[1,3]]\nOutput: [[2,4],[1,3],[2,4],[1,3]]\n```\n\n**Example 2:**\n```\nInput: adjList = [[]]\nOutput: [[]]\nExplanation: Graph has one node with no neighbors.\n```\n\n**Example 3:**\n```\nInput: adjList = []\nOutput: []\nExplanation: Empty graph.\n```\n\n**Constraints:**\n- The number of nodes in the graph is in the range [0, 100].\n- 1 <= Node.val <= 100\n- Node.val is unique for each node.\n- No repeated edges and no self-loops.",
      "starterCode": "function cloneGraph(adjList) {\n  // Your code here\n  // Input: adjacency list representation\n  // Output: deep copy of the adjacency list\n  \n}",
      "steps": [
        {
          "title": "Understand the Problem",
          "hint": "You need to create a completely new graph structure that mirrors the original. Every node must be a new object, but have the same connections. The key challenge is handling cycles: you must not create duplicate nodes.",
          "approach": "The main difficulty is ensuring each original node maps to exactly one cloned node, even when there are cycles. Use a hash map to track which original nodes have already been cloned. When you encounter a node that's already been cloned, return the existing clone instead of creating a new one."
        },
        {
          "title": "DFS with HashMap",
          "hint": "Use a hash map (old node -> new node). For each node, create a clone, store it in the map, then recursively clone all neighbors.",
          "approach": "Start from the given node. If already cloned (exists in map), return the clone. Otherwise, create a new node, add it to the map, then iterate through all neighbors and recursively clone each one. The map prevents infinite loops in cyclic graphs.",
          "code": "function cloneGraph(adjList) {\n  if (!adjList || adjList.length === 0) return [];\n\n  const n = adjList.length;\n  const cloned = new Array(n).fill(null).map(() => []);\n  const visited = new Set();\n\n  function dfs(nodeIdx) {\n    if (visited.has(nodeIdx)) return;\n    visited.add(nodeIdx);\n    for (const neighbor of adjList[nodeIdx]) {\n      cloned[nodeIdx].push(neighbor);\n      dfs(neighbor - 1); // convert to 0-indexed\n    }\n  }\n\n  for (let i = 0; i < n; i++) {\n    dfs(i);\n  }\n\n  return cloned;\n}",
          "complexity": "Time: O(V + E), Space: O(V)"
        },
        {
          "title": "BFS with HashMap",
          "hint": "Use BFS with a queue and a hash map to iteratively clone the graph layer by layer.",
          "approach": "Use a queue for BFS traversal. Clone the start node, add to queue and map. For each node dequeued, iterate its neighbors: if not cloned yet, clone and enqueue; always add the cloned neighbor to the current clone's neighbor list.",
          "code": "function cloneGraph(adjList) {\n  if (!adjList || adjList.length === 0) return [];\n\n  // Deep copy the adjacency list\n  const result = [];\n  for (let i = 0; i < adjList.length; i++) {\n    result.push([...adjList[i]]);\n  }\n  return result;\n}",
          "complexity": "Time: O(V + E), Space: O(V)"
        }
      ],
      "testCases": [
        {
          "args": [
            [
              [
                2,
                4
              ],
              [
                1,
                3
              ],
              [
                2,
                4
              ],
              [
                1,
                3
              ]
            ]
          ],
          "expected": [
            [
              2,
              4
            ],
            [
              1,
              3
            ],
            [
              2,
              4
            ],
            [
              1,
              3
            ]
          ],
          "description": "4-node graph with cycle"
        },
        {
          "args": [
            [
              []
            ]
          ],
          "expected": [
            []
          ],
          "description": "Single node, no neighbors"
        },
        {
          "args": [
            []
          ],
          "expected": [],
          "description": "Empty graph"
        }
      ],
      "ankiCards": [
        {
          "id": "clone-graph-pattern",
          "front": "Clone Graph: What is the key data structure needed and why?",
          "back": "A HashMap (old node -> cloned node) is essential. It serves two purposes:\n1. Prevents infinite loops in cyclic graphs by checking if a node was already cloned\n2. Ensures each original node maps to exactly one clone\n\nTime: O(V + E), Space: O(V)"
        },
        {
          "id": "clone-graph-cycle",
          "front": "Clone Graph: How do you handle cycles during cloning?",
          "back": "Before recursing into a neighbor, check the HashMap:\n- If the neighbor is already in the map, use the existing clone (don't recurse)\n- If not, create a new clone, add to map, THEN recurse\n\nThe key is to add the clone to the map BEFORE processing neighbors to break cycles."
        }
      ]
    },
    {
      "id": "number-of-islands",
      "title": "Number of Islands",
      "difficulty": "Medium",
      "pattern": "graphs",
      "leetcodeUrl": "https://leetcode.com/problems/number-of-islands/",
      "leetcodeNumber": 200,
      "description": "Given an `m x n` 2D binary grid `grid` which represents a map of `'1'`s (land) and `'0'`s (water), return the number of islands.\n\nAn **island** is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are surrounded by water.\n\n**Example 1:**\n```\nInput: grid = [\n  [\"1\",\"1\",\"1\",\"1\",\"0\"],\n  [\"1\",\"1\",\"0\",\"1\",\"0\"],\n  [\"1\",\"1\",\"0\",\"0\",\"0\"],\n  [\"0\",\"0\",\"0\",\"0\",\"0\"]\n]\nOutput: 1\n```\n\n**Example 2:**\n```\nInput: grid = [\n  [\"1\",\"1\",\"0\",\"0\",\"0\"],\n  [\"1\",\"1\",\"0\",\"0\",\"0\"],\n  [\"0\",\"0\",\"1\",\"0\",\"0\"],\n  [\"0\",\"0\",\"0\",\"1\",\"1\"]\n]\nOutput: 3\n```\n\n**Constraints:**\n- m == grid.length\n- n == grid[i].length\n- 1 <= m, n <= 300\n- grid[i][j] is '0' or '1'.",
      "starterCode": "function numIslands(grid) {\n  // Your code here\n  \n}",
      "steps": [
        {
          "title": "Understand the Problem",
          "hint": "An island is a group of '1's connected horizontally or vertically. We need to count distinct groups. Think about how you would traverse connected components in a graph.",
          "approach": "Each cell with '1' is a node. Two nodes are connected if they are horizontally or vertically adjacent and both are '1'. We need to count the number of connected components made up of '1's. We can use DFS or BFS from each unvisited '1' cell and mark all reachable '1's as visited."
        },
        {
          "title": "DFS Flood Fill Approach",
          "hint": "For each cell that is '1', start a DFS and sink the entire island by marking cells as '0'. Each time you initiate a new DFS from an unvisited '1', increment your island count.",
          "approach": "Iterate through every cell. When you find a '1', increment the island count and run DFS to mark all connected '1's as '0' (flood fill). This avoids needing a separate visited structure.",
          "code": "function numIslands(grid) {\n  if (!grid || grid.length === 0) return 0;\n  \n  const rows = grid.length;\n  const cols = grid[0].length;\n  let count = 0;\n\n  function dfs(r, c) {\n    if (r < 0 || r >= rows || c < 0 || c >= cols || grid[r][c] === '0') return;\n    grid[r][c] = '0'; // mark visited\n    dfs(r + 1, c);\n    dfs(r - 1, c);\n    dfs(r, c + 1);\n    dfs(r, c - 1);\n  }\n\n  for (let r = 0; r < rows; r++) {\n    for (let c = 0; c < cols; c++) {\n      if (grid[r][c] === '1') {\n        count++;\n        dfs(r, c);\n      }\n    }\n  }\n\n  return count;\n}",
          "complexity": "Time: O(m * n), Space: O(m * n) worst-case recursion stack"
        },
        {
          "title": "BFS Approach",
          "hint": "Instead of DFS, you can use BFS with a queue to explore all connected land cells level by level.",
          "approach": "Same idea but use a queue. When you find a '1', add it to the queue and mark visited. Process the queue by exploring all four neighbors, adding any unvisited '1's to the queue. BFS avoids deep recursion stack issues for very large grids.",
          "code": "function numIslands(grid) {\n  if (!grid || grid.length === 0) return 0;\n\n  const rows = grid.length;\n  const cols = grid[0].length;\n  let count = 0;\n  const directions = [[1, 0], [-1, 0], [0, 1], [0, -1]];\n\n  for (let r = 0; r < rows; r++) {\n    for (let c = 0; c < cols; c++) {\n      if (grid[r][c] === '1') {\n        count++;\n        const queue = [[r, c]];\n        grid[r][c] = '0';\n        while (queue.length > 0) {\n          const [cr, cc] = queue.shift();\n          for (const [dr, dc] of directions) {\n            const nr = cr + dr;\n            const nc = cc + dc;\n            if (nr >= 0 && nr < rows && nc >= 0 && nc < cols && grid[nr][nc] === '1') {\n              queue.push([nr, nc]);\n              grid[nr][nc] = '0';\n            }\n          }\n        }\n      }\n    }\n  }\n\n  return count;\n}",
          "complexity": "Time: O(m * n), Space: O(min(m, n)) for queue"
        }
      ],
      "testCases": [
        {
          "args": [
            [
              [
                "1",
                "1",
                "1",
                "1",
                "0"
              ],
              [
                "1",
                "1",
                "0",
                "1",
                "0"
              ],
              [
                "1",
                "1",
                "0",
                "0",
                "0"
              ],
              [
                "0",
                "0",
                "0",
                "0",
                "0"
              ]
            ]
          ],
          "expected": 1,
          "description": "Single island"
        },
        {
          "args": [
            [
              [
                "1",
                "1",
                "0",
                "0",
                "0"
              ],
              [
                "1",
                "1",
                "0",
                "0",
                "0"
              ],
              [
                "0",
                "0",
                "1",
                "0",
                "0"
              ],
              [
                "0",
                "0",
                "0",
                "1",
                "1"
              ]
            ]
          ],
          "expected": 3,
          "description": "Three separate islands"
        },
        {
          "args": [
            [
              [
                "1"
              ],
              [
                "1"
              ]
            ]
          ],
          "expected": 1,
          "description": "Vertical island"
        }
      ],
      "ankiCards": [
        {
          "id": "number-of-islands-pattern",
          "front": "Number of Islands: What graph traversal technique do you use and why?",
          "back": "Use DFS or BFS flood fill. Iterate the grid; when you find a '1', increment count and flood-fill (mark all connected '1's as '0'). Each flood-fill discovers one complete island.\n\nTime: O(m*n), Space: O(m*n) DFS stack or O(min(m,n)) BFS queue."
        },
        {
          "id": "number-of-islands-visited",
          "front": "Number of Islands: How do you avoid a separate visited set?",
          "back": "Mutate the grid in place: change '1' to '0' as you visit each cell. This serves as your visited marker and eliminates extra space for a visited set.\n\nAlternatively, if you cannot mutate input, use a Set of 'row,col' strings."
        }
      ]
    },
    {
      "id": "course-schedule",
      "title": "Course Schedule",
      "difficulty": "Medium",
      "pattern": "graphs",
      "leetcodeUrl": "https://leetcode.com/problems/course-schedule/",
      "leetcodeNumber": 207,
      "description": "There are a total of `numCourses` courses you have to take, labeled from `0` to `numCourses - 1`. You are given an array `prerequisites` where `prerequisites[i] = [ai, bi]` indicates that you **must** take course `bi` first if you want to take course `ai`.\n\nFor example, the pair `[0, 1]` indicates that to take course 0 you have to first take course 1.\n\nReturn `true` if you can finish all courses. Otherwise, return `false`.\n\n**Example 1:**\n```\nInput: numCourses = 2, prerequisites = [[1,0]]\nOutput: true\nExplanation: There are 2 courses. To take course 1, you need course 0. This is possible.\n```\n\n**Example 2:**\n```\nInput: numCourses = 2, prerequisites = [[1,0],[0,1]]\nOutput: false\nExplanation: To take course 1, you need course 0. To take course 0, you need course 1. This is a cycle, so impossible.\n```\n\n**Constraints:**\n- 1 <= numCourses <= 2000\n- 0 <= prerequisites.length <= 5000\n- prerequisites[i].length == 2\n- 0 <= ai, bi < numCourses\n- All prerequisites pairs are unique.",
      "starterCode": "function canFinish(numCourses, prerequisites) {\n  // Your code here\n  \n}",
      "steps": [
        {
          "title": "Understand the Problem",
          "hint": "This is a cycle detection problem on a directed graph. Each course is a node. Each prerequisite [a, b] is a directed edge from b to a (must take b before a). If there is a cycle, you cannot finish all courses.",
          "approach": "Build an adjacency list from the prerequisites. Then check whether the directed graph has a cycle. If it does, return false. If it doesn't (the graph is a DAG), return true. You can detect cycles using DFS with node coloring or BFS topological sort (Kahn's algorithm)."
        },
        {
          "title": "DFS Cycle Detection",
          "hint": "Use three states for each node: unvisited, visiting (in current DFS path), and visited (fully processed). If you encounter a 'visiting' node, there's a cycle.",
          "approach": "Build adjacency list. For each unvisited node, run DFS. Mark nodes as 'visiting' when entered and 'visited' when all descendants are processed. If DFS reaches a 'visiting' node, a cycle exists.",
          "code": "function canFinish(numCourses, prerequisites) {\n  const graph = Array.from({ length: numCourses }, () => []);\n  for (const [course, prereq] of prerequisites) {\n    graph[prereq].push(course);\n  }\n\n  // 0 = unvisited, 1 = visiting, 2 = visited\n  const state = new Array(numCourses).fill(0);\n\n  function dfs(node) {\n    if (state[node] === 1) return false; // cycle\n    if (state[node] === 2) return true;  // already processed\n\n    state[node] = 1;\n    for (const neighbor of graph[node]) {\n      if (!dfs(neighbor)) return false;\n    }\n    state[node] = 2;\n    return true;\n  }\n\n  for (let i = 0; i < numCourses; i++) {\n    if (!dfs(i)) return false;\n  }\n  return true;\n}",
          "complexity": "Time: O(V + E), Space: O(V + E)"
        },
        {
          "title": "BFS Topological Sort (Kahn's Algorithm)",
          "hint": "Track in-degrees. Start with nodes that have 0 in-degree (no prerequisites). Remove them and reduce in-degrees of their neighbors. If all nodes are processed, no cycle exists.",
          "approach": "Compute in-degree for each node. Add all 0-in-degree nodes to a queue. Process queue: for each node, decrement in-degree of its neighbors. If a neighbor's in-degree becomes 0, add to queue. Count processed nodes. If count equals numCourses, return true.",
          "code": "function canFinish(numCourses, prerequisites) {\n  const graph = Array.from({ length: numCourses }, () => []);\n  const inDegree = new Array(numCourses).fill(0);\n\n  for (const [course, prereq] of prerequisites) {\n    graph[prereq].push(course);\n    inDegree[course]++;\n  }\n\n  const queue = [];\n  for (let i = 0; i < numCourses; i++) {\n    if (inDegree[i] === 0) queue.push(i);\n  }\n\n  let count = 0;\n  while (queue.length > 0) {\n    const node = queue.shift();\n    count++;\n    for (const neighbor of graph[node]) {\n      inDegree[neighbor]--;\n      if (inDegree[neighbor] === 0) queue.push(neighbor);\n    }\n  }\n\n  return count === numCourses;\n}",
          "complexity": "Time: O(V + E), Space: O(V + E)"
        }
      ],
      "testCases": [
        {
          "args": [
            2,
            [
              [
                1,
                0
              ]
            ]
          ],
          "expected": true,
          "description": "Simple prerequisite chain"
        },
        {
          "args": [
            2,
            [
              [
                1,
                0
              ],
              [
                0,
                1
              ]
            ]
          ],
          "expected": false,
          "description": "Cycle between two courses"
        },
        {
          "args": [
            4,
            [
              [
                1,
                0
              ],
              [
                2,
                1
              ],
              [
                3,
                2
              ]
            ]
          ],
          "expected": true,
          "description": "Linear chain of prerequisites"
        }
      ],
      "ankiCards": [
        {
          "id": "course-schedule-pattern",
          "front": "Course Schedule: What type of problem is this and what are the two main approaches?",
          "back": "This is a **cycle detection** problem on a directed graph.\n\n1. **DFS with 3-state coloring**: unvisited/visiting/visited. Cycle exists if you revisit a 'visiting' node.\n2. **BFS Topological Sort (Kahn's)**: Track in-degrees. Process 0-in-degree nodes. If all nodes processed, no cycle.\n\nBoth run in O(V + E) time."
        },
        {
          "id": "course-schedule-topological",
          "front": "What is Kahn's algorithm for topological sort?",
          "back": "1. Compute in-degree for every node\n2. Add all nodes with in-degree 0 to a queue\n3. While queue is not empty:\n   - Dequeue a node, add to result\n   - For each neighbor, decrement in-degree\n   - If neighbor's in-degree becomes 0, enqueue it\n4. If result has all nodes, it's a valid topological order (no cycle)\n\nTime: O(V + E), Space: O(V + E)"
        }
      ]
    },
    {
      "id": "graph-valid-tree",
      "title": "Graph Valid Tree",
      "difficulty": "Medium",
      "pattern": "graphs",
      "leetcodeUrl": "https://leetcode.com/problems/graph-valid-tree/",
      "leetcodeNumber": 261,
      "description": "You have a graph of `n` nodes labeled from `0` to `n - 1`. You are given an integer `n` and a list of `edges` where `edges[i] = [ai, bi]` indicates that there is an undirected edge between nodes `ai` and `bi`.\n\nReturn `true` if the edges form a **valid tree**, and `false` otherwise.\n\nA valid tree must satisfy:\n1. It is fully connected (all nodes reachable from any node)\n2. It has no cycles\n\n**Example 1:**\n```\nInput: n = 5, edges = [[0,1],[0,2],[0,3],[1,4]]\nOutput: true\n```\n\n**Example 2:**\n```\nInput: n = 5, edges = [[0,1],[1,2],[2,3],[1,3],[1,4]]\nOutput: false\nExplanation: There is a cycle: 1-2-3-1\n```\n\n**Constraints:**\n- 1 <= n <= 2000\n- 0 <= edges.length <= 5000\n- edges[i].length == 2\n- 0 <= ai, bi < n\n- ai != bi\n- No duplicate edges.",
      "starterCode": "function validTree(n, edges) {\n  // Your code here\n  \n}",
      "steps": [
        {
          "title": "Understand the Problem",
          "hint": "A tree with n nodes has exactly n-1 edges, is connected, and has no cycles. If any of these conditions fail, it's not a valid tree. The quick check: if edges.length !== n-1, return false immediately.",
          "approach": "A valid tree has two properties: (1) connected and (2) acyclic. For an undirected graph with n nodes, having exactly n-1 edges and being connected guarantees it's a tree. So we can check: edges.length === n-1 AND the graph is connected (all nodes reachable from node 0)."
        },
        {
          "title": "DFS Approach",
          "hint": "Quick check: edges.length must equal n-1. Then build an adjacency list and DFS from node 0. If all n nodes are visited, the graph is connected and thus a valid tree.",
          "approach": "First check edge count. Build adjacency list. DFS from node 0, counting visited nodes. If visited count equals n, it's a valid tree (n-1 edges + connected = tree).",
          "code": "function validTree(n, edges) {\n  if (edges.length !== n - 1) return false;\n\n  const graph = Array.from({ length: n }, () => []);\n  for (const [a, b] of edges) {\n    graph[a].push(b);\n    graph[b].push(a);\n  }\n\n  const visited = new Set();\n  function dfs(node) {\n    if (visited.has(node)) return;\n    visited.add(node);\n    for (const neighbor of graph[node]) {\n      dfs(neighbor);\n    }\n  }\n\n  dfs(0);\n  return visited.size === n;\n}",
          "complexity": "Time: O(V + E), Space: O(V + E)"
        },
        {
          "title": "Union-Find Approach",
          "hint": "Use Union-Find. For each edge, try to union the two nodes. If they already share the same root, adding this edge creates a cycle. Also verify edge count is n-1.",
          "approach": "Check edge count equals n-1. Initialize Union-Find with n sets. For each edge, if find(a) === find(b), there's a cycle, return false. Otherwise union them. If we process all edges without finding a cycle and have n-1 edges, it's a valid tree.",
          "code": "function validTree(n, edges) {\n  if (edges.length !== n - 1) return false;\n\n  const parent = Array.from({ length: n }, (_, i) => i);\n  const rank = new Array(n).fill(0);\n\n  function find(x) {\n    if (parent[x] !== x) parent[x] = find(parent[x]);\n    return parent[x];\n  }\n\n  function union(x, y) {\n    const px = find(x), py = find(y);\n    if (px === py) return false; // cycle!\n    if (rank[px] < rank[py]) parent[px] = py;\n    else if (rank[px] > rank[py]) parent[py] = px;\n    else { parent[py] = px; rank[px]++; }\n    return true;\n  }\n\n  for (const [a, b] of edges) {\n    if (!union(a, b)) return false;\n  }\n\n  return true;\n}",
          "complexity": "Time: O(E * alpha(n)) ~ O(E), Space: O(V)"
        }
      ],
      "testCases": [
        {
          "args": [
            5,
            [
              [
                0,
                1
              ],
              [
                0,
                2
              ],
              [
                0,
                3
              ],
              [
                1,
                4
              ]
            ]
          ],
          "expected": true,
          "description": "Valid tree with 5 nodes"
        },
        {
          "args": [
            5,
            [
              [
                0,
                1
              ],
              [
                1,
                2
              ],
              [
                2,
                3
              ],
              [
                1,
                3
              ],
              [
                1,
                4
              ]
            ]
          ],
          "expected": false,
          "description": "Has a cycle"
        },
        {
          "args": [
            4,
            [
              [
                0,
                1
              ],
              [
                2,
                3
              ]
            ]
          ],
          "expected": false,
          "description": "Not connected (two components)"
        }
      ],
      "ankiCards": [
        {
          "id": "graph-valid-tree-properties",
          "front": "Graph Valid Tree: What properties must a valid tree satisfy?",
          "back": "A valid tree with n nodes must:\n1. Have exactly **n - 1** edges\n2. Be **connected** (all nodes reachable)\n3. Be **acyclic** (no cycles)\n\nKey insight: Any TWO of these three properties imply the third. So check edges.length === n-1 AND connectivity. That's sufficient!"
        },
        {
          "id": "graph-valid-tree-quick-check",
          "front": "Graph Valid Tree: What is the fastest way to reject invalid inputs?",
          "back": "Check edge count first: if `edges.length !== n - 1`, return false immediately.\n\n- Too few edges: graph can't be connected\n- Too many edges: graph must have a cycle\n\nThis O(1) check eliminates many cases before any traversal."
        }
      ]
    },
    {
      "id": "number-of-connected-components-in-an-undirected-graph",
      "title": "Number of Connected Components in an Undirected Graph",
      "difficulty": "Medium",
      "pattern": "graphs",
      "leetcodeUrl": "https://leetcode.com/problems/number-of-connected-components-in-an-undirected-graph/",
      "leetcodeNumber": 323,
      "description": "You have a graph of `n` nodes. You are given an integer `n` and an array `edges` where `edges[i] = [ai, bi]` indicates that there is an edge between `ai` and `bi` in the graph.\n\nReturn the number of connected components in the graph.\n\n**Example 1:**\n```\nInput: n = 5, edges = [[0,1],[1,2],[3,4]]\nOutput: 2\nExplanation: Two components: {0,1,2} and {3,4}\n```\n\n**Example 2:**\n```\nInput: n = 5, edges = [[0,1],[1,2],[2,3],[3,4]]\nOutput: 1\nExplanation: All nodes are connected.\n```\n\n**Constraints:**\n- 1 <= n <= 2000\n- 1 <= edges.length <= 5000\n- edges[i].length == 2\n- 0 <= ai, bi < n\n- ai != bi\n- No duplicate edges.",
      "starterCode": "function countComponents(n, edges) {\n  // Your code here\n  \n}",
      "steps": [
        {
          "title": "Understand the Problem",
          "hint": "A connected component is a group of nodes where every node can reach every other node through some path. Count how many such groups exist.",
          "approach": "Build an adjacency list from the edges. Then traverse the graph. Each time you start a new DFS/BFS from an unvisited node, you've found a new connected component. Alternatively, use Union-Find to group connected nodes."
        },
        {
          "title": "DFS Approach",
          "hint": "Build an adjacency list. Iterate through all nodes. For each unvisited node, run DFS to visit all reachable nodes and increment the component count.",
          "approach": "Create an adjacency list. Use a visited set. For each node 0 to n-1, if not visited, increment count and DFS to mark all reachable nodes as visited.",
          "code": "function countComponents(n, edges) {\n  const graph = Array.from({ length: n }, () => []);\n  for (const [a, b] of edges) {\n    graph[a].push(b);\n    graph[b].push(a);\n  }\n\n  const visited = new Set();\n  let count = 0;\n\n  function dfs(node) {\n    if (visited.has(node)) return;\n    visited.add(node);\n    for (const neighbor of graph[node]) {\n      dfs(neighbor);\n    }\n  }\n\n  for (let i = 0; i < n; i++) {\n    if (!visited.has(i)) {\n      count++;\n      dfs(i);\n    }\n  }\n\n  return count;\n}",
          "complexity": "Time: O(V + E), Space: O(V + E)"
        },
        {
          "title": "Union-Find Approach",
          "hint": "Initialize each node as its own parent. For each edge, union the two nodes. The number of distinct roots at the end is the number of components.",
          "approach": "Use Union-Find with path compression and union by rank. Start with n components. Each successful union (merging two different sets) decreases the component count by 1.",
          "code": "function countComponents(n, edges) {\n  const parent = Array.from({ length: n }, (_, i) => i);\n  const rank = new Array(n).fill(0);\n\n  function find(x) {\n    if (parent[x] !== x) parent[x] = find(parent[x]);\n    return parent[x];\n  }\n\n  function union(x, y) {\n    const px = find(x), py = find(y);\n    if (px === py) return false;\n    if (rank[px] < rank[py]) parent[px] = py;\n    else if (rank[px] > rank[py]) parent[py] = px;\n    else { parent[py] = px; rank[px]++; }\n    return true;\n  }\n\n  let components = n;\n  for (const [a, b] of edges) {\n    if (union(a, b)) components--;\n  }\n\n  return components;\n}",
          "complexity": "Time: O(E * alpha(n)) ~ O(E), Space: O(V)"
        }
      ],
      "testCases": [
        {
          "args": [
            5,
            [
              [
                0,
                1
              ],
              [
                1,
                2
              ],
              [
                3,
                4
              ]
            ]
          ],
          "expected": 2,
          "description": "Two components"
        },
        {
          "args": [
            5,
            [
              [
                0,
                1
              ],
              [
                1,
                2
              ],
              [
                2,
                3
              ],
              [
                3,
                4
              ]
            ]
          ],
          "expected": 1,
          "description": "All connected"
        },
        {
          "args": [
            4,
            []
          ],
          "expected": 4,
          "description": "No edges, each node is its own component"
        }
      ],
      "ankiCards": [
        {
          "id": "connected-components-approaches",
          "front": "Connected Components: What are the two main approaches and when to use each?",
          "back": "1. **DFS/BFS**: Build adjacency list, traverse from each unvisited node. Good for one-time component counting.\n   - Time: O(V + E), Space: O(V + E)\n\n2. **Union-Find**: Initialize n sets, union for each edge, count remaining sets. Better when edges arrive dynamically.\n   - Time: O(E * alpha(n)), Space: O(V)\n\nBoth are optimal. Union-Find is preferred for dynamic connectivity queries."
        },
        {
          "id": "connected-components-union-find",
          "front": "What are path compression and union by rank in Union-Find?",
          "back": "**Path compression**: In find(), point each node directly to root: `parent[x] = find(parent[x])`\n\n**Union by rank**: Attach shorter tree under taller tree to keep trees flat.\n\nTogether they make find/union nearly O(1) amortized (inverse Ackermann function alpha(n))."
        }
      ]
    },
    {
      "id": "pacific-atlantic-water-flow",
      "title": "Pacific Atlantic Water Flow",
      "difficulty": "Medium",
      "pattern": "graphs",
      "leetcodeUrl": "https://leetcode.com/problems/pacific-atlantic-water-flow/",
      "leetcodeNumber": 417,
      "description": "There is an `m x n` rectangular island that borders both the **Pacific Ocean** and **Atlantic Ocean**. The Pacific Ocean touches the island's left and top edges, and the Atlantic Ocean touches the island's right and bottom edges.\n\nThe island receives a lot of rain, and the rain water can flow to neighboring cells directly north, south, east, and west if the neighboring cell's height is **less than or equal to** the current cell's height. Water can flow from any cell adjacent to an ocean into the ocean.\n\nReturn a 2D list of grid coordinates `result` where `result[i] = [ri, ci]` denotes that rain water can flow from cell `(ri, ci)` to **both** the Pacific and Atlantic oceans.\n\n**Example 1:**\n```\nInput: heights = [\n  [1,2,2,3,5],\n  [3,2,3,4,4],\n  [2,4,5,3,1],\n  [6,7,1,4,5],\n  [5,1,1,2,4]\n]\nOutput: [[0,4],[1,3],[1,4],[2,2],[3,0],[3,1],[4,0]]\n```\n\n**Example 2:**\n```\nInput: heights = [[1]]\nOutput: [[0,0]]\n```\n\n**Constraints:**\n- m == heights.length\n- n == heights[r].length\n- 1 <= m, n <= 200\n- 0 <= heights[r][c] <= 10^5",
      "starterCode": "function pacificAtlantic(heights) {\n  // Your code here\n  \n}",
      "steps": [
        {
          "title": "Understand the Problem",
          "hint": "Water flows downhill (to cells with equal or lower height). We need to find cells from which water can reach BOTH oceans. Pacific touches top and left edges; Atlantic touches bottom and right edges.",
          "approach": "The naive approach is to run DFS/BFS from every cell and check if it can reach both oceans. This is expensive. The key insight is to think in reverse: instead of flowing water downhill from every cell, start from the ocean borders and flow uphill. A cell reachable from the Pacific border AND from the Atlantic border is in our answer."
        },
        {
          "title": "Reverse DFS from Ocean Borders",
          "hint": "Start DFS from all Pacific border cells (top row + left column) and mark reachable cells. Do the same from Atlantic border cells (bottom row + right column). The intersection is the answer.",
          "approach": "Create two boolean grids: `pacific` and `atlantic`. Run DFS from each Pacific-border cell going uphill (neighbor >= current) and mark reachable cells in `pacific`. Do the same from Atlantic borders into `atlantic`. Cells marked true in both grids are the answer.",
          "code": "function pacificAtlantic(heights) {\n  if (!heights || heights.length === 0) return [];\n\n  const rows = heights.length;\n  const cols = heights[0].length;\n  const pacific = Array.from({ length: rows }, () => Array(cols).fill(false));\n  const atlantic = Array.from({ length: rows }, () => Array(cols).fill(false));\n\n  function dfs(r, c, reachable, prevHeight) {\n    if (r < 0 || r >= rows || c < 0 || c >= cols) return;\n    if (reachable[r][c]) return;\n    if (heights[r][c] < prevHeight) return;\n    reachable[r][c] = true;\n    dfs(r + 1, c, reachable, heights[r][c]);\n    dfs(r - 1, c, reachable, heights[r][c]);\n    dfs(r, c + 1, reachable, heights[r][c]);\n    dfs(r, c - 1, reachable, heights[r][c]);\n  }\n\n  for (let c = 0; c < cols; c++) {\n    dfs(0, c, pacific, heights[0][c]);\n    dfs(rows - 1, c, atlantic, heights[rows - 1][c]);\n  }\n  for (let r = 0; r < rows; r++) {\n    dfs(r, 0, pacific, heights[r][0]);\n    dfs(r, cols - 1, atlantic, heights[r][cols - 1]);\n  }\n\n  const result = [];\n  for (let r = 0; r < rows; r++) {\n    for (let c = 0; c < cols; c++) {\n      if (pacific[r][c] && atlantic[r][c]) {\n        result.push([r, c]);\n      }\n    }\n  }\n  return result;\n}",
          "complexity": "Time: O(m * n), Space: O(m * n)"
        },
        {
          "title": "BFS Alternative",
          "hint": "Use multi-source BFS from all Pacific border cells simultaneously, then from all Atlantic border cells simultaneously.",
          "approach": "Initialize two queues with all Pacific and Atlantic border cells respectively. BFS uphill from each, marking visited cells. Finally, intersect the two visited sets. The BFS approach is iterative and avoids recursion stack overflow for large grids.",
          "code": "function pacificAtlantic(heights) {\n  if (!heights || heights.length === 0) return [];\n\n  const rows = heights.length;\n  const cols = heights[0].length;\n  const dirs = [[1,0],[-1,0],[0,1],[0,-1]];\n\n  function bfs(starts) {\n    const reachable = Array.from({ length: rows }, () => Array(cols).fill(false));\n    const queue = [...starts];\n    for (const [r, c] of queue) reachable[r][c] = true;\n\n    while (queue.length > 0) {\n      const [r, c] = queue.shift();\n      for (const [dr, dc] of dirs) {\n        const nr = r + dr, nc = c + dc;\n        if (nr >= 0 && nr < rows && nc >= 0 && nc < cols && !reachable[nr][nc] && heights[nr][nc] >= heights[r][c]) {\n          reachable[nr][nc] = true;\n          queue.push([nr, nc]);\n        }\n      }\n    }\n    return reachable;\n  }\n\n  const pacificStarts = [];\n  const atlanticStarts = [];\n  for (let r = 0; r < rows; r++) {\n    pacificStarts.push([r, 0]);\n    atlanticStarts.push([r, cols - 1]);\n  }\n  for (let c = 0; c < cols; c++) {\n    pacificStarts.push([0, c]);\n    atlanticStarts.push([rows - 1, c]);\n  }\n\n  const pacific = bfs(pacificStarts);\n  const atlantic = bfs(atlanticStarts);\n\n  const result = [];\n  for (let r = 0; r < rows; r++) {\n    for (let c = 0; c < cols; c++) {\n      if (pacific[r][c] && atlantic[r][c]) result.push([r, c]);\n    }\n  }\n  return result;\n}",
          "complexity": "Time: O(m * n), Space: O(m * n)"
        }
      ],
      "testCases": [
        {
          "args": [
            [
              [
                1,
                2,
                2,
                3,
                5
              ],
              [
                3,
                2,
                3,
                4,
                4
              ],
              [
                2,
                4,
                5,
                3,
                1
              ],
              [
                6,
                7,
                1,
                4,
                5
              ],
              [
                5,
                1,
                1,
                2,
                4
              ]
            ]
          ],
          "expected": [
            [
              0,
              4
            ],
            [
              1,
              3
            ],
            [
              1,
              4
            ],
            [
              2,
              2
            ],
            [
              3,
              0
            ],
            [
              3,
              1
            ],
            [
              4,
              0
            ]
          ],
          "description": "Standard 5x5 grid"
        },
        {
          "args": [
            [
              [
                1
              ]
            ]
          ],
          "expected": [
            [
              0,
              0
            ]
          ],
          "description": "Single cell"
        },
        {
          "args": [
            [
              [
                1,
                1
              ],
              [
                1,
                1
              ]
            ]
          ],
          "expected": [
            [
              0,
              0
            ],
            [
              0,
              1
            ],
            [
              1,
              0
            ],
            [
              1,
              1
            ]
          ],
          "description": "All equal heights, all cells reach both"
        }
      ],
      "ankiCards": [
        {
          "id": "pacific-atlantic-reverse",
          "front": "Pacific Atlantic Water Flow: What is the key insight for an efficient solution?",
          "back": "Reverse the flow direction! Instead of checking if each cell can reach both oceans (expensive), start from ocean borders and flow UPHILL.\n\n1. DFS/BFS from Pacific border cells (top row + left col) going to cells with height >= current\n2. DFS/BFS from Atlantic border cells (bottom row + right col) the same way\n3. Cells reachable from BOTH are the answer\n\nTime: O(m*n), Space: O(m*n)"
        },
        {
          "id": "pacific-atlantic-borders",
          "front": "Pacific Atlantic Water Flow: Which borders belong to which ocean?",
          "back": "Pacific Ocean: TOP row and LEFT column\nAtlantic Ocean: BOTTOM row and RIGHT column\n\nMnemonic: Pacific is on the top-left (like the Pacific Northwest on a US map), Atlantic is on the bottom-right."
        }
      ]
    },
    {
      "id": "longest-palindromic-substring",
      "title": "Longest Palindromic Substring",
      "difficulty": "Medium",
      "pattern": "dp-1d",
      "leetcodeUrl": "https://leetcode.com/problems/longest-palindromic-substring/",
      "leetcodeNumber": 5,
      "description": "Given a string `s`, return the longest palindromic substring in `s`.\n\nA **palindrome** is a string that reads the same forward and backward.\n\n**Example 1:**\n```\nInput: s = \"babad\"\nOutput: \"bab\"\nExplanation: \"aba\" is also a valid answer.\n```\n\n**Example 2:**\n```\nInput: s = \"cbbd\"\nOutput: \"bb\"\n```\n\n**Constraints:**\n- 1 <= s.length <= 1000\n- s consists of only digits and English letters.",
      "starterCode": "function longestPalindrome(s) {\n  // Your code here\n  \n}",
      "steps": [
        {
          "title": "Understand the Problem",
          "hint": "A palindrome reads the same forwards and backwards. We need to find the longest one. Brute force checks all substrings (O(n^3)). Can we do better?",
          "approach": "Two efficient approaches: (1) Expand around center - for each possible center (2n-1 centers: each character + each gap between characters), expand outward while characters match. (2) DP where dp[i][j] = true if s[i..j] is a palindrome."
        },
        {
          "title": "Expand Around Center",
          "hint": "A palindrome mirrors around its center. There are 2n-1 possible centers (n single characters + n-1 between-character gaps). For each center, expand outward while the characters on both sides match.",
          "approach": "For each index i, try expanding with i as center (odd-length palindromes) and with i,i+1 as center (even-length palindromes). Track the longest palindrome found.",
          "code": "function longestPalindrome(s) {\n  let start = 0, maxLen = 1;\n\n  function expandAroundCenter(left, right) {\n    while (left >= 0 && right < s.length && s[left] === s[right]) {\n      if (right - left + 1 > maxLen) {\n        start = left;\n        maxLen = right - left + 1;\n      }\n      left--;\n      right++;\n    }\n  }\n\n  for (let i = 0; i < s.length; i++) {\n    expandAroundCenter(i, i);     // odd-length\n    expandAroundCenter(i, i + 1); // even-length\n  }\n\n  return s.substring(start, start + maxLen);\n}",
          "complexity": "Time: O(n^2), Space: O(1)"
        },
        {
          "title": "Dynamic Programming Approach",
          "hint": "dp[i][j] = true if s[i..j] is a palindrome. s[i..j] is a palindrome if s[i] === s[j] AND s[i+1..j-1] is a palindrome.",
          "approach": "Fill the DP table for increasing lengths. Base cases: single chars are palindromes, two equal adjacent chars are palindromes. For longer substrings, check if outer chars match and inner substring is a palindrome.",
          "code": "function longestPalindrome(s) {\n  const n = s.length;\n  const dp = Array.from({ length: n }, () => Array(n).fill(false));\n  let start = 0, maxLen = 1;\n\n  // Every single character is a palindrome\n  for (let i = 0; i < n; i++) dp[i][i] = true;\n\n  // Check for two-character palindromes\n  for (let i = 0; i < n - 1; i++) {\n    if (s[i] === s[i + 1]) {\n      dp[i][i + 1] = true;\n      start = i;\n      maxLen = 2;\n    }\n  }\n\n  // Check for lengths 3 and above\n  for (let len = 3; len <= n; len++) {\n    for (let i = 0; i <= n - len; i++) {\n      const j = i + len - 1;\n      if (s[i] === s[j] && dp[i + 1][j - 1]) {\n        dp[i][j] = true;\n        if (len > maxLen) {\n          start = i;\n          maxLen = len;\n        }\n      }\n    }\n  }\n\n  return s.substring(start, start + maxLen);\n}",
          "complexity": "Time: O(n^2), Space: O(n^2)"
        }
      ],
      "testCases": [
        {
          "args": [
            "babad"
          ],
          "expected": "bab",
          "description": "Standard case (aba also valid)"
        },
        {
          "args": [
            "cbbd"
          ],
          "expected": "bb",
          "description": "Even-length palindrome"
        },
        {
          "args": [
            "a"
          ],
          "expected": "a",
          "description": "Single character"
        }
      ],
      "ankiCards": [
        {
          "id": "longest-palindromic-substring-expand",
          "front": "Longest Palindromic Substring: What is the expand-around-center technique?",
          "back": "For each of 2n-1 centers (n chars + n-1 gaps), expand outward while both sides match:\n\n```\nfor each i:\n  expand(i, i)     // odd-length: 'aba'\n  expand(i, i+1)   // even-length: 'abba'\n```\n\nTime: O(n^2), Space: O(1)\n\nThis is preferred over DP because of O(1) space."
        },
        {
          "id": "longest-palindromic-substring-centers",
          "front": "Longest Palindromic Substring: Why are there 2n-1 centers for palindromes?",
          "back": "A palindrome can be:\n- **Odd-length**: centered on a character (n centers)\n- **Even-length**: centered between two characters (n-1 centers)\n\nTotal: n + (n-1) = 2n-1 centers\n\nExample for 'abc': centers are a, a|b, b, b|c, c = 5 centers"
        }
      ]
    },
    {
      "id": "climbing-stairs",
      "title": "Climbing Stairs",
      "difficulty": "Easy",
      "pattern": "dp-1d",
      "leetcodeUrl": "https://leetcode.com/problems/climbing-stairs/",
      "leetcodeNumber": 70,
      "description": "You are climbing a staircase. It takes `n` steps to reach the top.\n\nEach time you can either climb `1` or `2` steps. In how many distinct ways can you climb to the top?\n\n**Example 1:**\n```\nInput: n = 2\nOutput: 2\nExplanation: There are two ways:\n1. 1 step + 1 step\n2. 2 steps\n```\n\n**Example 2:**\n```\nInput: n = 3\nOutput: 3\nExplanation: There are three ways:\n1. 1 step + 1 step + 1 step\n2. 1 step + 2 steps\n3. 2 steps + 1 step\n```\n\n**Constraints:**\n- 1 <= n <= 45",
      "starterCode": "function climbStairs(n) {\n  // Your code here\n  \n}",
      "steps": [
        {
          "title": "Understand the Problem",
          "hint": "To reach step n, you either came from step n-1 (took 1 step) or step n-2 (took 2 steps). So the number of ways to reach step n is the sum of ways to reach step n-1 and step n-2.",
          "approach": "This is essentially the Fibonacci sequence! dp[n] = dp[n-1] + dp[n-2], with base cases dp[1] = 1, dp[2] = 2. You can solve it with recursion (top-down), tabulation (bottom-up), or space-optimized with just two variables."
        },
        {
          "title": "Recursive with Memoization (Top-Down DP)",
          "hint": "Define a recursive function ways(n) that returns the number of ways to climb n stairs. Use a memo to cache results and avoid recomputation.",
          "approach": "Base cases: ways(1) = 1, ways(2) = 2. Recursive case: ways(n) = ways(n-1) + ways(n-2). Memoize to avoid exponential time.",
          "code": "function climbStairs(n) {\n  const memo = {};\n\n  function dp(i) {\n    if (i <= 2) return i;\n    if (memo[i] !== undefined) return memo[i];\n    memo[i] = dp(i - 1) + dp(i - 2);\n    return memo[i];\n  }\n\n  return dp(n);\n}",
          "complexity": "Time: O(n), Space: O(n)"
        },
        {
          "title": "Space-Optimized Bottom-Up",
          "hint": "Since we only need the last two values, we can use two variables instead of an array.",
          "approach": "Start with prev2 = 1 (1 step), prev1 = 2 (2 steps). Iterate from 3 to n, computing current = prev1 + prev2, then shift the variables. This uses O(1) space.",
          "code": "function climbStairs(n) {\n  if (n <= 2) return n;\n\n  let prev2 = 1; // ways to reach step 1\n  let prev1 = 2; // ways to reach step 2\n\n  for (let i = 3; i <= n; i++) {\n    const current = prev1 + prev2;\n    prev2 = prev1;\n    prev1 = current;\n  }\n\n  return prev1;\n}",
          "complexity": "Time: O(n), Space: O(1)"
        }
      ],
      "testCases": [
        {
          "args": [
            2
          ],
          "expected": 2,
          "description": "2 stairs: (1+1) or (2)"
        },
        {
          "args": [
            3
          ],
          "expected": 3,
          "description": "3 stairs: (1+1+1), (1+2), (2+1)"
        },
        {
          "args": [
            5
          ],
          "expected": 8,
          "description": "5 stairs"
        }
      ],
      "ankiCards": [
        {
          "id": "climbing-stairs-recurrence",
          "front": "Climbing Stairs: What is the recurrence relation and why?",
          "back": "dp[n] = dp[n-1] + dp[n-2]\n\nTo reach step n, you either:\n- Took 1 step from step n-1 (dp[n-1] ways)\n- Took 2 steps from step n-2 (dp[n-2] ways)\n\nBase cases: dp[1] = 1, dp[2] = 2\n\nThis is exactly the Fibonacci sequence!"
        },
        {
          "id": "climbing-stairs-optimization",
          "front": "Climbing Stairs: How do you optimize from O(n) space to O(1)?",
          "back": "Since dp[i] only depends on dp[i-1] and dp[i-2], replace the array with two variables:\n\n```\nlet prev2 = 1, prev1 = 2;\nfor (i = 3..n): current = prev1 + prev2, shift\n```\n\nThis pattern applies to any DP where each state depends on a fixed number of previous states."
        }
      ]
    },
    {
      "id": "decode-ways",
      "title": "Decode Ways",
      "difficulty": "Medium",
      "pattern": "dp-1d",
      "leetcodeUrl": "https://leetcode.com/problems/decode-ways/",
      "leetcodeNumber": 91,
      "description": "A message containing letters from `A-Z` can be **encoded** into numbers using the following mapping:\n\n```\n'A' -> \"1\"\n'B' -> \"2\"\n...\n'Z' -> \"26\"\n```\n\nTo **decode** an encoded message, all the digits must be grouped then mapped back into letters using the reverse of the mapping above (there may be multiple ways). For example, `\"11106\"` can be mapped into:\n- `\"AAJF\"` with the grouping `(1 1 10 6)`\n- `\"KJF\"` with the grouping `(11 10 6)`\n\nNote that the grouping `(1 11 06)` is invalid because `\"06\"` cannot be mapped into `'F'` since `\"6\"` is different from `\"06\"`.\n\nGiven a string `s` containing only digits, return the number of ways to decode it.\n\n**Example 1:**\n```\nInput: s = \"12\"\nOutput: 2\nExplanation: \"12\" could be decoded as \"AB\" (1 2) or \"L\" (12).\n```\n\n**Example 2:**\n```\nInput: s = \"226\"\nOutput: 3\nExplanation: \"226\" could be decoded as \"BZ\" (2 26), \"VF\" (22 6), or \"BBF\" (2 2 6).\n```\n\n**Example 3:**\n```\nInput: s = \"06\"\nOutput: 0\nExplanation: \"06\" cannot be mapped to \"F\" (leading zero). There are no valid decodings.\n```\n\n**Constraints:**\n- 1 <= s.length <= 100\n- s contains only digits and may contain leading zeros.",
      "starterCode": "function numDecodings(s) {\n  // Your code here\n  \n}",
      "steps": [
        {
          "title": "Understand the Problem",
          "hint": "At each position, you can take 1 digit or 2 digits (if they form a valid number 10-26). Leading zeros are invalid. This is similar to Climbing Stairs but with validity constraints.",
          "approach": "Define dp[i] as the number of ways to decode s[0..i-1]. At position i: if s[i-1] is valid (1-9), we can take it as a single digit: dp[i] += dp[i-1]. If s[i-2..i-1] forms a valid two-digit number (10-26), we can take two digits: dp[i] += dp[i-2]."
        },
        {
          "title": "Tabulation DP",
          "hint": "Build dp array from left to right. Handle the '0' character carefully: '0' alone is invalid, but '10' and '20' are valid two-digit codes.",
          "approach": "dp[0] = 1 (empty string base case). dp[1] = 1 if s[0] !== '0', else 0. For i >= 2: check single digit (s[i-1] !== '0') and double digit (10 <= parseInt(s[i-2..i-1]) <= 26).",
          "code": "function numDecodings(s) {\n  if (s[0] === '0') return 0;\n\n  const n = s.length;\n  const dp = new Array(n + 1).fill(0);\n  dp[0] = 1; // base case: empty string\n  dp[1] = 1; // first char is non-zero (checked above)\n\n  for (let i = 2; i <= n; i++) {\n    // Single digit: s[i-1]\n    if (s[i - 1] !== '0') {\n      dp[i] += dp[i - 1];\n    }\n    // Two digits: s[i-2..i-1]\n    const twoDigit = parseInt(s.substring(i - 2, i));\n    if (twoDigit >= 10 && twoDigit <= 26) {\n      dp[i] += dp[i - 2];\n    }\n  }\n\n  return dp[n];\n}",
          "complexity": "Time: O(n), Space: O(n)"
        },
        {
          "title": "Space-Optimized",
          "hint": "Each dp[i] only depends on dp[i-1] and dp[i-2]. Use two variables.",
          "approach": "Replace the dp array with two variables: prev2 and prev1. Update them as we iterate through the string.",
          "code": "function numDecodings(s) {\n  if (s[0] === '0') return 0;\n\n  let prev2 = 1; // dp[i-2]\n  let prev1 = 1; // dp[i-1]\n\n  for (let i = 2; i <= s.length; i++) {\n    let current = 0;\n    if (s[i - 1] !== '0') {\n      current += prev1;\n    }\n    const twoDigit = parseInt(s.substring(i - 2, i));\n    if (twoDigit >= 10 && twoDigit <= 26) {\n      current += prev2;\n    }\n    prev2 = prev1;\n    prev1 = current;\n  }\n\n  return prev1;\n}",
          "complexity": "Time: O(n), Space: O(1)"
        }
      ],
      "testCases": [
        {
          "args": [
            "12"
          ],
          "expected": 2,
          "description": "AB (1,2) or L (12)"
        },
        {
          "args": [
            "226"
          ],
          "expected": 3,
          "description": "BZ, VF, or BBF"
        },
        {
          "args": [
            "06"
          ],
          "expected": 0,
          "description": "Leading zero is invalid"
        }
      ],
      "ankiCards": [
        {
          "id": "decode-ways-recurrence",
          "front": "Decode Ways: What is the recurrence relation and what edge case is critical?",
          "back": "dp[i] = 0\n- If s[i-1] != '0': dp[i] += dp[i-1] (single digit)\n- If 10 <= s[i-2..i-1] <= 26: dp[i] += dp[i-2] (two digits)\n\nCritical edge case: **'0' character**\n- '0' alone is invalid (can't decode)\n- Only valid as part of '10' or '20'\n- If s starts with '0', answer is 0"
        },
        {
          "id": "decode-ways-vs-climbing",
          "front": "How is Decode Ways related to Climbing Stairs?",
          "back": "Both have the same structure: dp[i] = dp[i-1] + dp[i-2]\n\n**Climbing Stairs**: Always can take 1 or 2 steps\n**Decode Ways**: Can take 1 digit IF non-zero, can take 2 digits IF they form 10-26\n\nDecode Ways adds **validity constraints** to each transition. The '0' handling is the key difference."
        }
      ]
    },
    {
      "id": "word-break",
      "title": "Word Break",
      "difficulty": "Medium",
      "pattern": "dp-1d",
      "leetcodeUrl": "https://leetcode.com/problems/word-break/",
      "leetcodeNumber": 139,
      "description": "Given a string `s` and a dictionary of strings `wordDict`, return `true` if `s` can be segmented into a space-separated sequence of one or more dictionary words.\n\nNote that the same word in the dictionary may be reused multiple times in the segmentation.\n\n**Example 1:**\n```\nInput: s = \"leetcode\", wordDict = [\"leet\",\"code\"]\nOutput: true\nExplanation: \"leetcode\" can be segmented as \"leet code\".\n```\n\n**Example 2:**\n```\nInput: s = \"applepenapple\", wordDict = [\"apple\",\"pen\"]\nOutput: true\nExplanation: \"applepenapple\" can be segmented as \"apple pen apple\".\n```\n\n**Example 3:**\n```\nInput: s = \"catsandog\", wordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\nOutput: false\n```\n\n**Constraints:**\n- 1 <= s.length <= 300\n- 1 <= wordDict.length <= 1000\n- 1 <= wordDict[i].length <= 20\n- s and wordDict[i] consist of only lowercase English letters.\n- All the strings of wordDict are unique.",
      "starterCode": "function wordBreak(s, wordDict) {\n  // Your code here\n  \n}",
      "steps": [
        {
          "title": "Understand the Problem",
          "hint": "We need to check if we can partition the string into words that all exist in the dictionary. Think of it as: at each position, is there a word in the dictionary that ends here and the preceding part of the string is also breakable?",
          "approach": "Define dp[i] = true if s[0..i-1] can be segmented using dictionary words. For each position i, check all possible last words: for each j < i, if dp[j] is true and s[j..i-1] is in the dictionary, then dp[i] = true. Base case: dp[0] = true (empty string)."
        },
        {
          "title": "Bottom-Up DP with Set Lookup",
          "hint": "Convert wordDict to a Set for O(1) lookup. For each position i, check all possible split points j where dp[j] is true and s.substring(j, i) is in the set.",
          "approach": "Use a Set for the dictionary. Build dp array bottom-up. For each position i from 1 to n, try every split point j from 0 to i-1.",
          "code": "function wordBreak(s, wordDict) {\n  const wordSet = new Set(wordDict);\n  const n = s.length;\n  const dp = new Array(n + 1).fill(false);\n  dp[0] = true; // empty string is breakable\n\n  for (let i = 1; i <= n; i++) {\n    for (let j = 0; j < i; j++) {\n      if (dp[j] && wordSet.has(s.substring(j, i))) {\n        dp[i] = true;\n        break; // no need to check other j values\n      }\n    }\n  }\n\n  return dp[n];\n}",
          "complexity": "Time: O(n^2 * m) where m is max word length for substring, Space: O(n)"
        },
        {
          "title": "Optimized: Check Only Word-Length Windows",
          "hint": "Instead of checking all split points, only check split points that are word-length away from i.",
          "approach": "For each position i, instead of checking all j from 0 to i-1, only check substrings of lengths that exist in the dictionary. Precompute the set of word lengths to limit the inner loop.",
          "code": "function wordBreak(s, wordDict) {\n  const wordSet = new Set(wordDict);\n  const wordLengths = [...new Set(wordDict.map(w => w.length))];\n  const n = s.length;\n  const dp = new Array(n + 1).fill(false);\n  dp[0] = true;\n\n  for (let i = 1; i <= n; i++) {\n    for (const len of wordLengths) {\n      if (len <= i && dp[i - len] && wordSet.has(s.substring(i - len, i))) {\n        dp[i] = true;\n        break;\n      }\n    }\n  }\n\n  return dp[n];\n}",
          "complexity": "Time: O(n * k * m) where k = unique word lengths, m = max word length, Space: O(n)"
        }
      ],
      "testCases": [
        {
          "args": [
            "leetcode",
            [
              "leet",
              "code"
            ]
          ],
          "expected": true,
          "description": "leet + code"
        },
        {
          "args": [
            "applepenapple",
            [
              "apple",
              "pen"
            ]
          ],
          "expected": true,
          "description": "apple + pen + apple (reuse words)"
        },
        {
          "args": [
            "catsandog",
            [
              "cats",
              "dog",
              "sand",
              "and",
              "cat"
            ]
          ],
          "expected": false,
          "description": "Cannot be fully segmented"
        }
      ],
      "ankiCards": [
        {
          "id": "word-break-recurrence",
          "front": "Word Break: What is the DP recurrence?",
          "back": "dp[i] = true if there exists some j where:\n- dp[j] is true (s[0..j-1] is breakable)\n- s[j..i-1] is in the dictionary\n\nBase case: dp[0] = true (empty string)\nAnswer: dp[n]\n\nTime: O(n^2 * m), Space: O(n)\n\nOptimization: only check j values at distances matching word lengths in the dictionary."
        },
        {
          "id": "word-break-tips",
          "front": "Word Break: What are common pitfalls and optimizations?",
          "back": "Pitfalls:\n- Don't use greedy (longest/shortest match first): fails on cases like 'catsandog'\n- String operations (substring) can be expensive\n\nOptimizations:\n1. Use a Set for O(1) dictionary lookup\n2. Only check substring lengths that exist in dictionary\n3. Break early once dp[i] = true\n4. Can use Trie for prefix matching in more complex variants"
        }
      ]
    },
    {
      "id": "maximum-product-subarray",
      "title": "Maximum Product Subarray",
      "difficulty": "Medium",
      "pattern": "dp-1d",
      "leetcodeUrl": "https://leetcode.com/problems/maximum-product-subarray/",
      "leetcodeNumber": 152,
      "description": "Given an integer array `nums`, find a subarray that has the largest product, and return the product.\n\nThe test cases are generated so that the answer will fit in a **32-bit** integer.\n\nA **subarray** is a contiguous non-empty sequence of elements within an array.\n\n**Example 1:**\n```\nInput: nums = [2,3,-2,4]\nOutput: 6\nExplanation: [2,3] has the largest product 6.\n```\n\n**Example 2:**\n```\nInput: nums = [-2,0,-1]\nOutput: 0\nExplanation: The result cannot be 2 because [-2,-1] is not a subarray (not contiguous through 0).\n```\n\n**Constraints:**\n- 1 <= nums.length <= 2 * 10^4\n- -10 <= nums[i] <= 10\n- The product of any subarray of nums is guaranteed to fit in a 32-bit integer.",
      "starterCode": "function maxProduct(nums) {\n  // Your code here\n  \n}",
      "steps": [
        {
          "title": "Understand the Problem",
          "hint": "Unlike maximum subarray sum (Kadane's), products are tricky because a negative times a negative becomes positive. So a very negative product can become the maximum if multiplied by another negative number.",
          "approach": "We need to track both the maximum AND minimum product ending at each position. The minimum product (most negative) can become the maximum when multiplied by a negative number. At each position: new max = max(num, maxSoFar * num, minSoFar * num), new min = min(num, maxSoFar * num, minSoFar * num)."
        },
        {
          "title": "Track Min and Max Products",
          "hint": "At each element, the maximum product subarray ending here is either: the element itself (start fresh), previous max * current (extend positive), or previous min * current (two negatives make positive).",
          "approach": "Maintain curMax and curMin. For each number, compute the three candidates and update curMax and curMin. Track the global maximum.",
          "code": "function maxProduct(nums) {\n  let result = nums[0];\n  let curMax = nums[0];\n  let curMin = nums[0];\n\n  for (let i = 1; i < nums.length; i++) {\n    // If current number is negative, swapping max and min\n    // before multiplication gives correct results\n    if (nums[i] < 0) {\n      [curMax, curMin] = [curMin, curMax];\n    }\n\n    curMax = Math.max(nums[i], curMax * nums[i]);\n    curMin = Math.min(nums[i], curMin * nums[i]);\n\n    result = Math.max(result, curMax);\n  }\n\n  return result;\n}",
          "complexity": "Time: O(n), Space: O(1)"
        },
        {
          "title": "Alternative: Three-Way Max/Min",
          "hint": "Compute all three candidates explicitly without the swap trick.",
          "approach": "For each element, compute all three possible products (element alone, element * prevMax, element * prevMin) and pick the max and min from them.",
          "code": "function maxProduct(nums) {\n  let result = nums[0];\n  let prevMax = nums[0];\n  let prevMin = nums[0];\n\n  for (let i = 1; i < nums.length; i++) {\n    const candidates = [nums[i], prevMax * nums[i], prevMin * nums[i]];\n    const curMax = Math.max(...candidates);\n    const curMin = Math.min(...candidates);\n    result = Math.max(result, curMax);\n    prevMax = curMax;\n    prevMin = curMin;\n  }\n\n  return result;\n}",
          "complexity": "Time: O(n), Space: O(1)"
        }
      ],
      "testCases": [
        {
          "args": [
            [
              2,
              3,
              -2,
              4
            ]
          ],
          "expected": 6,
          "description": "Subarray [2,3]"
        },
        {
          "args": [
            [
              -2,
              0,
              -1
            ]
          ],
          "expected": 0,
          "description": "Zero breaks the subarray"
        },
        {
          "args": [
            [
              -2,
              3,
              -4
            ]
          ],
          "expected": 24,
          "description": "Two negatives: [-2,3,-4] = 24"
        }
      ],
      "ankiCards": [
        {
          "id": "max-product-subarray-key-insight",
          "front": "Maximum Product Subarray: Why do you need to track both min and max?",
          "back": "Because a **negative * negative = positive**!\n\nThe most negative product so far can become the most positive when multiplied by a negative number.\n\nAt each step, compute:\n- curMax = max(num, prevMax * num, prevMin * num)\n- curMin = min(num, prevMax * num, prevMin * num)\n\nThis handles all cases: positive chains, negative flips, and fresh starts."
        },
        {
          "id": "max-product-subarray-vs-sum",
          "front": "How does Max Product Subarray differ from Kadane's (Max Sum Subarray)?",
          "back": "**Max Sum (Kadane's)**: Only track max. curMax = max(num, curMax + num)\n\n**Max Product**: Track BOTH max AND min because:\n1. Negative * negative = positive\n2. A large negative min can flip to a large positive max\n\nBoth are O(n) time, O(1) space, but product needs two running values instead of one."
        }
      ]
    },
    {
      "id": "house-robber",
      "title": "House Robber",
      "difficulty": "Medium",
      "pattern": "dp-1d",
      "leetcodeUrl": "https://leetcode.com/problems/house-robber/",
      "leetcodeNumber": 198,
      "description": "You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected and **it will automatically contact the police if two adjacent houses were broken into on the same night**.\n\nGiven an integer array `nums` representing the amount of money of each house, return the maximum amount of money you can rob tonight **without alerting the police**.\n\n**Example 1:**\n```\nInput: nums = [1,2,3,1]\nOutput: 4\nExplanation: Rob house 1 (money = 1) and house 3 (money = 3). Total = 1 + 3 = 4.\n```\n\n**Example 2:**\n```\nInput: nums = [2,7,9,3,1]\nOutput: 12\nExplanation: Rob house 1 (money = 2), house 3 (money = 9) and house 5 (money = 1). Total = 2 + 9 + 1 = 12.\n```\n\n**Constraints:**\n- 1 <= nums.length <= 100\n- 0 <= nums[i] <= 400",
      "starterCode": "function rob(nums) {\n  // Your code here\n  \n}",
      "steps": [
        {
          "title": "Understand the Problem",
          "hint": "At each house, you have two choices: rob it (and skip the previous house) or skip it (and take whatever was best up to the previous house). This is a classic decision-at-each-step DP problem.",
          "approach": "Define dp[i] as the maximum money you can rob from houses 0 to i. At house i, either rob it (nums[i] + dp[i-2]) or skip it (dp[i-1]). So dp[i] = max(dp[i-1], nums[i] + dp[i-2])."
        },
        {
          "title": "Tabulation DP",
          "hint": "Build a dp array where dp[i] = max money robbing from houses 0..i. Fill it bottom-up.",
          "approach": "Base cases: dp[0] = nums[0], dp[1] = max(nums[0], nums[1]). For each subsequent house: dp[i] = max(dp[i-1], nums[i] + dp[i-2]).",
          "code": "function rob(nums) {\n  if (nums.length === 1) return nums[0];\n\n  const dp = new Array(nums.length);\n  dp[0] = nums[0];\n  dp[1] = Math.max(nums[0], nums[1]);\n\n  for (let i = 2; i < nums.length; i++) {\n    dp[i] = Math.max(dp[i - 1], nums[i] + dp[i - 2]);\n  }\n\n  return dp[nums.length - 1];\n}",
          "complexity": "Time: O(n), Space: O(n)"
        },
        {
          "title": "Space-Optimized",
          "hint": "Since each dp[i] only depends on dp[i-1] and dp[i-2], use two variables instead of an array.",
          "approach": "Track prev2 (dp[i-2]) and prev1 (dp[i-1]). At each step, compute current = max(prev1, nums[i] + prev2), then shift variables.",
          "code": "function rob(nums) {\n  let prev2 = 0; // dp[i-2]\n  let prev1 = 0; // dp[i-1]\n\n  for (const num of nums) {\n    const current = Math.max(prev1, num + prev2);\n    prev2 = prev1;\n    prev1 = current;\n  }\n\n  return prev1;\n}",
          "complexity": "Time: O(n), Space: O(1)"
        }
      ],
      "testCases": [
        {
          "args": [
            [
              1,
              2,
              3,
              1
            ]
          ],
          "expected": 4,
          "description": "Rob houses 0 and 2"
        },
        {
          "args": [
            [
              2,
              7,
              9,
              3,
              1
            ]
          ],
          "expected": 12,
          "description": "Rob houses 0, 2, and 4"
        },
        {
          "args": [
            [
              5
            ]
          ],
          "expected": 5,
          "description": "Single house"
        }
      ],
      "ankiCards": [
        {
          "id": "house-robber-recurrence",
          "front": "House Robber: What is the recurrence relation?",
          "back": "dp[i] = max(dp[i-1], nums[i] + dp[i-2])\n\nAt house i, choose the better option:\n- **Skip** house i: best from houses 0..i-1 = dp[i-1]\n- **Rob** house i: nums[i] + best from houses 0..i-2 = nums[i] + dp[i-2]\n\nBase: dp[0] = nums[0], dp[1] = max(nums[0], nums[1])"
        },
        {
          "id": "house-robber-pattern",
          "front": "House Robber: What general DP pattern does this problem follow?",
          "back": "The **include/exclude** pattern:\n- At each element, decide to include it (take value + skip previous) or exclude it (take previous best)\n- dp[i] = max(exclude, include) = max(dp[i-1], val[i] + dp[i-2])\n\nThis pattern appears in many problems: max non-adjacent sum, delete & earn, etc.\n\nCan be space-optimized to O(1) since we only need two previous values."
        }
      ]
    },
    {
      "id": "house-robber-ii",
      "title": "House Robber II",
      "difficulty": "Medium",
      "pattern": "dp-1d",
      "leetcodeUrl": "https://leetcode.com/problems/house-robber-ii/",
      "leetcodeNumber": 213,
      "description": "You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed. All houses at this place are **arranged in a circle**. That means the first house is the neighbor of the last one. Meanwhile, adjacent houses have a security system connected, and it will automatically contact the police if two adjacent houses were broken into on the same night.\n\nGiven an integer array `nums` representing the amount of money of each house, return the maximum amount of money you can rob tonight **without alerting the police**.\n\n**Example 1:**\n```\nInput: nums = [2,3,2]\nOutput: 3\nExplanation: You cannot rob house 0 and house 2 (adjacent in circle). Rob house 1 = 3.\n```\n\n**Example 2:**\n```\nInput: nums = [1,2,3,1]\nOutput: 4\nExplanation: Rob house 0 (1) + house 2 (3) = 4.\n```\n\n**Example 3:**\n```\nInput: nums = [1,2,3]\nOutput: 3\n```\n\n**Constraints:**\n- 1 <= nums.length <= 100\n- 0 <= nums[i] <= 1000",
      "starterCode": "function rob(nums) {\n  // Your code here\n  \n}",
      "steps": [
        {
          "title": "Understand the Problem",
          "hint": "This is House Robber I but the houses form a circle, meaning the first and last houses are adjacent. You cannot rob both. How can you reduce this to the original problem?",
          "approach": "Since house 0 and house n-1 are adjacent, you can never rob both. So break it into two subproblems: (1) Rob from houses 0 to n-2 (exclude last), (2) Rob from houses 1 to n-1 (exclude first). The answer is the maximum of these two."
        },
        {
          "title": "Reduce to House Robber I",
          "hint": "Run the House Robber I algorithm twice: once on nums[0..n-2] and once on nums[1..n-1]. Return the max.",
          "approach": "Write a helper function that solves the linear House Robber problem. Call it twice with different subarrays. This elegantly handles the circular constraint.",
          "code": "function rob(nums) {\n  if (nums.length === 1) return nums[0];\n  if (nums.length === 2) return Math.max(nums[0], nums[1]);\n\n  function robLinear(houses) {\n    let prev2 = 0, prev1 = 0;\n    for (const h of houses) {\n      const current = Math.max(prev1, h + prev2);\n      prev2 = prev1;\n      prev1 = current;\n    }\n    return prev1;\n  }\n\n  // Exclude last house OR exclude first house\n  return Math.max(\n    robLinear(nums.slice(0, nums.length - 1)),\n    robLinear(nums.slice(1))\n  );\n}",
          "complexity": "Time: O(n), Space: O(n) due to slice (can be O(1) with index bounds)"
        },
        {
          "title": "Space-Optimized with Index Bounds",
          "hint": "Instead of slicing arrays, pass start and end indices to the helper function.",
          "approach": "Avoid creating new arrays by passing index boundaries. The helper function iterates from start to end using the original array.",
          "code": "function rob(nums) {\n  if (nums.length === 1) return nums[0];\n  if (nums.length === 2) return Math.max(nums[0], nums[1]);\n\n  function robRange(start, end) {\n    let prev2 = 0, prev1 = 0;\n    for (let i = start; i <= end; i++) {\n      const current = Math.max(prev1, nums[i] + prev2);\n      prev2 = prev1;\n      prev1 = current;\n    }\n    return prev1;\n  }\n\n  return Math.max(\n    robRange(0, nums.length - 2),\n    robRange(1, nums.length - 1)\n  );\n}",
          "complexity": "Time: O(n), Space: O(1)"
        }
      ],
      "testCases": [
        {
          "args": [
            [
              2,
              3,
              2
            ]
          ],
          "expected": 3,
          "description": "Circular: cannot rob first and last"
        },
        {
          "args": [
            [
              1,
              2,
              3,
              1
            ]
          ],
          "expected": 4,
          "description": "Rob house 0 and house 2"
        },
        {
          "args": [
            [
              1,
              2,
              3
            ]
          ],
          "expected": 3,
          "description": "Rob only house 2"
        }
      ],
      "ankiCards": [
        {
          "id": "house-robber-ii-reduction",
          "front": "House Robber II: How do you handle the circular arrangement?",
          "back": "Break into two linear subproblems:\n1. Houses 0 to n-2 (include first, exclude last)\n2. Houses 1 to n-1 (exclude first, include last)\n\nAnswer = max(subproblem1, subproblem2)\n\nThis works because you can never rob both house 0 and house n-1 (they're adjacent in the circle)."
        },
        {
          "id": "house-robber-ii-pattern",
          "front": "What is the general technique for converting circular DP to linear DP?",
          "back": "When items form a circle where first and last are adjacent:\n1. Run the linear algorithm on elements [0..n-2]\n2. Run the linear algorithm on elements [1..n-1]\n3. Take the max/min of both results\n\nThis pattern works because you break the circular dependency by ensuring the first and last elements are never both included."
        }
      ]
    },
    {
      "id": "longest-increasing-subsequence",
      "title": "Longest Increasing Subsequence",
      "difficulty": "Medium",
      "pattern": "dp-1d",
      "leetcodeUrl": "https://leetcode.com/problems/longest-increasing-subsequence/",
      "leetcodeNumber": 300,
      "description": "Given an integer array `nums`, return the length of the longest **strictly increasing** subsequence.\n\nA **subsequence** is an array that can be derived from another array by deleting some or no elements without changing the order of the remaining elements.\n\n**Example 1:**\n```\nInput: nums = [10,9,2,5,3,7,101,18]\nOutput: 4\nExplanation: The longest increasing subsequence is [2,3,7,101], length 4.\n```\n\n**Example 2:**\n```\nInput: nums = [0,1,0,3,2,3]\nOutput: 4\n```\n\n**Example 3:**\n```\nInput: nums = [7,7,7,7,7,7,7]\nOutput: 1\n```\n\n**Constraints:**\n- 1 <= nums.length <= 2500\n- -10^4 <= nums[i] <= 10^4",
      "starterCode": "function lengthOfLIS(nums) {\n  // Your code here\n  \n}",
      "steps": [
        {
          "title": "Understand the Problem",
          "hint": "A subsequence is NOT a subarray: elements don't need to be contiguous, but they must maintain their relative order. We want the longest one that is strictly increasing.",
          "approach": "Two approaches: (1) O(n^2) DP: dp[i] = length of longest increasing subsequence ending at index i. For each i, check all j < i where nums[j] < nums[i]. (2) O(n log n) patience sorting with binary search."
        },
        {
          "title": "O(n^2) DP Approach",
          "hint": "dp[i] = length of LIS ending at index i. For each i, check all previous elements j < i. If nums[j] < nums[i], then dp[i] = max(dp[i], dp[j] + 1).",
          "approach": "Initialize all dp[i] = 1 (each element is a subsequence of length 1). For each pair (j, i) where j < i and nums[j] < nums[i], try extending j's subsequence. Answer is max(dp).",
          "code": "function lengthOfLIS(nums) {\n  const n = nums.length;\n  const dp = new Array(n).fill(1);\n\n  for (let i = 1; i < n; i++) {\n    for (let j = 0; j < i; j++) {\n      if (nums[j] < nums[i]) {\n        dp[i] = Math.max(dp[i], dp[j] + 1);\n      }\n    }\n  }\n\n  return Math.max(...dp);\n}",
          "complexity": "Time: O(n^2), Space: O(n)"
        },
        {
          "title": "O(n log n) Binary Search (Patience Sorting)",
          "hint": "Maintain a 'tails' array where tails[i] is the smallest possible tail element for an increasing subsequence of length i+1. Use binary search to find the position to insert/replace.",
          "approach": "Iterate through nums. For each number, binary search in 'tails' for the first element >= num. If found, replace it (we found a smaller tail for that length). If not found, append (we extended the longest subsequence). The length of 'tails' is the LIS length.",
          "code": "function lengthOfLIS(nums) {\n  const tails = [];\n\n  for (const num of nums) {\n    let lo = 0, hi = tails.length;\n    while (lo < hi) {\n      const mid = (lo + hi) >> 1;\n      if (tails[mid] < num) lo = mid + 1;\n      else hi = mid;\n    }\n    tails[lo] = num;\n  }\n\n  return tails.length;\n}",
          "complexity": "Time: O(n log n), Space: O(n)"
        }
      ],
      "testCases": [
        {
          "args": [
            [
              10,
              9,
              2,
              5,
              3,
              7,
              101,
              18
            ]
          ],
          "expected": 4,
          "description": "LIS: [2, 3, 7, 101]"
        },
        {
          "args": [
            [
              0,
              1,
              0,
              3,
              2,
              3
            ]
          ],
          "expected": 4,
          "description": "LIS: [0, 1, 2, 3]"
        },
        {
          "args": [
            [
              7,
              7,
              7,
              7,
              7,
              7,
              7
            ]
          ],
          "expected": 1,
          "description": "All same elements, strictly increasing means length 1"
        }
      ],
      "ankiCards": [
        {
          "id": "lis-dp-approach",
          "front": "Longest Increasing Subsequence: What is the O(n^2) DP approach?",
          "back": "dp[i] = length of LIS ending at index i\n\nRecurrence:\n```\nfor each i:\n  for each j < i:\n    if nums[j] < nums[i]:\n      dp[i] = max(dp[i], dp[j] + 1)\n```\n\nBase: all dp[i] = 1\nAnswer: max(dp)\n\nTime: O(n^2), Space: O(n)"
        },
        {
          "id": "lis-binary-search",
          "front": "Longest Increasing Subsequence: How does the O(n log n) patience sorting work?",
          "back": "Maintain a 'tails' array: tails[i] = smallest tail element for IS of length i+1.\n\nFor each num:\n- Binary search for first element >= num in tails\n- If found at index j: replace tails[j] = num (smaller tail is better)\n- If not found: append num (new longest subsequence)\n\nAnswer: tails.length\n\nKey insight: tails is always sorted, enabling binary search.\nNote: tails does NOT contain the actual LIS, just its length."
        }
      ]
    },
    {
      "id": "coin-change",
      "title": "Coin Change",
      "difficulty": "Medium",
      "pattern": "dp-1d",
      "leetcodeUrl": "https://leetcode.com/problems/coin-change/",
      "leetcodeNumber": 322,
      "description": "You are given an integer array `coins` representing coins of different denominations and an integer `amount` representing a total amount of money.\n\nReturn the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return `-1`.\n\nYou may assume that you have an infinite number of each kind of coin.\n\n**Example 1:**\n```\nInput: coins = [1,5,10,25], amount = 30\nOutput: 2\nExplanation: 5 + 25 = 30, 2 coins.\n```\n\n**Example 2:**\n```\nInput: coins = [2], amount = 3\nOutput: -1\nExplanation: Cannot make 3 with only 2-cent coins.\n```\n\n**Example 3:**\n```\nInput: coins = [1], amount = 0\nOutput: 0\n```\n\n**Constraints:**\n- 1 <= coins.length <= 12\n- 1 <= coins[i] <= 2^31 - 1\n- 0 <= amount <= 10^4",
      "starterCode": "function coinChange(coins, amount) {\n  // Your code here\n  \n}",
      "steps": [
        {
          "title": "Understand the Problem",
          "hint": "This is a classic unbounded knapsack / minimum coins problem. For each sub-amount, we want the minimum coins needed. Greedy doesn't always work (e.g., coins [1,3,4], amount 6: greedy gives 4+1+1=3 coins, but 3+3=2 coins is optimal).",
          "approach": "Define dp[i] as the minimum number of coins needed to make amount i. For each amount i, try every coin c: if c <= i, then dp[i] = min(dp[i], dp[i-c] + 1). Base case: dp[0] = 0. Initialize all other dp values to Infinity (unreachable)."
        },
        {
          "title": "Top-Down DP (Memoization)",
          "hint": "Recursively find the min coins for each amount, caching results.",
          "approach": "Define a recursive function that tries subtracting each coin denomination and returns the minimum coins. Memoize results for each amount.",
          "code": "function coinChange(coins, amount) {\n  const memo = new Map();\n\n  function dp(remaining) {\n    if (remaining === 0) return 0;\n    if (remaining < 0) return Infinity;\n    if (memo.has(remaining)) return memo.get(remaining);\n\n    let minCoins = Infinity;\n    for (const coin of coins) {\n      const result = dp(remaining - coin);\n      minCoins = Math.min(minCoins, result + 1);\n    }\n\n    memo.set(remaining, minCoins);\n    return minCoins;\n  }\n\n  const result = dp(amount);\n  return result === Infinity ? -1 : result;\n}",
          "complexity": "Time: O(amount * coins.length), Space: O(amount)"
        },
        {
          "title": "Bottom-Up DP (Tabulation)",
          "hint": "Build a dp array from 0 to amount. For each sub-amount, try every coin.",
          "approach": "Create dp array of size amount+1, initialized to Infinity except dp[0] = 0. For each amount i from 1 to amount, for each coin c, if c <= i and dp[i-c] + 1 < dp[i], update dp[i].",
          "code": "function coinChange(coins, amount) {\n  const dp = new Array(amount + 1).fill(Infinity);\n  dp[0] = 0;\n\n  for (let i = 1; i <= amount; i++) {\n    for (const coin of coins) {\n      if (coin <= i && dp[i - coin] + 1 < dp[i]) {\n        dp[i] = dp[i - coin] + 1;\n      }\n    }\n  }\n\n  return dp[amount] === Infinity ? -1 : dp[amount];\n}",
          "complexity": "Time: O(amount * coins.length), Space: O(amount)"
        }
      ],
      "testCases": [
        {
          "args": [
            [
              1,
              5,
              10,
              25
            ],
            30
          ],
          "expected": 2,
          "description": "25 + 5 = 30"
        },
        {
          "args": [
            [
              2
            ],
            3
          ],
          "expected": -1,
          "description": "Impossible to make 3 with coin 2"
        },
        {
          "args": [
            [
              1
            ],
            0
          ],
          "expected": 0,
          "description": "Zero amount needs zero coins"
        }
      ],
      "ankiCards": [
        {
          "id": "coin-change-recurrence",
          "front": "Coin Change: What is the recurrence relation and why doesn't greedy work?",
          "back": "dp[i] = min(dp[i - coin] + 1) for each coin <= i\nBase: dp[0] = 0, all others = Infinity\n\nGreedy fails because taking the largest coin first isn't always optimal.\nExample: coins [1,3,4], amount 6\n- Greedy: 4+1+1 = 3 coins\n- Optimal: 3+3 = 2 coins\n\nDP considers all possibilities."
        },
        {
          "id": "coin-change-pattern",
          "front": "Coin Change: What DP pattern is this and what similar problems exist?",
          "back": "This is the **unbounded knapsack** pattern (can use each item unlimited times).\n\nSimilar problems:\n- Coin Change II (count ways instead of min coins)\n- Perfect Squares (coins are 1,4,9,16...)\n- Minimum cost for tickets\n\nKey difference from 0/1 knapsack: items can be reused, so dp[i-coin] (not dp[i-1][...])."
        }
      ]
    },
    {
      "id": "palindromic-substrings",
      "title": "Palindromic Substrings",
      "difficulty": "Medium",
      "pattern": "dp-1d",
      "leetcodeUrl": "https://leetcode.com/problems/palindromic-substrings/",
      "leetcodeNumber": 647,
      "description": "Given a string `s`, return the number of **palindromic substrings** in it.\n\nA string is a palindrome when it reads the same backward as forward. A substring is a contiguous sequence of characters within the string.\n\n**Example 1:**\n```\nInput: s = \"abc\"\nOutput: 3\nExplanation: Three palindromic substrings: \"a\", \"b\", \"c\".\n```\n\n**Example 2:**\n```\nInput: s = \"aaa\"\nOutput: 6\nExplanation: Six palindromic substrings: \"a\", \"a\", \"a\", \"aa\", \"aa\", \"aaa\".\n```\n\n**Constraints:**\n- 1 <= s.length <= 1000\n- s consists of lowercase English letters.",
      "starterCode": "function countSubstrings(s) {\n  // Your code here\n  \n}",
      "steps": [
        {
          "title": "Understand the Problem",
          "hint": "Count ALL palindromic substrings, not just distinct ones. Every single character is a palindrome. This is closely related to Longest Palindromic Substring but we count instead of track max length.",
          "approach": "We can use the same expand-around-center technique from Longest Palindromic Substring, but instead of tracking the longest, we count every palindrome we find during expansion."
        },
        {
          "title": "Expand Around Center (Count)",
          "hint": "For each of 2n-1 centers, expand and count each valid palindrome found.",
          "approach": "For each center, expand outward. Each time the expansion succeeds (characters match), that's one more palindromic substring. Sum up all the counts.",
          "code": "function countSubstrings(s) {\n  let count = 0;\n\n  function expandAroundCenter(left, right) {\n    while (left >= 0 && right < s.length && s[left] === s[right]) {\n      count++;\n      left--;\n      right++;\n    }\n  }\n\n  for (let i = 0; i < s.length; i++) {\n    expandAroundCenter(i, i);     // odd-length\n    expandAroundCenter(i, i + 1); // even-length\n  }\n\n  return count;\n}",
          "complexity": "Time: O(n^2), Space: O(1)"
        },
        {
          "title": "DP Approach",
          "hint": "Use a 2D DP table where dp[i][j] is true if s[i..j] is a palindrome. Count all true entries.",
          "approach": "Same DP as Longest Palindromic Substring, but count all dp[i][j] = true entries instead of finding the max length.",
          "code": "function countSubstrings(s) {\n  const n = s.length;\n  const dp = Array.from({ length: n }, () => Array(n).fill(false));\n  let count = 0;\n\n  // Single characters\n  for (let i = 0; i < n; i++) {\n    dp[i][i] = true;\n    count++;\n  }\n\n  // Two characters\n  for (let i = 0; i < n - 1; i++) {\n    if (s[i] === s[i + 1]) {\n      dp[i][i + 1] = true;\n      count++;\n    }\n  }\n\n  // Lengths 3+\n  for (let len = 3; len <= n; len++) {\n    for (let i = 0; i <= n - len; i++) {\n      const j = i + len - 1;\n      if (s[i] === s[j] && dp[i + 1][j - 1]) {\n        dp[i][j] = true;\n        count++;\n      }\n    }\n  }\n\n  return count;\n}",
          "complexity": "Time: O(n^2), Space: O(n^2)"
        }
      ],
      "testCases": [
        {
          "args": [
            "abc"
          ],
          "expected": 3,
          "description": "No multi-char palindromes, only individual chars"
        },
        {
          "args": [
            "aaa"
          ],
          "expected": 6,
          "description": "Multiple overlapping palindromes"
        },
        {
          "args": [
            "aba"
          ],
          "expected": 4,
          "description": "a, b, a, aba"
        }
      ],
      "ankiCards": [
        {
          "id": "palindromic-substrings-technique",
          "front": "Palindromic Substrings: What is the most space-efficient approach?",
          "back": "Expand around center: for each of 2n-1 centers, expand outward and count each valid expansion.\n\n```javascript\nfor (let i = 0; i < n; i++) {\n  expand(i, i);     // odd\n  expand(i, i + 1); // even\n}\n```\n\nEach successful expansion = 1 more palindrome.\nTime: O(n^2), Space: O(1)"
        },
        {
          "id": "palindromic-substrings-vs-longest",
          "front": "How does Palindromic Substrings (#647) differ from Longest Palindromic Substring (#5)?",
          "back": "Same algorithm, different tracking:\n- **Longest (#5)**: Track start index and max length, return substring\n- **Count (#647)**: Increment counter for each palindrome found\n\nBoth use expand-around-center with O(n^2) time, O(1) space."
        }
      ]
    },
    {
      "id": "unique-paths",
      "title": "Unique Paths",
      "difficulty": "Medium",
      "pattern": "dp-2d",
      "leetcodeUrl": "https://leetcode.com/problems/unique-paths/",
      "leetcodeNumber": 62,
      "description": "There is a robot on an `m x n` grid. The robot is initially located at the top-left corner (i.e., `grid[0][0]`). The robot tries to move to the bottom-right corner (i.e., `grid[m - 1][n - 1]`). The robot can only move either down or right at any point in time.\n\nGiven the two integers `m` and `n`, return the number of possible unique paths that the robot can take to reach the bottom-right corner.\n\n**Example 1:**\n```\nInput: m = 3, n = 7\nOutput: 28\n```\n\n**Example 2:**\n```\nInput: m = 3, n = 2\nOutput: 3\nExplanation: From the top-left corner, there are a total of 3 ways to reach the bottom-right corner:\n1. Right -> Down -> Down\n2. Down -> Down -> Right\n3. Down -> Right -> Down\n```\n\n**Constraints:**\n- 1 <= m, n <= 100",
      "starterCode": "function uniquePaths(m, n) {\n  // Your code here\n  \n}",
      "steps": [
        {
          "title": "Understand the Problem",
          "hint": "The robot can only move right or down. Think about how many choices the robot has at each cell and how that relates to subproblems.",
          "approach": "At any cell (i, j), the robot could have arrived from the cell above (i-1, j) or from the cell to the left (i, j-1). The number of unique paths to (i, j) is the sum of paths to those two cells. This gives us a recurrence relation: dp[i][j] = dp[i-1][j] + dp[i][j-1]. Base case: the first row and first column each have only 1 path (all right or all down)."
        },
        {
          "title": "2D DP Table",
          "hint": "Build a 2D table where dp[i][j] represents the number of unique paths to reach cell (i, j).",
          "approach": "Create an m x n grid. Initialize the first row and first column to 1 (only one way to reach any cell in the top row or left column). Fill in the rest using dp[i][j] = dp[i-1][j] + dp[i][j-1].",
          "code": "function uniquePaths(m, n) {\n  const dp = Array.from({ length: m }, () => Array(n).fill(0));\n  \n  // Base cases: first row and first column\n  for (let i = 0; i < m; i++) dp[i][0] = 1;\n  for (let j = 0; j < n; j++) dp[0][j] = 1;\n  \n  // Fill the table\n  for (let i = 1; i < m; i++) {\n    for (let j = 1; j < n; j++) {\n      dp[i][j] = dp[i - 1][j] + dp[i][j - 1];\n    }\n  }\n  \n  return dp[m - 1][n - 1];\n}",
          "complexity": "Time: O(m * n), Space: O(m * n)"
        },
        {
          "title": "Optimal: Space-Optimized 1D DP",
          "hint": "Notice that each row only depends on the row above it. Can you reduce space to a single row?",
          "approach": "Maintain a single row array. When processing each row, dp[j] already holds the value from the row above. We update dp[j] += dp[j-1] which adds the left neighbor in the current row. This compresses 2D DP into 1D.",
          "code": "function uniquePaths(m, n) {\n  const dp = Array(n).fill(1);\n  \n  for (let i = 1; i < m; i++) {\n    for (let j = 1; j < n; j++) {\n      dp[j] += dp[j - 1];\n    }\n  }\n  \n  return dp[n - 1];\n}",
          "complexity": "Time: O(m * n), Space: O(n)"
        }
      ],
      "testCases": [
        {
          "args": [
            3,
            7
          ],
          "expected": 28,
          "description": "3x7 grid"
        },
        {
          "args": [
            3,
            2
          ],
          "expected": 3,
          "description": "3x2 grid"
        },
        {
          "args": [
            1,
            1
          ],
          "expected": 1,
          "description": "1x1 grid - already at destination"
        }
      ],
      "ankiCards": [
        {
          "id": "unique-paths-recurrence",
          "front": "Unique Paths: What is the recurrence relation for counting unique paths in an m x n grid (robot moves only right or down)?",
          "back": "dp[i][j] = dp[i-1][j] + dp[i][j-1]\n\nBase case: dp[i][0] = 1, dp[0][j] = 1 (first row and first column have only one path each).\n\nThe number of ways to reach any cell equals the sum of ways to reach the cell above and the cell to the left."
        },
        {
          "id": "unique-paths-optimization",
          "front": "Unique Paths: How can you optimize the 2D DP solution from O(m*n) space to O(n) space?",
          "back": "Use a single 1D array of size n. Process row by row. Since dp[i][j] only depends on dp[i-1][j] (already stored in dp[j]) and dp[i][j-1] (dp[j-1] in current iteration), just do dp[j] += dp[j-1] for each row.\n\nTime: O(m*n), Space: O(n)"
        }
      ]
    },
    {
      "id": "longest-common-subsequence",
      "title": "Longest Common Subsequence",
      "difficulty": "Medium",
      "pattern": "dp-2d",
      "leetcodeUrl": "https://leetcode.com/problems/longest-common-subsequence/",
      "leetcodeNumber": 1143,
      "description": "Given two strings `text1` and `text2`, return the length of their longest common subsequence. If there is no common subsequence, return `0`.\n\nA **subsequence** of a string is a new string generated from the original string with some characters (can be none) deleted without changing the relative order of the remaining characters.\n\nFor example, `\"ace\"` is a subsequence of `\"abcde\"`.\n\nA **common subsequence** of two strings is a subsequence that is common to both strings.\n\n**Example 1:**\n```\nInput: text1 = \"abcde\", text2 = \"ace\"\nOutput: 3\nExplanation: The longest common subsequence is \"ace\" and its length is 3.\n```\n\n**Example 2:**\n```\nInput: text1 = \"abc\", text2 = \"abc\"\nOutput: 3\nExplanation: The longest common subsequence is \"abc\" and its length is 3.\n```\n\n**Example 3:**\n```\nInput: text1 = \"abc\", text2 = \"def\"\nOutput: 0\nExplanation: There is no such common subsequence, so the result is 0.\n```\n\n**Constraints:**\n- 1 <= text1.length, text2.length <= 1000\n- text1 and text2 consist of only lowercase English characters.",
      "starterCode": "function longestCommonSubsequence(text1, text2) {\n  // Your code here\n  \n}",
      "steps": [
        {
          "title": "Understand the Problem",
          "hint": "A subsequence maintains relative order but does not need to be contiguous. Think about what happens when you compare characters at the end of both strings.",
          "approach": "If the last characters match, they must be part of the LCS, so we add 1 and look at the remaining prefixes. If they don't match, we try removing the last character from either string and take the maximum. This gives us the recurrence: if text1[i] == text2[j], dp[i][j] = 1 + dp[i-1][j-1]; otherwise dp[i][j] = max(dp[i-1][j], dp[i][j-1])."
        },
        {
          "title": "2D DP Table",
          "hint": "Build a (m+1) x (n+1) table where dp[i][j] is the LCS length of text1[0..i-1] and text2[0..j-1].",
          "approach": "Create a table with an extra row and column of zeros (base case: empty string has LCS of 0). Fill it by comparing characters. If characters match, take diagonal + 1. Otherwise, take the max of top or left cell.",
          "code": "function longestCommonSubsequence(text1, text2) {\n  const m = text1.length;\n  const n = text2.length;\n  const dp = Array.from({ length: m + 1 }, () => Array(n + 1).fill(0));\n  \n  for (let i = 1; i <= m; i++) {\n    for (let j = 1; j <= n; j++) {\n      if (text1[i - 1] === text2[j - 1]) {\n        dp[i][j] = 1 + dp[i - 1][j - 1];\n      } else {\n        dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);\n      }\n    }\n  }\n  \n  return dp[m][n];\n}",
          "complexity": "Time: O(m * n), Space: O(m * n)"
        },
        {
          "title": "Optimal: Space-Optimized DP",
          "hint": "Each row only depends on the previous row. Can you use two 1D arrays instead of a full 2D table?",
          "approach": "Use two arrays: prev and curr. For each row, compute curr from prev. After processing a row, swap them. This reduces space from O(m*n) to O(n).",
          "code": "function longestCommonSubsequence(text1, text2) {\n  const m = text1.length;\n  const n = text2.length;\n  let prev = Array(n + 1).fill(0);\n  let curr = Array(n + 1).fill(0);\n  \n  for (let i = 1; i <= m; i++) {\n    for (let j = 1; j <= n; j++) {\n      if (text1[i - 1] === text2[j - 1]) {\n        curr[j] = 1 + prev[j - 1];\n      } else {\n        curr[j] = Math.max(prev[j], curr[j - 1]);\n      }\n    }\n    [prev, curr] = [curr, prev];\n    curr.fill(0);\n  }\n  \n  return prev[n];\n}",
          "complexity": "Time: O(m * n), Space: O(n)"
        }
      ],
      "testCases": [
        {
          "args": [
            "abcde",
            "ace"
          ],
          "expected": 3,
          "description": "LCS is 'ace'"
        },
        {
          "args": [
            "abc",
            "abc"
          ],
          "expected": 3,
          "description": "Identical strings"
        },
        {
          "args": [
            "abc",
            "def"
          ],
          "expected": 0,
          "description": "No common subsequence"
        }
      ],
      "ankiCards": [
        {
          "id": "lcs-recurrence",
          "front": "Longest Common Subsequence: What is the recurrence relation?",
          "back": "If text1[i-1] == text2[j-1]:\n  dp[i][j] = 1 + dp[i-1][j-1]\nElse:\n  dp[i][j] = max(dp[i-1][j], dp[i][j-1])\n\nBase case: dp[0][j] = dp[i][0] = 0 (empty string has LCS length 0).\n\nTime: O(m*n), Space: O(m*n) or O(n) with optimization."
        },
        {
          "id": "lcs-vs-substring",
          "front": "What is the difference between Longest Common Subsequence and Longest Common Substring?",
          "back": "Subsequence: characters need NOT be contiguous, just in relative order. 'ace' is a subsequence of 'abcde'.\n\nSubstring: characters MUST be contiguous. 'bcd' is a substring of 'abcde'.\n\nFor LCS, when characters don't match we take max(dp[i-1][j], dp[i][j-1]).\nFor Longest Common Substring, when characters don't match we reset dp[i][j] = 0."
        }
      ]
    },
    {
      "id": "maximum-subarray",
      "title": "Maximum Subarray",
      "difficulty": "Medium",
      "pattern": "greedy",
      "leetcodeUrl": "https://leetcode.com/problems/maximum-subarray/",
      "leetcodeNumber": 53,
      "description": "Given an integer array `nums`, find the subarray with the largest sum, and return its sum.\n\nA **subarray** is a contiguous non-empty sequence of elements within an array.\n\n**Example 1:**\n```\nInput: nums = [-2,1,-3,4,-1,2,1,-5,4]\nOutput: 6\nExplanation: The subarray [4,-1,2,1] has the largest sum 6.\n```\n\n**Example 2:**\n```\nInput: nums = [1]\nOutput: 1\nExplanation: The subarray [1] has the largest sum 1.\n```\n\n**Example 3:**\n```\nInput: nums = [5,4,-1,7,8]\nOutput: 23\nExplanation: The subarray [5,4,-1,7,8] has the largest sum 23.\n```\n\n**Constraints:**\n- 1 <= nums.length <= 10^5\n- -10^4 <= nums[i] <= 10^4",
      "starterCode": "function maxSubArray(nums) {\n  // Your code here\n  \n}",
      "steps": [
        {
          "title": "Understand the Problem",
          "hint": "We need a contiguous subarray with the maximum sum. The key insight is: at each position, should we extend the current subarray or start a new one?",
          "approach": "Think greedily. If the running sum becomes negative, it would only hurt any future subarray. At that point, it is better to start fresh from the current element. This is known as Kadane's Algorithm."
        },
        {
          "title": "Brute Force",
          "hint": "Check all possible subarrays and compute their sums.",
          "approach": "Use two nested loops to consider all subarrays. For each starting index i, extend the subarray to each ending index j and track the maximum sum.",
          "code": "function maxSubArray(nums) {\n  let maxSum = -Infinity;\n  \n  for (let i = 0; i < nums.length; i++) {\n    let currentSum = 0;\n    for (let j = i; j < nums.length; j++) {\n      currentSum += nums[j];\n      maxSum = Math.max(maxSum, currentSum);\n    }\n  }\n  \n  return maxSum;\n}",
          "complexity": "Time: O(n^2), Space: O(1)"
        },
        {
          "title": "Optimal: Kadane's Algorithm (Greedy)",
          "hint": "At each element, the maximum subarray ending here is either the element itself or the element added to the previous maximum subarray.",
          "approach": "Maintain a running sum (currentSum). At each element, decide: start a new subarray (just the current element) or extend the previous subarray. currentSum = max(nums[i], currentSum + nums[i]). Track the global maximum across all positions.",
          "code": "function maxSubArray(nums) {\n  let currentSum = nums[0];\n  let maxSum = nums[0];\n  \n  for (let i = 1; i < nums.length; i++) {\n    currentSum = Math.max(nums[i], currentSum + nums[i]);\n    maxSum = Math.max(maxSum, currentSum);\n  }\n  \n  return maxSum;\n}",
          "complexity": "Time: O(n), Space: O(1)"
        }
      ],
      "testCases": [
        {
          "args": [
            [
              -2,
              1,
              -3,
              4,
              -1,
              2,
              1,
              -5,
              4
            ]
          ],
          "expected": 6,
          "description": "Mixed positive and negative values"
        },
        {
          "args": [
            [
              1
            ]
          ],
          "expected": 1,
          "description": "Single element"
        },
        {
          "args": [
            [
              5,
              4,
              -1,
              7,
              8
            ]
          ],
          "expected": 23,
          "description": "Entire array is the max subarray"
        }
      ],
      "ankiCards": [
        {
          "id": "maximum-subarray-kadane",
          "front": "In Maximum Subarray, what is Kadane's algorithm and why does restarting at the current element sometimes become optimal?",
          "back": "Kadane's Algorithm (Greedy):\n\ncurrentSum = max(nums[i], currentSum + nums[i])\nmaxSum = max(maxSum, currentSum)\n\nAt each element, either extend the current subarray or start fresh. If the running sum is negative, starting fresh is always better.\n\nTime: O(n), Space: O(1)"
        },
        {
          "id": "maximum-subarray-key-decision",
          "front": "Maximum Subarray: What is the greedy decision at each step in Kadane's algorithm?",
          "back": "At each element nums[i], decide:\n1. Extend the current subarray: currentSum + nums[i]\n2. Start a new subarray: nums[i]\n\nTake the maximum of these two. If currentSum was negative, nums[i] alone is always >= currentSum + nums[i], so we start fresh."
        }
      ]
    },
    {
      "id": "jump-game",
      "title": "Jump Game",
      "difficulty": "Medium",
      "pattern": "greedy",
      "leetcodeUrl": "https://leetcode.com/problems/jump-game/",
      "leetcodeNumber": 55,
      "description": "You are given an integer array `nums`. You are initially positioned at the array's first index, and each element in the array represents your maximum jump length at that position.\n\nReturn `true` if you can reach the last index, or `false` otherwise.\n\n**Example 1:**\n```\nInput: nums = [2,3,1,1,4]\nOutput: true\nExplanation: Jump 1 step from index 0 to 1, then 3 steps to the last index.\n```\n\n**Example 2:**\n```\nInput: nums = [3,2,1,0,4]\nOutput: false\nExplanation: You will always arrive at index 3 no matter what. Its maximum jump length is 0, so you can never reach the last index.\n```\n\n**Constraints:**\n- 1 <= nums.length <= 10^4\n- 0 <= nums[i] <= 10^5",
      "starterCode": "function canJump(nums) {\n  // Your code here\n  \n}",
      "steps": [
        {
          "title": "Understand the Problem",
          "hint": "Each element tells you the maximum jump length from that position, not the exact jump. You can jump anywhere from 1 to nums[i] steps from position i.",
          "approach": "Think about reachability. If we can reach a position, we can reach any position up to i + nums[i]. We need to determine if the last index is reachable from index 0. A greedy approach works: track the farthest index we can reach as we iterate."
        },
        {
          "title": "DP Approach (Bottom-Up)",
          "hint": "For each index, determine if the last index is reachable. Work backwards from the end.",
          "approach": "Create a boolean array where dp[i] = true if we can reach the last index from position i. dp[n-1] = true (already at the end). For each position from n-2 down to 0, check if any position i+1 to i+nums[i] has dp[j] = true.",
          "code": "function canJump(nums) {\n  const n = nums.length;\n  const dp = Array(n).fill(false);\n  dp[n - 1] = true;\n  \n  for (let i = n - 2; i >= 0; i--) {\n    const farthest = Math.min(i + nums[i], n - 1);\n    for (let j = i + 1; j <= farthest; j++) {\n      if (dp[j]) {\n        dp[i] = true;\n        break;\n      }\n    }\n  }\n  \n  return dp[0];\n}",
          "complexity": "Time: O(n^2), Space: O(n)"
        },
        {
          "title": "Optimal: Greedy (Track Max Reach)",
          "hint": "As you iterate left to right, track the farthest index you can reach. If you ever land on an index beyond your reach, you are stuck.",
          "approach": "Maintain a variable maxReach. Iterate through the array: if the current index i > maxReach, we cannot reach this index, return false. Otherwise, update maxReach = max(maxReach, i + nums[i]). If maxReach >= n-1 at any point, return true.",
          "code": "function canJump(nums) {\n  let maxReach = 0;\n  \n  for (let i = 0; i < nums.length; i++) {\n    if (i > maxReach) return false;\n    maxReach = Math.max(maxReach, i + nums[i]);\n    if (maxReach >= nums.length - 1) return true;\n  }\n  \n  return true;\n}",
          "complexity": "Time: O(n), Space: O(1)"
        }
      ],
      "testCases": [
        {
          "args": [
            [
              2,
              3,
              1,
              1,
              4
            ]
          ],
          "expected": true,
          "description": "Can reach the end"
        },
        {
          "args": [
            [
              3,
              2,
              1,
              0,
              4
            ]
          ],
          "expected": false,
          "description": "Stuck at index 3 with jump length 0"
        },
        {
          "args": [
            [
              0
            ]
          ],
          "expected": true,
          "description": "Single element - already at the end"
        }
      ],
      "ankiCards": [
        {
          "id": "jump-game-greedy",
          "front": "Jump Game: What is the greedy approach to determine if you can reach the last index?",
          "back": "Track the farthest reachable index (maxReach).\n\nFor each index i:\n- If i > maxReach: return false (unreachable)\n- Update maxReach = max(maxReach, i + nums[i])\n- If maxReach >= n-1: return true\n\nTime: O(n), Space: O(1)"
        },
        {
          "id": "jump-game-stuck",
          "front": "Jump Game: When is it impossible to reach the last index?",
          "back": "It is impossible when there exists a 'barrier' of zeros that no previous position can jump over.\n\nExample: [3,2,1,0,4] - indices 0,1,2 can all reach at most index 3, but nums[3]=0, so we can never get past index 3.\n\nThe greedy approach detects this: when i > maxReach, we are at an unreachable position."
        }
      ]
    },
    {
      "id": "merge-intervals",
      "title": "Merge Intervals",
      "difficulty": "Medium",
      "pattern": "intervals",
      "leetcodeUrl": "https://leetcode.com/problems/merge-intervals/",
      "leetcodeNumber": 56,
      "description": "Given an array of `intervals` where `intervals[i] = [starti, endi]`, merge all overlapping intervals, and return an array of the non-overlapping intervals that cover all the intervals in the input.\n\n**Example 1:**\n```\nInput: intervals = [[1,3],[2,6],[8,10],[15,18]]\nOutput: [[1,6],[8,10],[15,18]]\nExplanation: Since intervals [1,3] and [2,6] overlap, merge them into [1,6].\n```\n\n**Example 2:**\n```\nInput: intervals = [[1,4],[4,5]]\nOutput: [[1,5]]\nExplanation: Intervals [1,4] and [4,5] are considered overlapping.\n```\n\n**Constraints:**\n- 1 <= intervals.length <= 10^4\n- intervals[i].length == 2\n- 0 <= starti <= endi <= 10^4",
      "starterCode": "function merge(intervals) {\n  // Your code here\n  \n}",
      "steps": [
        {
          "title": "Understand the Problem",
          "hint": "Intervals may not be sorted. Sorting by start time makes it easy to detect overlaps because overlapping intervals will be adjacent after sorting.",
          "approach": "Sort intervals by their start time. Then iterate through and merge overlapping intervals. Two consecutive intervals overlap if the current interval's start <= the previous interval's end."
        },
        {
          "title": "Brute Force: Compare All Pairs",
          "hint": "Check every pair of intervals for overlap and merge them.",
          "approach": "Repeatedly scan through intervals, merging any overlapping pair, until no more merges are possible. This is inefficient but correct.",
          "code": "function merge(intervals) {\n  // Sort by start time first\n  intervals.sort((a, b) => a[0] - b[0]);\n  const result = [intervals[0]];\n  \n  for (let i = 1; i < intervals.length; i++) {\n    const last = result[result.length - 1];\n    if (intervals[i][0] <= last[1]) {\n      last[1] = Math.max(last[1], intervals[i][1]);\n    } else {\n      result.push(intervals[i]);\n    }\n  }\n  \n  return result;\n}",
          "complexity": "Time: O(n log n), Space: O(n)"
        },
        {
          "title": "Optimal: Sort + Linear Merge",
          "hint": "After sorting by start time, a single pass is enough to merge all overlapping intervals.",
          "approach": "Sort by start time. Initialize result with the first interval. For each subsequent interval: if it overlaps with the last interval in result (start <= lastEnd), extend the end; otherwise, add it as a new interval.",
          "code": "function merge(intervals) {\n  intervals.sort((a, b) => a[0] - b[0]);\n  const merged = [intervals[0]];\n  \n  for (let i = 1; i < intervals.length; i++) {\n    const prev = merged[merged.length - 1];\n    const curr = intervals[i];\n    \n    if (curr[0] <= prev[1]) {\n      // Overlapping - extend the end\n      prev[1] = Math.max(prev[1], curr[1]);\n    } else {\n      // Non-overlapping - add new interval\n      merged.push(curr);\n    }\n  }\n  \n  return merged;\n}",
          "complexity": "Time: O(n log n), Space: O(n)"
        }
      ],
      "testCases": [
        {
          "args": [
            [
              [
                1,
                3
              ],
              [
                2,
                6
              ],
              [
                8,
                10
              ],
              [
                15,
                18
              ]
            ]
          ],
          "expected": [
            [
              1,
              6
            ],
            [
              8,
              10
            ],
            [
              15,
              18
            ]
          ],
          "description": "Multiple merges needed"
        },
        {
          "args": [
            [
              [
                1,
                4
              ],
              [
                4,
                5
              ]
            ]
          ],
          "expected": [
            [
              1,
              5
            ]
          ],
          "description": "Touching intervals merge"
        },
        {
          "args": [
            [
              [
                1,
                4
              ],
              [
                0,
                4
              ]
            ]
          ],
          "expected": [
            [
              0,
              4
            ]
          ],
          "description": "Unsorted input, complete overlap"
        }
      ],
      "ankiCards": [
        {
          "id": "merge-intervals-approach",
          "front": "Merge Intervals: What is the standard approach?",
          "back": "1. Sort intervals by start time: O(n log n)\n2. Initialize result with first interval\n3. For each interval:\n   - If curr.start <= prev.end: merge (prev.end = max(prev.end, curr.end))\n   - Else: add curr to result\n\nTime: O(n log n), Space: O(n)"
        },
        {
          "id": "merge-intervals-why-sort",
          "front": "Merge Intervals: Why is sorting by start time essential?",
          "back": "Sorting ensures that overlapping intervals are adjacent. After sorting, if interval[i] does NOT overlap with the last merged interval, then no subsequent interval will overlap with it either (because all subsequent starts are >= interval[i].start).\n\nThis allows a single linear pass to merge all overlapping intervals."
        }
      ]
    },
    {
      "id": "insert-interval",
      "title": "Insert Interval",
      "difficulty": "Medium",
      "pattern": "intervals",
      "leetcodeUrl": "https://leetcode.com/problems/insert-interval/",
      "leetcodeNumber": 57,
      "description": "You are given an array of non-overlapping intervals `intervals` where `intervals[i] = [starti, endi]` represent the start and the end of the `ith` interval and `intervals` is sorted in ascending order by `starti`. You are also given an interval `newInterval = [start, end]` that represents the start and end of another interval.\n\nInsert `newInterval` into `intervals` such that `intervals` is still sorted in ascending order by `starti` and `intervals` still does not have any overlapping intervals (merge overlapping intervals if necessary).\n\nReturn `intervals` after the insertion.\n\n**Example 1:**\n```\nInput: intervals = [[1,3],[6,9]], newInterval = [2,5]\nOutput: [[1,5],[6,9]]\n```\n\n**Example 2:**\n```\nInput: intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]\nOutput: [[1,2],[3,10],[12,16]]\nExplanation: Because the new interval [4,8] overlaps with [3,5],[6,7],[8,10].\n```\n\n**Constraints:**\n- 0 <= intervals.length <= 10^4\n- intervals[i].length == 2\n- 0 <= starti <= endi <= 10^5\n- intervals is sorted by starti in ascending order.\n- newInterval.length == 2\n- 0 <= start <= end <= 10^5",
      "starterCode": "function insert(intervals, newInterval) {\n  // Your code here\n  \n}",
      "steps": [
        {
          "title": "Understand the Problem",
          "hint": "The intervals are already sorted and non-overlapping. We need to insert a new interval and merge any resulting overlaps. Think of three phases: intervals entirely before the new one, intervals that overlap, and intervals entirely after.",
          "approach": "Iterate through intervals and split into three groups: (1) intervals that end before newInterval starts (no overlap, add as-is), (2) intervals that overlap with newInterval (merge them), and (3) intervals that start after newInterval ends (no overlap, add as-is)."
        },
        {
          "title": "Linear Scan with Merge",
          "hint": "Two intervals [a,b] and [c,d] overlap if a <= d and c <= b. When they overlap, the merged interval is [min(a,c), max(b,d)].",
          "approach": "Use a single pass. First, add all intervals that end before newInterval starts. Then, merge all overlapping intervals with newInterval by expanding its start and end. Finally, add newInterval and all remaining intervals.",
          "code": "function insert(intervals, newInterval) {\n  const result = [];\n  let i = 0;\n  const n = intervals.length;\n  \n  // Add all intervals that come before newInterval\n  while (i < n && intervals[i][1] < newInterval[0]) {\n    result.push(intervals[i]);\n    i++;\n  }\n  \n  // Merge overlapping intervals with newInterval\n  while (i < n && intervals[i][0] <= newInterval[1]) {\n    newInterval[0] = Math.min(newInterval[0], intervals[i][0]);\n    newInterval[1] = Math.max(newInterval[1], intervals[i][1]);\n    i++;\n  }\n  result.push(newInterval);\n  \n  // Add remaining intervals\n  while (i < n) {\n    result.push(intervals[i]);\n    i++;\n  }\n  \n  return result;\n}",
          "complexity": "Time: O(n), Space: O(n)"
        },
        {
          "title": "Optimal: Same Approach (Already Optimal)",
          "hint": "The linear scan approach is already optimal since we must examine every interval at least once.",
          "approach": "The three-phase approach is the optimal solution. We process each interval exactly once. The key conditions are: (1) intervals[i][1] < newInterval[0] means no overlap yet, (2) intervals[i][0] <= newInterval[1] means overlap exists. This is clean and efficient.",
          "code": "function insert(intervals, newInterval) {\n  const result = [];\n  let [newStart, newEnd] = newInterval;\n  let i = 0;\n  \n  // Phase 1: intervals ending before new interval starts\n  while (i < intervals.length && intervals[i][1] < newStart) {\n    result.push(intervals[i++]);\n  }\n  \n  // Phase 2: merge overlapping intervals\n  while (i < intervals.length && intervals[i][0] <= newEnd) {\n    newStart = Math.min(newStart, intervals[i][0]);\n    newEnd = Math.max(newEnd, intervals[i][1]);\n    i++;\n  }\n  result.push([newStart, newEnd]);\n  \n  // Phase 3: intervals starting after new interval ends\n  while (i < intervals.length) {\n    result.push(intervals[i++]);\n  }\n  \n  return result;\n}",
          "complexity": "Time: O(n), Space: O(n)"
        }
      ],
      "testCases": [
        {
          "args": [
            [
              [
                1,
                3
              ],
              [
                6,
                9
              ]
            ],
            [
              2,
              5
            ]
          ],
          "expected": [
            [
              1,
              5
            ],
            [
              6,
              9
            ]
          ],
          "description": "New interval overlaps with one existing interval"
        },
        {
          "args": [
            [
              [
                1,
                2
              ],
              [
                3,
                5
              ],
              [
                6,
                7
              ],
              [
                8,
                10
              ],
              [
                12,
                16
              ]
            ],
            [
              4,
              8
            ]
          ],
          "expected": [
            [
              1,
              2
            ],
            [
              3,
              10
            ],
            [
              12,
              16
            ]
          ],
          "description": "New interval overlaps with multiple intervals"
        },
        {
          "args": [
            [],
            [
              5,
              7
            ]
          ],
          "expected": [
            [
              5,
              7
            ]
          ],
          "description": "Empty intervals list"
        }
      ],
      "ankiCards": [
        {
          "id": "insert-interval-phases",
          "front": "Insert Interval: What are the three phases of the linear scan approach?",
          "back": "Phase 1: Add all intervals that end before newInterval starts (intervals[i][1] < newStart).\n\nPhase 2: Merge all overlapping intervals (intervals[i][0] <= newEnd). Update newStart = min(...), newEnd = max(...).\n\nPhase 3: Add all remaining intervals that start after newInterval ends.\n\nTime: O(n), Space: O(n)"
        },
        {
          "id": "insert-interval-overlap",
          "front": "How do you check if two intervals [a,b] and [c,d] overlap?",
          "back": "Two intervals overlap if and only if: a <= d AND c <= b\n\nEquivalently, they do NOT overlap if: b < c OR d < a (one ends before the other starts).\n\nWhen they overlap, the merged interval is: [min(a,c), max(b,d)]"
        }
      ]
    },
    {
      "id": "meeting-rooms",
      "title": "Meeting Rooms",
      "difficulty": "Easy",
      "pattern": "intervals",
      "leetcodeUrl": "https://leetcode.com/problems/meeting-rooms/",
      "leetcodeNumber": 252,
      "description": "Given an array of meeting time intervals where `intervals[i] = [starti, endi]`, determine if a person could attend all meetings.\n\nA person can attend all meetings if no two meetings overlap.\n\n**Example 1:**\n```\nInput: intervals = [[0,30],[5,10],[15,20]]\nOutput: false\nExplanation: [0,30] and [5,10] overlap, so you cannot attend both.\n```\n\n**Example 2:**\n```\nInput: intervals = [[7,10],[2,4]]\nOutput: true\nExplanation: After sorting: [2,4] and [7,10] do not overlap.\n```\n\n**Example 3:**\n```\nInput: intervals = []\nOutput: true\nExplanation: No meetings, so no conflicts.\n```\n\n**Constraints:**\n- 0 <= intervals.length <= 10^4\n- intervals[i].length == 2\n- 0 <= starti < endi <= 10^6\n\n**Note:** This is a LeetCode Premium problem (#252).",
      "starterCode": "function canAttendMeetings(intervals) {\n  // Your code here\n  \n}",
      "steps": [
        {
          "title": "Understand the Problem",
          "hint": "We need to check if any two meetings overlap. Two meetings [a,b] and [c,d] overlap if one starts before the other ends.",
          "approach": "If we sort the meetings by start time, we only need to check consecutive meetings for overlap. Two consecutive meetings (after sorting) overlap if the current meeting starts before the previous meeting ends."
        },
        {
          "title": "Brute Force: Check All Pairs",
          "hint": "Compare every pair of intervals to check for overlap.",
          "approach": "Use two nested loops to check all pairs. Two intervals [a,b] and [c,d] overlap if a < d and c < b.",
          "code": "function canAttendMeetings(intervals) {\n  for (let i = 0; i < intervals.length; i++) {\n    for (let j = i + 1; j < intervals.length; j++) {\n      if (intervals[i][0] < intervals[j][1] && intervals[j][0] < intervals[i][1]) {\n        return false;\n      }\n    }\n  }\n  return true;\n}",
          "complexity": "Time: O(n^2), Space: O(1)"
        },
        {
          "title": "Optimal: Sort + Linear Scan",
          "hint": "Sort by start time. Then just check if any meeting starts before the previous one ends.",
          "approach": "Sort intervals by start time. Iterate through and check if intervals[i][0] < intervals[i-1][1]. If so, there is an overlap and the person cannot attend all meetings.",
          "code": "function canAttendMeetings(intervals) {\n  if (intervals.length <= 1) return true;\n  \n  intervals.sort((a, b) => a[0] - b[0]);\n  \n  for (let i = 1; i < intervals.length; i++) {\n    if (intervals[i][0] < intervals[i - 1][1]) {\n      return false;\n    }\n  }\n  \n  return true;\n}",
          "complexity": "Time: O(n log n), Space: O(1)"
        }
      ],
      "testCases": [
        {
          "args": [
            [
              [
                0,
                30
              ],
              [
                5,
                10
              ],
              [
                15,
                20
              ]
            ]
          ],
          "expected": false,
          "description": "Overlapping meetings"
        },
        {
          "args": [
            [
              [
                7,
                10
              ],
              [
                2,
                4
              ]
            ]
          ],
          "expected": true,
          "description": "Non-overlapping after sorting"
        },
        {
          "args": [
            []
          ],
          "expected": true,
          "description": "No meetings"
        }
      ],
      "ankiCards": [
        {
          "id": "meeting-rooms-approach",
          "front": "Meeting Rooms: How do you determine if a person can attend all meetings?",
          "back": "1. Sort intervals by start time\n2. Check consecutive pairs: if intervals[i].start < intervals[i-1].end, there is a conflict\n3. Return false if any conflict found, true otherwise\n\nTime: O(n log n), Space: O(1)\n\nKey insight: After sorting by start time, only consecutive intervals can overlap."
        },
        {
          "id": "meeting-rooms-overlap-check",
          "front": "Meeting Rooms: After sorting by start time, what is the overlap condition between consecutive intervals?",
          "back": "After sorting, two consecutive intervals overlap if:\nintervals[i][0] < intervals[i-1][1]\n(current start < previous end)\n\nWe don't need to check intervals[i-1][0] < intervals[i][1] because sorting guarantees intervals[i-1][0] <= intervals[i][0]."
        }
      ]
    },
    {
      "id": "meeting-rooms-ii",
      "title": "Meeting Rooms II",
      "difficulty": "Medium",
      "pattern": "intervals",
      "leetcodeUrl": "https://leetcode.com/problems/meeting-rooms-ii/",
      "leetcodeNumber": 253,
      "description": "Given an array of meeting time intervals `intervals` where `intervals[i] = [starti, endi]`, return the minimum number of conference rooms required.\n\n**Example 1:**\n```\nInput: intervals = [[0,30],[5,10],[15,20]]\nOutput: 2\nExplanation: Meeting [0,30] uses one room the entire time. Meetings [5,10] and [15,20] can share another room since they don't overlap.\n```\n\n**Example 2:**\n```\nInput: intervals = [[7,10],[2,4]]\nOutput: 1\nExplanation: The meetings don't overlap, so only 1 room is needed.\n```\n\n**Example 3:**\n```\nInput: intervals = [[0,5],[5,10],[0,10]]\nOutput: 2\nExplanation: [0,5] and [0,10] overlap, needing 2 rooms. Then [5,10] can reuse the room freed by [0,5].\n```\n\n**Constraints:**\n- 1 <= intervals.length <= 10^4\n- 0 <= starti < endi <= 10^6\n\n**Note:** This is a LeetCode Premium problem (#253).",
      "starterCode": "function minMeetingRooms(intervals) {\n  // Your code here\n  \n}",
      "steps": [
        {
          "title": "Understand the Problem",
          "hint": "The minimum number of rooms needed equals the maximum number of meetings that overlap at any point in time. Think about what happens at each meeting start and end.",
          "approach": "Consider a timeline. When a meeting starts, we need one more room. When a meeting ends, one room is freed. The maximum number of simultaneous meetings at any point is our answer. We can model this using separate sorted arrays of start and end times."
        },
        {
          "title": "Sort + Two Pointers on Events",
          "hint": "Separate start and end times, sort them independently, and use two pointers to simulate the timeline.",
          "approach": "Create two sorted arrays: starts and ends. Use two pointers (s and e). If starts[s] < ends[e], a meeting starts before one ends, so we need another room. Otherwise, a meeting ended, freeing a room. Track the max rooms needed.",
          "code": "function minMeetingRooms(intervals) {\n  const starts = intervals.map(i => i[0]).sort((a, b) => a - b);\n  const ends = intervals.map(i => i[1]).sort((a, b) => a - b);\n  \n  let rooms = 0;\n  let maxRooms = 0;\n  let s = 0;\n  let e = 0;\n  \n  while (s < starts.length) {\n    if (starts[s] < ends[e]) {\n      rooms++;\n      s++;\n    } else {\n      rooms--;\n      e++;\n    }\n    maxRooms = Math.max(maxRooms, rooms);\n  }\n  \n  return maxRooms;\n}",
          "complexity": "Time: O(n log n), Space: O(n)"
        },
        {
          "title": "Optimal: Sweep Line / Event-Based",
          "hint": "Create events for each start (+1) and end (-1), sort them, and sweep through to find the peak overlap.",
          "approach": "Create an event array: +1 for each start time, -1 for each end time. Sort events by time (with ties broken by processing ends before starts). Sweep through and maintain a running count of active meetings. The maximum count is the answer.",
          "code": "function minMeetingRooms(intervals) {\n  const events = [];\n  \n  for (const [start, end] of intervals) {\n    events.push([start, 1]);  // meeting starts\n    events.push([end, -1]);   // meeting ends\n  }\n  \n  // Sort by time; if tied, process ends (-1) before starts (+1)\n  events.sort((a, b) => a[0] - b[0] || a[1] - b[1]);\n  \n  let rooms = 0;\n  let maxRooms = 0;\n  \n  for (const [time, delta] of events) {\n    rooms += delta;\n    maxRooms = Math.max(maxRooms, rooms);\n  }\n  \n  return maxRooms;\n}",
          "complexity": "Time: O(n log n), Space: O(n)"
        }
      ],
      "testCases": [
        {
          "args": [
            [
              [
                0,
                30
              ],
              [
                5,
                10
              ],
              [
                15,
                20
              ]
            ]
          ],
          "expected": 2,
          "description": "Two overlapping meetings need 2 rooms"
        },
        {
          "args": [
            [
              [
                7,
                10
              ],
              [
                2,
                4
              ]
            ]
          ],
          "expected": 1,
          "description": "Non-overlapping meetings need 1 room"
        },
        {
          "args": [
            [
              [
                0,
                5
              ],
              [
                5,
                10
              ],
              [
                0,
                10
              ]
            ]
          ],
          "expected": 2,
          "description": "One meeting spans both others"
        }
      ],
      "ankiCards": [
        {
          "id": "meeting-rooms-ii-two-pointers",
          "front": "In Meeting Rooms II, how does the two-pointer approach over sorted start/end arrays compute the minimum rooms?",
          "back": "1. Extract and sort start times and end times separately\n2. Use pointer s for starts, e for ends\n3. If starts[s] < ends[e]: a meeting starts before one ends -> rooms++, s++\n4. Else: a meeting ends -> rooms--, e++\n5. Track maxRooms throughout\n\nTime: O(n log n), Space: O(n)\n\nKey: We don't need to match which start goes with which end. We only care about the count of concurrent meetings."
        },
        {
          "id": "meeting-rooms-ii-sweep-line",
          "front": "Meeting Rooms II: What is the sweep line / event-based approach?",
          "back": "1. Create events: (time, +1) for starts, (time, -1) for ends\n2. Sort by time (break ties: ends before starts)\n3. Sweep through, maintaining running count\n4. Max count = min rooms needed\n\nWhy process ends before starts on ties? If a meeting ends at time 5 and another starts at time 5, they can share a room.\n\nTime: O(n log n), Space: O(n)"
        }
      ]
    },
    {
      "id": "non-overlapping-intervals",
      "title": "Non-overlapping Intervals",
      "difficulty": "Medium",
      "pattern": "intervals",
      "leetcodeUrl": "https://leetcode.com/problems/non-overlapping-intervals/",
      "leetcodeNumber": 435,
      "description": "Given an array of intervals `intervals` where `intervals[i] = [starti, endi]`, return the minimum number of intervals you need to remove to make the rest of the intervals non-overlapping.\n\n**Example 1:**\n```\nInput: intervals = [[1,2],[2,3],[3,4],[1,3]]\nOutput: 1\nExplanation: [1,3] can be removed and the rest of the intervals are non-overlapping.\n```\n\n**Example 2:**\n```\nInput: intervals = [[1,2],[1,2],[1,2]]\nOutput: 2\nExplanation: You need to remove two [1,2] to make the rest of the intervals non-overlapping.\n```\n\n**Example 3:**\n```\nInput: intervals = [[1,2],[2,3]]\nOutput: 0\nExplanation: You don't need to remove any of the intervals since they're already non-overlapping.\n```\n\n**Constraints:**\n- 1 <= intervals.length <= 10^5\n- intervals[i].length == 2\n- -5 * 10^4 <= starti < endi <= 5 * 10^4",
      "starterCode": "function eraseOverlapIntervals(intervals) {\n  // Your code here\n  \n}",
      "steps": [
        {
          "title": "Understand the Problem",
          "hint": "This is equivalent to finding the maximum number of non-overlapping intervals (interval scheduling problem). The minimum removals = total intervals - maximum non-overlapping intervals.",
          "approach": "This is the classic interval scheduling / activity selection problem. Sort by end time and greedily pick intervals that don't overlap with the previously selected one. The greedy choice is to always pick the interval that ends earliest, as it leaves the most room for future intervals."
        },
        {
          "title": "Sort by Start Time Approach",
          "hint": "Sort by start time. When two intervals overlap, remove the one with the larger end time (it is more likely to cause future overlaps).",
          "approach": "Sort by start time. Track the end of the last kept interval. When the current interval overlaps (start < prevEnd), increment the removal count and keep the interval with the smaller end. Otherwise, update prevEnd.",
          "code": "function eraseOverlapIntervals(intervals) {\n  intervals.sort((a, b) => a[0] - b[0]);\n  let removals = 0;\n  let prevEnd = intervals[0][1];\n  \n  for (let i = 1; i < intervals.length; i++) {\n    if (intervals[i][0] < prevEnd) {\n      // Overlap: remove the one with larger end\n      removals++;\n      prevEnd = Math.min(prevEnd, intervals[i][1]);\n    } else {\n      prevEnd = intervals[i][1];\n    }\n  }\n  \n  return removals;\n}",
          "complexity": "Time: O(n log n), Space: O(1)"
        },
        {
          "title": "Optimal: Sort by End Time (Classic Greedy)",
          "hint": "Sorting by end time is the classic approach for interval scheduling. Always pick the interval that ends earliest.",
          "approach": "Sort by end time. Greedily count the maximum number of non-overlapping intervals by selecting each interval whose start >= the end of the last selected interval. The answer is total - count.",
          "code": "function eraseOverlapIntervals(intervals) {\n  intervals.sort((a, b) => a[1] - b[1]);\n  let count = 1; // count of non-overlapping intervals\n  let prevEnd = intervals[0][1];\n  \n  for (let i = 1; i < intervals.length; i++) {\n    if (intervals[i][0] >= prevEnd) {\n      count++;\n      prevEnd = intervals[i][1];\n    }\n  }\n  \n  return intervals.length - count;\n}",
          "complexity": "Time: O(n log n), Space: O(1)"
        }
      ],
      "testCases": [
        {
          "args": [
            [
              [
                1,
                2
              ],
              [
                2,
                3
              ],
              [
                3,
                4
              ],
              [
                1,
                3
              ]
            ]
          ],
          "expected": 1,
          "description": "Remove [1,3] to eliminate overlap"
        },
        {
          "args": [
            [
              [
                1,
                2
              ],
              [
                1,
                2
              ],
              [
                1,
                2
              ]
            ]
          ],
          "expected": 2,
          "description": "All identical - keep one, remove two"
        },
        {
          "args": [
            [
              [
                1,
                2
              ],
              [
                2,
                3
              ]
            ]
          ],
          "expected": 0,
          "description": "Already non-overlapping"
        }
      ],
      "ankiCards": [
        {
          "id": "non-overlapping-intervals-greedy",
          "front": "Non-overlapping Intervals: Why does sorting by end time and picking the earliest-ending interval work?",
          "back": "This is the classic Activity Selection / Interval Scheduling problem. Sorting by end time and always choosing the earliest-ending non-overlapping interval maximizes the count of intervals we can keep.\n\nIntuition: An interval that ends earlier leaves more room for future intervals. This greedy choice is provably optimal.\n\nAnswer = total intervals - max non-overlapping count.\nTime: O(n log n)"
        },
        {
          "id": "non-overlapping-intervals-overlap-resolution",
          "front": "Non-overlapping Intervals: When two intervals overlap, which one should you remove and why?",
          "back": "Remove the interval with the LARGER end time. It occupies more space and is more likely to overlap with future intervals.\n\nKeep the one with the smaller end time because it frees up more room for subsequent intervals.\n\nThis is the greedy choice that leads to the minimum number of removals."
        }
      ]
    },
    {
      "id": "rotate-image",
      "title": "Rotate Image",
      "difficulty": "Medium",
      "pattern": "math-geometry",
      "leetcodeUrl": "https://leetcode.com/problems/rotate-image/",
      "leetcodeNumber": 48,
      "description": "You are given an `n x n` 2D `matrix` representing an image, rotate the image by 90 degrees (clockwise).\n\nYou have to rotate the image **in-place**, which means you have to modify the input 2D matrix directly. **DO NOT** allocate another 2D matrix and do the rotation.\n\n**Example 1:**\n```\nInput: matrix = [[1,2,3],[4,5,6],[7,8,9]]\nOutput: [[7,4,1],[8,5,2],[9,6,3]]\n```\n\n**Example 2:**\n```\nInput: matrix = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]\nOutput: [[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]\n```\n\n**Constraints:**\n- n == matrix.length == matrix[i].length\n- 1 <= n <= 20\n- -1000 <= matrix[i][j] <= 1000",
      "starterCode": "function rotate(matrix) {\n  // Your code here\n  \n}",
      "steps": [
        {
          "title": "Understand the Problem",
          "hint": "In a 90-degree clockwise rotation, the first row becomes the last column, the second row becomes the second-to-last column, etc. The key constraint is in-place rotation.",
          "approach": "There are two clean approaches: (1) Transpose the matrix then reverse each row, or (2) Rotate four cells at a time layer by layer. Both achieve in-place rotation. The transpose + reverse approach is simpler to implement."
        },
        {
          "title": "Layer-by-Layer Rotation",
          "hint": "Process the matrix in concentric layers (rings). For each layer, rotate four elements at a time in a cycle.",
          "approach": "For each layer from outside to inside, rotate groups of 4 elements: top -> right -> bottom -> left -> top. Use a temporary variable to hold one value during the 4-way swap.",
          "code": "function rotate(matrix) {\n  const n = matrix.length;\n  \n  for (let layer = 0; layer < Math.floor(n / 2); layer++) {\n    const first = layer;\n    const last = n - 1 - layer;\n    \n    for (let i = first; i < last; i++) {\n      const offset = i - first;\n      const top = matrix[first][i]; // save top\n      \n      // left -> top\n      matrix[first][i] = matrix[last - offset][first];\n      // bottom -> left\n      matrix[last - offset][first] = matrix[last][last - offset];\n      // right -> bottom\n      matrix[last][last - offset] = matrix[i][last];\n      // top -> right\n      matrix[i][last] = top;\n    }\n  }\n  \n  return matrix;\n}",
          "complexity": "Time: O(n^2), Space: O(1)"
        },
        {
          "title": "Optimal: Transpose + Reverse Rows",
          "hint": "A 90-degree clockwise rotation is equivalent to transposing the matrix and then reversing each row.",
          "approach": "Step 1: Transpose the matrix (swap matrix[i][j] with matrix[j][i]). Step 2: Reverse each row. This is mathematically equivalent to a 90-degree clockwise rotation and is the cleanest implementation.",
          "code": "function rotate(matrix) {\n  const n = matrix.length;\n  \n  // Step 1: Transpose (swap across diagonal)\n  for (let i = 0; i < n; i++) {\n    for (let j = i + 1; j < n; j++) {\n      [matrix[i][j], matrix[j][i]] = [matrix[j][i], matrix[i][j]];\n    }\n  }\n  \n  // Step 2: Reverse each row\n  for (let i = 0; i < n; i++) {\n    matrix[i].reverse();\n  }\n  \n  return matrix;\n}",
          "complexity": "Time: O(n^2), Space: O(1)"
        }
      ],
      "testCases": [
        {
          "args": [
            [
              [
                1,
                2,
                3
              ],
              [
                4,
                5,
                6
              ],
              [
                7,
                8,
                9
              ]
            ]
          ],
          "expected": [
            [
              7,
              4,
              1
            ],
            [
              8,
              5,
              2
            ],
            [
              9,
              6,
              3
            ]
          ],
          "description": "3x3 matrix rotation"
        },
        {
          "args": [
            [
              [
                5,
                1,
                9,
                11
              ],
              [
                2,
                4,
                8,
                10
              ],
              [
                13,
                3,
                6,
                7
              ],
              [
                15,
                14,
                12,
                16
              ]
            ]
          ],
          "expected": [
            [
              15,
              13,
              2,
              5
            ],
            [
              14,
              3,
              4,
              1
            ],
            [
              12,
              6,
              8,
              9
            ],
            [
              16,
              7,
              10,
              11
            ]
          ],
          "description": "4x4 matrix rotation"
        },
        {
          "args": [
            [
              [
                1
              ]
            ]
          ],
          "expected": [
            [
              1
            ]
          ],
          "description": "1x1 matrix - no change"
        }
      ],
      "ankiCards": [
        {
          "id": "rotate-image-transpose-reverse",
          "front": "Rotate Image 90 degrees clockwise: What is the transpose + reverse approach?",
          "back": "90-degree clockwise rotation = Transpose + Reverse each row\n\n1. Transpose: swap matrix[i][j] with matrix[j][i] for all j > i\n2. Reverse each row\n\nOther rotations:\n- 90 CCW: Transpose + Reverse each column (or Reverse rows + Transpose)\n- 180: Reverse each row, then reverse row order\n\nTime: O(n^2), Space: O(1)"
        },
        {
          "id": "rotate-image-layer-rotation",
          "front": "Rotate Image: How does the layer-by-layer rotation work?",
          "back": "Process concentric rings from outside in:\n- For each layer, rotate 4 elements at a time:\n  top -> temp\n  left -> top\n  bottom -> left\n  right -> bottom\n  temp -> right\n\nNumber of layers: floor(n/2)\nElements per layer: n - 2*layer - 1\n\nTime: O(n^2), Space: O(1)"
        }
      ]
    },
    {
      "id": "spiral-matrix",
      "title": "Spiral Matrix",
      "difficulty": "Medium",
      "pattern": "math-geometry",
      "leetcodeUrl": "https://leetcode.com/problems/spiral-matrix/",
      "leetcodeNumber": 54,
      "description": "Given an `m x n` `matrix`, return all elements of the `matrix` in spiral order.\n\n**Example 1:**\n```\nInput: matrix = [[1,2,3],[4,5,6],[7,8,9]]\nOutput: [1,2,3,6,9,8,7,4,5]\n```\n\n**Example 2:**\n```\nInput: matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]\nOutput: [1,2,3,4,8,12,11,10,9,5,6,7]\n```\n\n**Constraints:**\n- m == matrix.length\n- n == matrix[i].length\n- 1 <= m, n <= 10\n- -100 <= matrix[i][j] <= 100",
      "starterCode": "function spiralOrder(matrix) {\n  // Your code here\n  \n}",
      "steps": [
        {
          "title": "Understand the Problem",
          "hint": "Traverse the matrix in spiral order: right across the top row, down the right column, left across the bottom row, up the left column, then repeat for the inner matrix.",
          "approach": "Maintain four boundaries: top, bottom, left, right. After traversing in each direction, shrink the corresponding boundary. Be careful to check boundaries after each direction to avoid duplicates in non-square matrices."
        },
        {
          "title": "Boundary Simulation",
          "hint": "Use four pointers to track the current boundaries and shrink them inward after each traversal direction.",
          "approach": "Initialize top=0, bottom=m-1, left=0, right=n-1. Traverse right (top row), then top++. Traverse down (right column), then right--. Check if top <= bottom before traversing left (bottom row), then bottom--. Check if left <= right before traversing up (left column), then left++. Repeat until all elements are visited.",
          "code": "function spiralOrder(matrix) {\n  const result = [];\n  let top = 0, bottom = matrix.length - 1;\n  let left = 0, right = matrix[0].length - 1;\n  \n  while (top <= bottom && left <= right) {\n    // Traverse right\n    for (let j = left; j <= right; j++) {\n      result.push(matrix[top][j]);\n    }\n    top++;\n    \n    // Traverse down\n    for (let i = top; i <= bottom; i++) {\n      result.push(matrix[i][right]);\n    }\n    right--;\n    \n    // Traverse left (check boundary)\n    if (top <= bottom) {\n      for (let j = right; j >= left; j--) {\n        result.push(matrix[bottom][j]);\n      }\n      bottom--;\n    }\n    \n    // Traverse up (check boundary)\n    if (left <= right) {\n      for (let i = bottom; i >= top; i--) {\n        result.push(matrix[i][left]);\n      }\n      left++;\n    }\n  }\n  \n  return result;\n}",
          "complexity": "Time: O(m * n), Space: O(1) excluding output"
        },
        {
          "title": "Optimal: Same Approach (Already Optimal)",
          "hint": "The boundary approach visits each element exactly once, making it optimal.",
          "approach": "The boundary simulation is the standard optimal approach. Each element is visited exactly once. The key pitfall is remembering to check boundaries before the left and up traversals to avoid revisiting elements when the matrix is not square.",
          "code": "function spiralOrder(matrix) {\n  if (!matrix.length || !matrix[0].length) return [];\n  \n  const result = [];\n  let top = 0, bottom = matrix.length - 1;\n  let left = 0, right = matrix[0].length - 1;\n  \n  while (top <= bottom && left <= right) {\n    // Right across top row\n    for (let col = left; col <= right; col++) {\n      result.push(matrix[top][col]);\n    }\n    top++;\n    \n    // Down the right column\n    for (let row = top; row <= bottom; row++) {\n      result.push(matrix[row][right]);\n    }\n    right--;\n    \n    // Left across bottom row\n    if (top <= bottom) {\n      for (let col = right; col >= left; col--) {\n        result.push(matrix[bottom][col]);\n      }\n      bottom--;\n    }\n    \n    // Up the left column\n    if (left <= right) {\n      for (let row = bottom; row >= top; row--) {\n        result.push(matrix[row][left]);\n      }\n      left++;\n    }\n  }\n  \n  return result;\n}",
          "complexity": "Time: O(m * n), Space: O(1) excluding output"
        }
      ],
      "testCases": [
        {
          "args": [
            [
              [
                1,
                2,
                3
              ],
              [
                4,
                5,
                6
              ],
              [
                7,
                8,
                9
              ]
            ]
          ],
          "expected": [
            1,
            2,
            3,
            6,
            9,
            8,
            7,
            4,
            5
          ],
          "description": "3x3 matrix spiral"
        },
        {
          "args": [
            [
              [
                1,
                2,
                3,
                4
              ],
              [
                5,
                6,
                7,
                8
              ],
              [
                9,
                10,
                11,
                12
              ]
            ]
          ],
          "expected": [
            1,
            2,
            3,
            4,
            8,
            12,
            11,
            10,
            9,
            5,
            6,
            7
          ],
          "description": "3x4 non-square matrix"
        },
        {
          "args": [
            [
              [
                1
              ]
            ]
          ],
          "expected": [
            1
          ],
          "description": "Single element matrix"
        }
      ],
      "ankiCards": [
        {
          "id": "spiral-matrix-boundaries",
          "front": "Spiral Matrix: What are the four boundaries and how do they change?",
          "back": "Boundaries: top, bottom, left, right\n\nEach spiral cycle:\n1. Traverse RIGHT along top row -> top++\n2. Traverse DOWN along right column -> right--\n3. Traverse LEFT along bottom row (if top <= bottom) -> bottom--\n4. Traverse UP along left column (if left <= right) -> left++\n\nStop when top > bottom OR left > right."
        },
        {
          "id": "spiral-matrix-pitfall",
          "front": "Spiral Matrix: What is the common pitfall with non-square matrices?",
          "back": "After traversing right and down, you MUST check boundaries before traversing left and up:\n- Check top <= bottom before left traversal\n- Check left <= right before up traversal\n\nWithout these checks, you may revisit elements in a single-row or single-column remaining strip. For example, in a 1x4 matrix, after going right, you would incorrectly go left again."
        }
      ]
    },
    {
      "id": "set-matrix-zeroes",
      "title": "Set Matrix Zeroes",
      "difficulty": "Medium",
      "pattern": "math-geometry",
      "leetcodeUrl": "https://leetcode.com/problems/set-matrix-zeroes/",
      "leetcodeNumber": 73,
      "description": "Given an `m x n` integer matrix `matrix`, if an element is `0`, set its entire row and column to `0`'s.\n\nYou must do it **in place**.\n\n**Example 1:**\n```\nInput: matrix = [[1,1,1],[1,0,1],[1,1,1]]\nOutput: [[1,0,1],[0,0,0],[1,0,1]]\n```\n\n**Example 2:**\n```\nInput: matrix = [[0,1,2,0],[3,4,5,2],[1,3,1,5]]\nOutput: [[0,0,0,0],[0,4,5,0],[0,3,1,0]]\n```\n\n**Constraints:**\n- m == matrix.length\n- n == matrix[0].length\n- 1 <= m, n <= 200\n- -2^31 <= matrix[i][j] <= 2^31 - 1\n\n**Follow up:**\n- A straightforward solution using O(mn) space is probably a bad idea.\n- A simple improvement uses O(m + n) space, but still not the best solution.\n- Could you devise a constant space solution?",
      "starterCode": "function setZeroes(matrix) {\n  // Your code here\n  \n}",
      "steps": [
        {
          "title": "Understand the Problem",
          "hint": "If any cell is 0, its entire row and column become 0. The challenge is doing this in-place without using the modified matrix to make incorrect decisions.",
          "approach": "We cannot zero out rows/columns as we scan, because that would affect subsequent checks. We need to first identify which rows and columns need to be zeroed, then apply the changes. The question is: how much extra space do we need for this bookkeeping?"
        },
        {
          "title": "O(m + n) Space: Track Rows and Columns",
          "hint": "Use two sets (or arrays) to record which rows and columns should be zeroed.",
          "approach": "First pass: scan the matrix and record all row indices and column indices that contain a zero. Second pass: for each cell, if its row or column is in the set, set it to 0.",
          "code": "function setZeroes(matrix) {\n  const m = matrix.length;\n  const n = matrix[0].length;\n  const zeroRows = new Set();\n  const zeroCols = new Set();\n  \n  // First pass: find zeros\n  for (let i = 0; i < m; i++) {\n    for (let j = 0; j < n; j++) {\n      if (matrix[i][j] === 0) {\n        zeroRows.add(i);\n        zeroCols.add(j);\n      }\n    }\n  }\n  \n  // Second pass: set zeros\n  for (let i = 0; i < m; i++) {\n    for (let j = 0; j < n; j++) {\n      if (zeroRows.has(i) || zeroCols.has(j)) {\n        matrix[i][j] = 0;\n      }\n    }\n  }\n  \n  return matrix;\n}",
          "complexity": "Time: O(m * n), Space: O(m + n)"
        },
        {
          "title": "Optimal: O(1) Space Using First Row/Column as Markers",
          "hint": "Instead of using extra arrays, use the first row and first column of the matrix itself as markers.",
          "approach": "Use matrix[i][0] to mark if row i should be zeroed. Use matrix[0][j] to mark if column j should be zeroed. Since matrix[0][0] is shared, use a separate variable for either the first row or first column. Process: (1) Mark zeros in first row/col, (2) Zero inner cells based on markers, (3) Handle first row and first column last.",
          "code": "function setZeroes(matrix) {\n  const m = matrix.length;\n  const n = matrix[0].length;\n  let firstRowZero = false;\n  let firstColZero = false;\n  \n  // Check if first row has zero\n  for (let j = 0; j < n; j++) {\n    if (matrix[0][j] === 0) firstRowZero = true;\n  }\n  \n  // Check if first column has zero\n  for (let i = 0; i < m; i++) {\n    if (matrix[i][0] === 0) firstColZero = true;\n  }\n  \n  // Use first row/col as markers for inner cells\n  for (let i = 1; i < m; i++) {\n    for (let j = 1; j < n; j++) {\n      if (matrix[i][j] === 0) {\n        matrix[i][0] = 0;\n        matrix[0][j] = 0;\n      }\n    }\n  }\n  \n  // Zero inner cells based on markers\n  for (let i = 1; i < m; i++) {\n    for (let j = 1; j < n; j++) {\n      if (matrix[i][0] === 0 || matrix[0][j] === 0) {\n        matrix[i][j] = 0;\n      }\n    }\n  }\n  \n  // Zero first row if needed\n  if (firstRowZero) {\n    for (let j = 0; j < n; j++) matrix[0][j] = 0;\n  }\n  \n  // Zero first column if needed\n  if (firstColZero) {\n    for (let i = 0; i < m; i++) matrix[i][0] = 0;\n  }\n  \n  return matrix;\n}",
          "complexity": "Time: O(m * n), Space: O(1)"
        }
      ],
      "testCases": [
        {
          "args": [
            [
              [
                1,
                1,
                1
              ],
              [
                1,
                0,
                1
              ],
              [
                1,
                1,
                1
              ]
            ]
          ],
          "expected": [
            [
              1,
              0,
              1
            ],
            [
              0,
              0,
              0
            ],
            [
              1,
              0,
              1
            ]
          ],
          "description": "Single zero in center"
        },
        {
          "args": [
            [
              [
                0,
                1,
                2,
                0
              ],
              [
                3,
                4,
                5,
                2
              ],
              [
                1,
                3,
                1,
                5
              ]
            ]
          ],
          "expected": [
            [
              0,
              0,
              0,
              0
            ],
            [
              0,
              4,
              5,
              0
            ],
            [
              0,
              3,
              1,
              0
            ]
          ],
          "description": "Zeros in corners of first row"
        },
        {
          "args": [
            [
              [
                1,
                2,
                3
              ],
              [
                4,
                5,
                6
              ]
            ]
          ],
          "expected": [
            [
              1,
              2,
              3
            ],
            [
              4,
              5,
              6
            ]
          ],
          "description": "No zeros - matrix unchanged"
        }
      ],
      "ankiCards": [
        {
          "id": "set-matrix-zeroes-constant-space",
          "front": "Set Matrix Zeroes: How do you achieve O(1) space?",
          "back": "Use the first row and first column as markers:\n1. Track if first row/col originally had zeros (2 booleans)\n2. For inner cells (i>0, j>0): if matrix[i][j]=0, set matrix[i][0]=0 and matrix[0][j]=0\n3. Zero inner cells based on first row/col markers\n4. Handle first row and first column last\n\nOrder matters: zero inner cells BEFORE first row/col to avoid overwriting markers.\n\nTime: O(m*n), Space: O(1)"
        },
        {
          "id": "set-matrix-zeroes-order",
          "front": "Set Matrix Zeroes: Why must the first row and first column be zeroed LAST in the O(1) approach?",
          "back": "The first row and first column serve as markers for which rows/columns to zero.\n\nIf we zero the first row/column early, we destroy the marker information needed to process inner cells.\n\nCorrect order:\n1. Record if first row/col had original zeros\n2. Mark zeros in first row/col (from inner cells)\n3. Zero inner cells using markers\n4. Zero first row/col using saved booleans"
        }
      ]
    },
    {
      "id": "reverse-bits",
      "title": "Reverse Bits",
      "difficulty": "Easy",
      "pattern": "bit-manipulation",
      "leetcodeUrl": "https://leetcode.com/problems/reverse-bits/",
      "leetcodeNumber": 190,
      "description": "Reverse bits of a given 32 bits unsigned integer.\n\n**Note:**\n- In JavaScript, there is no unsigned integer type, so both the input and output will be given as a signed integer. The internal binary representation of the integer is the same, whether it is positive or negative.\n- In JavaScript, bitwise operators treat their operands as a sequence of 32 bits.\n\n**Example 1:**\n```\nInput: n = 43261596 (binary: 00000010100101000001111010011100)\nOutput: 964176192 (binary: 00111001011110000010100101000000)\nExplanation: The input binary string 00000010100101000001111010011100 represents the unsigned integer 43261596, so return 964176192 whose binary representation is 00111001011110000010100101000000.\n```\n\n**Example 2:**\n```\nInput: n = 4294967293 (binary: 11111111111111111111111111111101)\nOutput: 3221225471 (binary: 10111111111111111111111111111111)\n```\n\n**Constraints:**\n- The input must be a binary string of length 32.",
      "starterCode": "function reverseBits(n) {\n  // Your code here\n  \n}",
      "steps": [
        {
          "title": "Understand the Problem",
          "hint": "We need to reverse all 32 bits of a number. For example, bit 0 becomes bit 31, bit 1 becomes bit 30, etc. In JavaScript, use >>> 0 to convert the result to an unsigned 32-bit integer.",
          "approach": "Extract bits from the right side of n one by one, and place them into the result from the left side. This reverses the bit order. Be careful with JavaScript's signed 32-bit behavior: use >>> 0 to get the unsigned representation."
        },
        {
          "title": "Bit-by-Bit Reversal",
          "hint": "Extract the rightmost bit of n, place it in the leftmost available position of the result, then shift n right.",
          "approach": "Process all 32 bits. For each iteration: left-shift result by 1 to make room, OR with (n & 1) to add the rightmost bit of n, then right-shift n by 1. After 32 iterations, use >>> 0 to ensure unsigned result.",
          "code": "function reverseBits(n) {\n  let result = 0;\n  \n  for (let i = 0; i < 32; i++) {\n    result = (result << 1) | (n & 1);\n    n = n >>> 1;\n  }\n  \n  return result >>> 0;\n}",
          "complexity": "Time: O(32) = O(1), Space: O(1)"
        },
        {
          "title": "Optimal: Divide and Conquer (Swap Halves)",
          "hint": "Swap adjacent pairs of bits, then groups of 4, then 8, then 16. This is like a bit-level merge sort reversal.",
          "approach": "Swap bits in progressively larger groups: swap adjacent single bits, then adjacent pairs, then nibbles (4-bit groups), then bytes, then 16-bit halves. This uses 5 constant-time operations.",
          "code": "function reverseBits(n) {\n  // Swap adjacent bits\n  n = ((n & 0xAAAAAAAA) >>> 1) | ((n & 0x55555555) << 1);\n  // Swap pairs\n  n = ((n & 0xCCCCCCCC) >>> 2) | ((n & 0x33333333) << 2);\n  // Swap nibbles\n  n = ((n & 0xF0F0F0F0) >>> 4) | ((n & 0x0F0F0F0F) << 4);\n  // Swap bytes\n  n = ((n & 0xFF00FF00) >>> 8) | ((n & 0x00FF00FF) << 8);\n  // Swap halves\n  n = (n >>> 16) | (n << 16);\n  \n  return n >>> 0;\n}",
          "complexity": "Time: O(1), Space: O(1)"
        }
      ],
      "testCases": [
        {
          "args": [
            43261596
          ],
          "expected": 964176192,
          "description": "Standard case"
        },
        {
          "args": [
            0
          ],
          "expected": 0,
          "description": "All zeros stay all zeros"
        },
        {
          "args": [
            1
          ],
          "expected": 2147483648,
          "description": "Bit 0 becomes bit 31"
        }
      ],
      "ankiCards": [
        {
          "id": "reverse-bits-approach",
          "front": "Reverse Bits: What is the simple bit-by-bit approach?",
          "back": "Loop 32 times:\n1. Left-shift result by 1 to make room\n2. OR result with (n & 1) to add rightmost bit of n\n3. Unsigned right-shift n by 1: n = n >>> 1\n4. Return result >>> 0 (ensure unsigned)\n\nTime: O(32) = O(1), Space: O(1)\n\nKey JS detail: Use >>> (unsigned shift) not >> (signed shift)."
        },
        {
          "id": "reverse-bits-divide-conquer",
          "front": "Reverse Bits: How does the divide-and-conquer bit swap approach work?",
          "back": "Reverse by swapping at progressively larger scales:\n1. Swap adjacent single bits (mask: 0xAAAAAAAA / 0x55555555)\n2. Swap adjacent 2-bit pairs (mask: 0xCCCCCCCC / 0x33333333)\n3. Swap adjacent 4-bit nibbles (mask: 0xF0F0F0F0 / 0x0F0F0F0F)\n4. Swap adjacent bytes (mask: 0xFF00FF00 / 0x00FF00FF)\n5. Swap 16-bit halves\n\n5 constant-time operations. O(1) time and space."
        }
      ]
    },
    {
      "id": "number-of-1-bits",
      "title": "Number of 1 Bits",
      "difficulty": "Easy",
      "pattern": "bit-manipulation",
      "leetcodeUrl": "https://leetcode.com/problems/number-of-1-bits/",
      "leetcodeNumber": 191,
      "description": "Write a function that takes the binary representation of a positive integer and returns the number of set bits it has (also known as the Hamming weight).\n\n**Example 1:**\n```\nInput: n = 11 (binary: 1011)\nOutput: 3\nExplanation: The input binary string 1011 has three set bits.\n```\n\n**Example 2:**\n```\nInput: n = 128 (binary: 10000000)\nOutput: 1\nExplanation: The input binary string 10000000 has one set bit.\n```\n\n**Example 3:**\n```\nInput: n = 2147483645 (binary: 1111111111111111111111111111101)\nOutput: 30\n```\n\n**Constraints:**\n- 1 <= n <= 2^31 - 1\n\n**Note:** In JavaScript, bitwise operations work on 32-bit integers.",
      "starterCode": "function hammingWeight(n) {\n  // Your code here\n  \n}",
      "steps": [
        {
          "title": "Understand the Problem",
          "hint": "We need to count the number of 1 bits in the binary representation of n. This is also called the 'popcount' or 'Hamming weight'.",
          "approach": "We can use bitwise operations to check each bit. JavaScript performs bitwise operations on 32-bit integers. Two approaches: (1) check each of the 32 bits, or (2) use Brian Kernighan's trick to flip the lowest set bit each time."
        },
        {
          "title": "Check Each Bit",
          "hint": "Use n & 1 to check the least significant bit, then right-shift n by 1.",
          "approach": "Check the last bit using n & 1. If it is 1, increment the count. Then unsigned right-shift n by 1 (n >>> 1) to process the next bit. Repeat 32 times or until n becomes 0.",
          "code": "function hammingWeight(n) {\n  let count = 0;\n  \n  while (n !== 0) {\n    count += n & 1;\n    n = n >>> 1; // unsigned right shift\n  }\n  \n  return count;\n}",
          "complexity": "Time: O(32) = O(1), Space: O(1)"
        },
        {
          "title": "Optimal: Brian Kernighan's Algorithm",
          "hint": "n & (n - 1) removes the lowest set bit. Count how many times you can do this until n becomes 0.",
          "approach": "The expression n & (n - 1) clears the lowest set bit of n. For example: 1100 & 1011 = 1000. Each iteration removes exactly one set bit, so the number of iterations equals the number of set bits. This is faster when the number of 1 bits is small.",
          "code": "function hammingWeight(n) {\n  let count = 0;\n  \n  while (n !== 0) {\n    n = n & (n - 1); // clear lowest set bit\n    count++;\n  }\n  \n  return count;\n}",
          "complexity": "Time: O(k) where k is number of set bits, Space: O(1)"
        }
      ],
      "testCases": [
        {
          "args": [
            11
          ],
          "expected": 3,
          "description": "Binary 1011 has three 1-bits"
        },
        {
          "args": [
            128
          ],
          "expected": 1,
          "description": "Binary 10000000 has one 1-bit"
        },
        {
          "args": [
            255
          ],
          "expected": 8,
          "description": "Binary 11111111 has eight 1-bits"
        }
      ],
      "ankiCards": [
        {
          "id": "number-of-1-bits-kernighan",
          "front": "Number of 1 Bits: What does n & (n - 1) do, and how is it used to count set bits?",
          "back": "n & (n - 1) clears the LOWEST set bit of n.\n\nExample: n = 1100, n-1 = 1011\nn & (n-1) = 1000 (lowest 1-bit removed)\n\nTo count set bits: repeatedly apply n = n & (n-1) until n = 0. Count iterations.\n\nThis is Brian Kernighan's algorithm. Time: O(k) where k = number of set bits."
        },
        {
          "id": "number-of-1-bits-js-shift",
          "front": "Number of 1 Bits: Why use >>> (unsigned right shift) instead of >> in JavaScript?",
          "back": "In JavaScript:\n- >> (signed right shift): preserves the sign bit. For negative numbers, it fills with 1s from the left.\n- >>> (unsigned right shift): always fills with 0s from the left.\n\nSince we're treating n as an unsigned 32-bit integer, we must use >>> to avoid infinite loops when the sign bit is set."
        }
      ]
    },
    {
      "id": "missing-number",
      "title": "Missing Number",
      "difficulty": "Easy",
      "pattern": "bit-manipulation",
      "leetcodeUrl": "https://leetcode.com/problems/missing-number/",
      "leetcodeNumber": 268,
      "description": "Given an array `nums` containing `n` distinct numbers in the range `[0, n]`, return the only number in the range that is missing from the array.\n\n**Example 1:**\n```\nInput: nums = [3,0,1]\nOutput: 2\nExplanation: n = 3 since there are 3 numbers, so all numbers are in the range [0,3]. 2 is the missing number since it does not appear in nums.\n```\n\n**Example 2:**\n```\nInput: nums = [0,1]\nOutput: 2\nExplanation: n = 2 since there are 2 numbers, so all numbers are in the range [0,2]. 2 is the missing number since it does not appear in nums.\n```\n\n**Example 3:**\n```\nInput: nums = [9,6,4,2,3,5,7,0,1]\nOutput: 8\n```\n\n**Constraints:**\n- n == nums.length\n- 1 <= n <= 10^4\n- 0 <= nums[i] <= n\n- All the numbers of nums are unique.\n\n**Follow up:** Could you implement a solution using only O(1) extra space complexity and O(n) runtime complexity?",
      "starterCode": "function missingNumber(nums) {\n  // Your code here\n  \n}",
      "steps": [
        {
          "title": "Understand the Problem",
          "hint": "The array has n numbers from the range [0, n], so exactly one number is missing. We can use math (sum formula) or XOR to find it.",
          "approach": "Two elegant approaches: (1) Sum formula: the sum of 0 to n should be n*(n+1)/2. Subtract the actual sum to find the missing number. (2) XOR: XOR all array values with all numbers 0 to n. Since x ^ x = 0, all pairs cancel out, leaving the missing number."
        },
        {
          "title": "Math: Sum Formula",
          "hint": "The expected sum of 0 to n is n*(n+1)/2. Subtract the actual sum of the array.",
          "approach": "Calculate the expected total sum using the formula n*(n+1)/2. Then subtract each element of the array. The remainder is the missing number.",
          "code": "function missingNumber(nums) {\n  const n = nums.length;\n  const expectedSum = (n * (n + 1)) / 2;\n  const actualSum = nums.reduce((sum, num) => sum + num, 0);\n  return expectedSum - actualSum;\n}",
          "complexity": "Time: O(n), Space: O(1)"
        },
        {
          "title": "Optimal: XOR Approach",
          "hint": "XOR a number with itself gives 0. XOR with 0 gives the number. XOR all indices and all values together.",
          "approach": "XOR all numbers from 0 to n with all elements in the array. Every number that appears in both will cancel out (x ^ x = 0), leaving only the missing number. This avoids any potential integer overflow issues that the sum approach might have in other languages.",
          "code": "function missingNumber(nums) {\n  let xor = nums.length; // start with n\n  \n  for (let i = 0; i < nums.length; i++) {\n    xor ^= i ^ nums[i];\n  }\n  \n  return xor;\n}",
          "complexity": "Time: O(n), Space: O(1)"
        }
      ],
      "testCases": [
        {
          "args": [
            [
              3,
              0,
              1
            ]
          ],
          "expected": 2,
          "description": "Missing 2 from [0,3]"
        },
        {
          "args": [
            [
              0,
              1
            ]
          ],
          "expected": 2,
          "description": "Missing number is n"
        },
        {
          "args": [
            [
              9,
              6,
              4,
              2,
              3,
              5,
              7,
              0,
              1
            ]
          ],
          "expected": 8,
          "description": "Larger array, missing 8"
        }
      ],
      "ankiCards": [
        {
          "id": "missing-number-xor",
          "front": "Missing Number: How does the XOR approach find the missing number?",
          "back": "XOR all indices (0 to n-1) and all array values, starting with n:\n\nxor = n\nfor i in 0..n-1: xor ^= i ^ nums[i]\n\nSince XOR is commutative and x ^ x = 0:\n- Every number that exists in both the range and the array cancels out\n- The missing number appears only in the range, so it survives\n\nTime: O(n), Space: O(1)"
        },
        {
          "id": "missing-number-sum",
          "front": "Missing Number: What are two O(n) approaches and when would you prefer one over the other?",
          "back": "1. Sum formula: missing = n*(n+1)/2 - sum(nums)\n   - Simple and intuitive\n   - Potential overflow for very large n (not an issue in JS with Number, but is in languages with fixed-size integers)\n\n2. XOR: xor all indices with all values\n   - No overflow risk\n   - Slightly less intuitive\n\nBoth are O(n) time, O(1) space. XOR is generally safer across languages."
        }
      ]
    },
    {
      "id": "counting-bits",
      "title": "Counting Bits",
      "difficulty": "Easy",
      "pattern": "bit-manipulation",
      "leetcodeUrl": "https://leetcode.com/problems/counting-bits/",
      "leetcodeNumber": 338,
      "description": "Given an integer `n`, return an array `ans` of length `n + 1` such that for each `i` (0 <= i <= n), `ans[i]` is the number of `1`'s in the binary representation of `i`.\n\n**Example 1:**\n```\nInput: n = 2\nOutput: [0,1,1]\nExplanation:\n0 --> 0 (zero 1-bits)\n1 --> 1 (one 1-bit)\n2 --> 10 (one 1-bit)\n```\n\n**Example 2:**\n```\nInput: n = 5\nOutput: [0,1,1,2,1,2]\nExplanation:\n0 --> 0\n1 --> 1\n2 --> 10\n3 --> 11\n4 --> 100\n5 --> 101\n```\n\n**Constraints:**\n- 0 <= n <= 10^5\n\n**Follow up:**\n- Can you do it in O(n) time and O(n) space (not counting the output array)?",
      "starterCode": "function countBits(n) {\n  // Your code here\n  \n}",
      "steps": [
        {
          "title": "Understand the Problem",
          "hint": "We need the popcount for every number from 0 to n. Computing each independently takes O(log n) per number, but we can use dynamic programming to do it in O(1) per number.",
          "approach": "Key insight: the number of set bits in i relates to a smaller number we have already computed. Several DP relationships work: (1) ans[i] = ans[i >> 1] + (i & 1), meaning we can get the count by looking at i without its last bit and adding back whether the last bit is 1."
        },
        {
          "title": "Brute Force: Count Bits for Each Number",
          "hint": "Use any bit-counting method (like Brian Kernighan's) for each number from 0 to n.",
          "approach": "For each number i from 0 to n, count its set bits individually using n & (n-1) trick.",
          "code": "function countBits(n) {\n  const ans = new Array(n + 1);\n  \n  for (let i = 0; i <= n; i++) {\n    let count = 0;\n    let num = i;\n    while (num !== 0) {\n      num = num & (num - 1);\n      count++;\n    }\n    ans[i] = count;\n  }\n  \n  return ans;\n}",
          "complexity": "Time: O(n log n), Space: O(n)"
        },
        {
          "title": "Optimal: DP with Bit Relationship",
          "hint": "ans[i] = ans[i >> 1] + (i & 1). Right-shifting i by 1 gives a number we have already computed.",
          "approach": "For any number i: i >> 1 is i divided by 2 (removing the last bit), which we have already computed. We just need to add back whether the last bit of i is 1 (i & 1). This gives O(1) per number.",
          "code": "function countBits(n) {\n  const ans = new Array(n + 1).fill(0);\n  \n  for (let i = 1; i <= n; i++) {\n    ans[i] = ans[i >> 1] + (i & 1);\n  }\n  \n  return ans;\n}",
          "complexity": "Time: O(n), Space: O(n)"
        }
      ],
      "testCases": [
        {
          "args": [
            2
          ],
          "expected": [
            0,
            1,
            1
          ],
          "description": "Count bits for 0 to 2"
        },
        {
          "args": [
            5
          ],
          "expected": [
            0,
            1,
            1,
            2,
            1,
            2
          ],
          "description": "Count bits for 0 to 5"
        },
        {
          "args": [
            0
          ],
          "expected": [
            0
          ],
          "description": "Only number 0"
        }
      ],
      "ankiCards": [
        {
          "id": "counting-bits-dp",
          "front": "Counting Bits: What is the DP recurrence to count set bits for all numbers 0 to n in O(n)?",
          "back": "ans[i] = ans[i >> 1] + (i & 1)\n\nExplanation:\n- i >> 1 removes the last bit of i (already computed since i>>1 < i)\n- (i & 1) checks if the last bit is 1\n- We add back the last bit's contribution\n\nExample: i=5 (101)\n- 5 >> 1 = 2 (10), ans[2] = 1\n- 5 & 1 = 1\n- ans[5] = 1 + 1 = 2\n\nTime: O(n), Space: O(n)"
        },
        {
          "id": "counting-bits-alt-recurrence",
          "front": "Counting Bits: What alternative DP recurrences exist besides ans[i] = ans[i>>1] + (i&1)?",
          "back": "1. ans[i] = ans[i & (i-1)] + 1\n   (i & (i-1) clears the lowest set bit, which is a smaller already-computed number, plus 1 for the cleared bit)\n\n2. ans[i] = ans[i - highestBit] + 1\n   (subtract the highest power of 2, then add 1)\n\nAll achieve O(n) time with O(n) space."
        }
      ]
    },
    {
      "id": "sum-of-two-integers",
      "title": "Sum of Two Integers",
      "difficulty": "Medium",
      "pattern": "bit-manipulation",
      "leetcodeUrl": "https://leetcode.com/problems/sum-of-two-integers/",
      "leetcodeNumber": 371,
      "description": "Given two integers `a` and `b`, return the sum of the two integers without using the operators `+` and `-`.\n\n**Example 1:**\n```\nInput: a = 1, b = 2\nOutput: 3\n```\n\n**Example 2:**\n```\nInput: a = 2, b = 3\nOutput: 5\n```\n\n**Example 3:**\n```\nInput: a = -1, b = 1\nOutput: 0\n```\n\n**Constraints:**\n- -1000 <= a, b <= 1000\n\n**Note:** In JavaScript, bitwise operations use 32-bit signed integers. The carry propagation must be masked to 32 bits to handle negative numbers correctly.",
      "starterCode": "function getSum(a, b) {\n  // Your code here\n  \n}",
      "steps": [
        {
          "title": "Understand the Problem",
          "hint": "Think about how binary addition works at the bit level. Adding two bits: 0+0=0, 0+1=1, 1+0=1, 1+1=10 (0 with carry 1). XOR gives the sum without carry. AND gives the carry positions.",
          "approach": "Binary addition without +/- uses two operations: XOR (^) computes the sum ignoring carries, AND (&) finds positions where carries occur. The carry must be shifted left by 1 (since carry goes to the next higher bit). Repeat until there is no carry."
        },
        {
          "title": "Iterative Bit Addition",
          "hint": "a ^ b gives sum without carry. (a & b) << 1 gives the carry. Repeat with the new sum and carry until carry is 0.",
          "approach": "In each iteration: compute the sum without carry (a ^ b) and the carry ((a & b) << 1). Set a to the sum and b to the carry. Repeat until b (carry) is 0. In JavaScript, mask with 0xFFFFFFFF to keep values within 32 bits.",
          "code": "function getSum(a, b) {\n  while (b !== 0) {\n    const carry = (a & b) << 1;\n    a = a ^ b;\n    b = carry;\n  }\n  return a;\n}",
          "complexity": "Time: O(32) = O(1), Space: O(1)"
        },
        {
          "title": "Optimal: Handle JavaScript 32-bit Masking",
          "hint": "JavaScript numbers are 64-bit floats but bitwise ops use 32-bit signed integers. For negative numbers, we need to mask to 32 bits to prevent infinite carry propagation.",
          "approach": "Mask carry and result with 0xFFFFFFFF to stay within 32 bits. After the loop, if a > 0x7FFFFFFF (sign bit is set), the result is negative in 32-bit representation; use ~(a ^ 0xFFFFFFFF) to convert.",
          "code": "function getSum(a, b) {\n  const MASK = 0xFFFFFFFF;\n  const MAX_INT = 0x7FFFFFFF;\n  \n  while (b !== 0) {\n    const carry = ((a & b) & MASK) << 1;\n    a = (a ^ b) & MASK;\n    b = carry & MASK;\n  }\n  \n  // If a is greater than MAX_INT, it is negative in 32-bit\n  return a <= MAX_INT ? a : ~(a ^ MASK);\n}",
          "complexity": "Time: O(32) = O(1), Space: O(1)"
        }
      ],
      "testCases": [
        {
          "args": [
            1,
            2
          ],
          "expected": 3,
          "description": "Simple positive addition"
        },
        {
          "args": [
            2,
            3
          ],
          "expected": 5,
          "description": "Two positive numbers"
        },
        {
          "args": [
            -1,
            1
          ],
          "expected": 0,
          "description": "Negative and positive cancel out"
        }
      ],
      "ankiCards": [
        {
          "id": "sum-of-two-integers-bit-ops",
          "front": "Sum of Two Integers: How do XOR and AND simulate addition?",
          "back": "XOR (^): gives the sum of two bits without carry\n  0^0=0, 0^1=1, 1^0=1, 1^1=0\n\nAND (&): identifies where carries occur\n  1&1=1 (carry needed), all others=0\n\nShift carry left by 1: carry goes to next bit position.\n\nRepeat: a = a ^ b (sum), b = (a & b) << 1 (carry)\nStop when carry (b) is 0.\n\nTime: O(32) = O(1)"
        },
        {
          "id": "sum-of-two-integers-js-mask",
          "front": "Sum of Two Integers: Why do you need to mask with 0xFFFFFFFF in JavaScript?",
          "back": "JavaScript numbers are 64-bit floats, but bitwise operations work on 32-bit signed integers. When dealing with negative numbers, the carry can propagate beyond 32 bits, causing an infinite loop.\n\nMasking with 0xFFFFFFFF (all 32 bits set) keeps values within 32-bit range.\n\nAfter the loop, if result > 0x7FFFFFFF (sign bit set), convert to negative with ~(result ^ 0xFFFFFFFF)."
        }
      ]
    }
  ]
}
